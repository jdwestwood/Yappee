// this version of web.js serves only the main page and the Google content; it relies on web_EPO.js on port 8081 to serve
// the EPO biblio data; the servers are separated in this way because the EPO OPS API blacklists some of the Heroku
// servers; get around this by always querying EPO from my AWS development server, even when the app is deployed on
// Heroku.

var express = require('express');                         // use 'npm install express' to install this nodejs package
var http = require('http');                               // part of nodejs
var https = require('https');
var fs = require('fs');
var crypto = require('crypto');                           // part of nodejs

// memcached (local server) or MemCachier (Heroku) client; on local server; start memcached server using 'memcached -vv -d';
// on Heroku, need to add the MemCachier service; default server:port is 127.0.0.1:11211
var ONE_WEEK = 7*24*60*60;                // cache expiration time in seconds
var MemJS = require('memjs').Client;      // external package; memjs is the memcached client used on Heroku that also works locally
// creat the memcache (local) or MemCachier (Heroku) client; the first argument is the config string for the memcached
// server and port, which has the form "[user:pass@]server1:[11211]"; on the local EC2 instance, the empty string defaults
// to 127.0.0.1:11211.
var memjs = MemJS.create("", {expires: ONE_WEEK});

// secret for signed cookies; use an environmental variable so secret stays the same across server restarts
const COOKIE_SECRET = process.env.COOKIE_SECRET;

var DEBUG_FLAG = false;
process.argv.forEach(function(value) {                 // get debug flag, if any, from command line and set DEBUG_FLAG
    switch (value) {
      case '-d': case '-debug':
        DEBUG_FLAG = true;
        break;
      default:                                         // if not set on command line, check environment variable DEBUG
        if (process.env.DEBUG && process.env.DEBUG.toLowerCase() == 'true') DEBUG_FLAG = true;
    }
  });

var indexFile = (DEBUG_FLAG) ? 'indexDev.html' : 'index.html';   // set homepage file according to DEBUG_FLAG

function createRandomString() {
// create a random number as a base64 string.
  var hash = crypto.createHash('sha1');
  var seed = Math.random().toString();
  hash.update(seed, 'utf8');
  return hash.digest('base64');
}

var googleHost = 'www.google.com';
var googleURL = '';
var googlePath = '';
var googleReqParam = {};
var googleReq;0

var app = express();                                    // create the server

// set secret for signed cookies; signed cookies prove that request back from client is using a cookie that came from
// this server
app.use(express.cookieParser(COOKIE_SECRET));

// track user sessions
var sessionCookie = 'yappee_id';
var clientCookie = 'yappee_cl';
var sessionList = {};

// express.logger is the same as connect.logger - documentation is at www.senchalabs.org/connect/logger.html
app.use(express.logger('default'));
// give access to 'lib' directory tree so can serve .css and .js files referenced in index.html  
app.use(express.static(__dirname + '/lib'));

var indexHTML = fs.readFileSync(indexFile, {'encoding': 'utf-8'});           // returns a buffer unless encoding is specified

app.get('/*', function(clientReq, serverResp) {         // clientReq is an instance of express Request object, which inherits from
  var url = clientReq.url;
  debug_log("\nGET request received for url:" + url);
  switch (true) {                              // http.IncomingMessage and stream.Readable; serverResp is an instance of express
    case url == '/':                           // Response object, inherits from http.ServerResponse stream.Writable
      clientReqLogging(clientReq, 'GET');
      setupSessionCookie(clientReq, serverResp);
      serverResp.send(indexHTML);
      break;
    case url.slice(0,10) == '/jsverify/':
      // send the yappee_cl cookie in response to an ajax request from the client when the main page loads
      verifyCookies(clientReq, processJSVerify, denyGETReq, true);
      break;

      function processJSVerify(success) {
      // callback for verifyCookies when the GET request for /jsverify/ has valid session cookie
        debug_log(success);
        setupClientCookie(clientReq, serverResp);
        serverResp.send("");
      }
    default:
      // if GET request has valid session cookie (generated by server) and client-generated cookie present with value
      // the same as the session cookie, then send the request on to Google; otherwise send 404 error.
      verifyCookies(clientReq, processGETReq, denyGETReq, false);
      break;

      function processGETReq(success) {
      // callback for verifyCookies when the GET request has valid cookies; success is a string containing cookie values found
        debug_log(success);
        googleReqHeader = prepGoogleReqHeader(clientReq);
        // make all requests to Google as https: to port 443, but send responses and redirects back to client as http: on port 8080
        googleReqParam = HTTPRequestParameters(googleHost, url, 'GET', 443, googleReqHeader);
        googleReq = https.request(googleReqParam, function(googleResp) {
                                                    processRes(googleReqParam, googleResp, clientReq, serverResp);
                                                  });
        googleReq.end();
      }

      function denyGETReq(error) {
      // callback for verifyCookies when the GET request has invalid cookies; error is a string describing the error encountered.
        serverResp.send(404);
        clientReqLogging(clientReq, 'GET');
        debug_log(error);
        console.log("\nResponded to GET request with 404 error");
      }
  }
});

app.head('/*', function(clientReq, serverResp) {
  var url = clientReq.url;
  debug_log("\nHEAD request received for url:" + url);
  // if HEAD request has valid session cookie (generated by server) and valid client cookie (generated by javascript in the
  // client), then send the request on to Google; otherwise send 404 error.
  verifyCookies(clientReq, processHEADReq, denyHEADReq, false);

  function processHEADReq(success) {
  // callback for verifyCookies when the HEAD request has valid cookies.
    debug_log(success);
    switch (true) {
      case /^\/patents\//.test(url):
        googleReqHeader = prepGoogleReqHeader(clientReq);
        googleReqParam = HTTPRequestParameters(googleHost, url, 'HEAD', 443, googleReqHeader);
        googleReq = https.request(googleReqParam, function(googleResp) {
                                                    processRes(googleReqParam, googleResp, clientReq, serverResp);
                                                  });
        googleReq.end();
        break;
      default:
        // this should never happen
        console.log("Unexpected url in HEAD request.");
        denyHEADReq("Unexpected url in HEAD request with valid cookies");
    }
  }

  function denyHEADReq(error) {                                            // invalid cookies
  // callback for verifyCookies when the HEAD request has invalid cookies; error is a string describing the error encountered.
    serverResp.send(404);
    clientReqLogging(clientReq, 'HEAD');
    debug_log(error);
    console.log("\nResponded to HEAD request with 404 error");
  }
});

app.post('/*', function(clientReq, serverResp) {     // clientReq is an instance of express Request object, which inherits from
  var url = clientReq.url;                           // http.IncomingMessage and stream.Readable; serverResp is instance of express
  debug_log("\nPOST request received for url:" + url);   // Response object, inherits from http.ServerResponse stream.Writable
  // if POST request has valid session cookie (generated by server) and valid client cookie (generated by javascript in the
  // client), then send the request to the EPO API.
  verifyCookies(clientReq, processPOSTReq, denyPOSTReq, false);

  function processPOSTReq(success) {
  // callback for verifyCookies when the POST request has valid cookies.
    debug_log(success);
    clientReqLogging(clientReq, 'POST');
    switch (true) {
      case url == '/' || url == '/yappee/':            // do not respond to POST request
        denyPOSTReq('In processPOSTReq, received POST request for main page');
        break;
      case url == '/epoapi/biblio':
        // response to EPO biblio requests is handled in a separate server web_EPO.js listening on port 8081
        denyPOSTReq('In processPOSTReq, unexpectedly received POST request for EPO biblio data on port 8080');
        break;
      default:
        googleReqHeader = prepGoogleReqHeader(clientReq);
        googleReqParam = HTTPRequestParameters(googleHost, url, 'POST', 80, googleReqHeader);
        googleReq = http.request(googleReqParam, function(googleResp) {
                                                   processRes(googleReqParam, googleResp, clientReq, serverResp);
                                                 });
        // 'data' and 'end' events inherited from nodejs Readable stream
        clientReq.on('data', function(chunk) {googleReq.write(chunk);} );
        clientReq.on('end', function() { googleReq.end();} );
    }
  }

  function denyPOSTReq(error) {                                        // invalid Cookies, do not respond
    serverResp.send(404);
    clientReqLogging(clientReq, 'POST');
    debug_log(error);
    console.log("\nResponded to POST request with 404 error");
  }
});

function prepGoogleReqHeader(clientReq) {
  console.log('\nIn prepGoogleReqHeader, received clientReq from ' + clientReq.ip + ' for host \'' + clientReq.headers['host']
                + '\' and url \'' + clientReq.url + '\'');
  var googleReqHeader = JSON.parse(JSON.stringify(clientReq.headers));
  delete googleReqHeader.host;
  debug_log("In prepGoogleReqHeader, incoming header is", googleReqHeader);
  prepareHeaderCookies(googleReqHeader);
  delete googleReqHeader.referer;
  debug_log('Header for request to Google: ', googleReqHeader);
  return googleReqHeader;
}

function prepareHeaderCookies(header) {
// remove sessionCookie and clientCookie from HTTP header 'header' object
  var cookieList = header['cookie'].split('; ');
debug_log("\nIncoming cookieList: ", cookieList);
  var cookieNameList = cookieList.map(function(s) {return s.slice(0, s.indexOf('='));});
  removeCookie(sessionCookie);
  removeCookie(clientCookie);
  var newCookieList = cookieList.filter(function(s) {return (s != "");});
  if (newCookieList.length > 0) {
    header['cookie'] = newCookieList.join('; ');
  }
  else {
    delete header['cookie'];
  }
debug_log("\nOutgoing newCookieList: ", newCookieList);

  function removeCookie(cookieName) {
  // removes cookieName from cookieList
    var i = cookieNameList.indexOf(cookieName);
    if (i != -1) {
      cookieList[i] = "";
    }
    else {
      debug_log("In removeCookie, did not find cookie: " + cookieName);
    }
  }
}

function clientReqLogging(clientReq, type) {
    console.log('\nIn clientReqLogging, received ' + type + ' request from ' + clientReq.ip + 
                '\nfor host \'' + clientReq.headers['host'] + '\' and url \'' + clientReq.url + 
                '\'\nwith referer \'' + clientReq.headers['referer']) + '\'';
    debug_log('\nRequest headers are:\n', clientReq.headers);
}

var port = process.env.PORT || 8080                 // 5000 was default setting; 8080 is conventional setting for website debug
app.listen(port, function() {
  console.log("Listening on " + port);
});

function processRes(extReq, extResp, clientReq, serverResp) {
// extReq is an object returned from HTTPRequestParameters - instance of http.ServerResponse;
// extResp is instance of http.IncomingMessage; clientReq is instance of express Request object
// and serverResp is instance of express Response object (as described above)

  console.log('\nIn processRes, response statusCode: ' + extResp.statusCode);
  debug_log(extResp.headers);

  // make copy of the extResp headers, so can modify them if needed before relaying to the client
  serverRespHeader = JSON.parse(JSON.stringify(extResp.headers));

  // clientReq has been redirected; need to substitute the server host for the external host in the redirected location url
  if (extResp.statusCode == '302') {
    var extRedirectedLoc = extResp.headers['location'];
    var serverRedirectedLoc = extRedirectedLoc.replace(extReq['host'], clientReq.headers['host']);
      // make all requests to Google as https: to port 443, but send responses and redirects back to client as http: on port 8080
    serverRedirectedLoc = serverRedirectedLoc.replace('https', 'http');
    debug_log('extRedirectedLoc: ' + extRedirectedLoc);
    debug_log('serverRedirectedLoc: ' + serverRedirectedLoc);
    serverRespHeader['location'] = serverRedirectedLoc;
  }

  serverResp.writeHead(extResp.statusCode, serverRespHeader);

  extResp.on('data', function(chunk) {
      serverResp.write(chunk);
  });
  extResp.on('end', function() {
    serverResp.end();
  });
}

function HTTPRequestParameters(host, path, method, port, headers) {
  return {host: host,
          path: path,
          method: method,
          port: port,
          headers: headers
         };
}

function setupSessionCookie(clientReq, serverResp) {
// called when user requests the main page
  var sValue = clientReq.signedCookies[sessionCookie];
  // if client requests the main page '/' and does not have an sessionCookie
  if (sValue) {
    debug_log("\nIn setupSessionCookie, client sent session cookie " + sessionCookie + ": " + sValue);
  }
  else {
    var sValue = createRandomString();
    // send a session cookie; 'httpOnly' means not accessible from javascript on the client side; default 'domain'
    // is the domain of this server; default path is '/' (i.e., all paths that begin with '/'); do not send from
    // https only ('secure' not set).
    serverResp.cookie(sessionCookie, sValue, {signed: true, httpOnly: true});  // send session cookie as browser session cookie
    debug_log("\nIn setupSessionCookie, sending new session cookie " + sessionCookie + ": " + sValue);
  }
  sessionList[sValue] = {};                                                    // create entry in sessionList
}

function setupClientCookie(clientReq, serverResp) {
// called when a GET request is made to /jsverify/; main page load triggers an ajax request for the string that
// will be set as the value of the 'yappee_cl' cookie every time a request for Google data is made by the js.
  // create a clientCookie will be accessed by client-side javascript and returned with each subsequent HTTP request
  var sValue = clientReq.signedCookies[sessionCookie];
  if (sValue) {
    var cValue = createRandomString();
    sessionList[sValue] = {"cValue": cValue};
    serverResp.cookie(clientCookie, cValue, {signed: true});                    // send client cookie as browser session cookie
    debug_log("\nIn setupClientCookie, sending client cookie " + clientCookie + ": " + cValue);
    memjs.set(sValue, cValue, function(err, success) {}, ONE_WEEK);             // cache the sessionCookie/clientCookie key/value
  }
  else {
    debug_log("\nIn setupClientCookie, did not get a session cookie " + sessionCookie +
              ", so will not send client cookie " + clientCookie);
  }
}

function verifyCookies(clientReq, validCookies, invalidCookies, sessionOnly) {
// check the cookies in a HTTP request; callback validCookies when cookies are valid; callback invalidCookies when cookies
// are not valid; sessionOnly is a boolean which if true, only the session cookie is verified
  this.returnStr = "";
  verifySessionCookie(clientReq, on_SessionVerify.bind(this));

  function verifySessionCookie(clientReq, on_SessionVerify) {
  // check if clientReq contains a valid session cookie; on_SessionVerify is the callback.
    var sValue = clientReq.signedCookies[sessionCookie];
    if (sValue) {
      if (sessionList[sValue]) {
        on_SessionVerify({"success" : "From server memory, got valid session cookie " + sValue});
      }
      else {
        // server was put to sleep then sessionList does not contain key/value sValue/cValue, so check the memcache
        memjs.get(sValue, on_check_cookie_cache);
      }
    }
    else {
      on_SessionVerify({"error": "No session cookie from client"});
    }

    function on_check_cookie_cache(err, value, key) {
    // callback for the memcache get request for the sessionCookie value sValue; if the sValue is not found, both value and key
    // null; otherwise they are buffers.
      if (key && value) {
        sessionList[sValue] = {"cValue": value.toString()};                              // recreate the cookies in sessionList;
        on_SessionVerify({"success": "From cache, got valid session cookie " + sValue});
      }
      else {
        on_SessionVerify({"error": "From cache, session cookie " + sValue + " not found"});
      }
    }
  }

  function on_SessionVerify(message) {
  // callback for verifySessionCookie; message is an object containing either a 'success' or an 'error' key
    if (message.success) {
      this.returnStr += message.success;
      if (sessionOnly) {
        validCookies(this.returnStr);
      }
      else {
        verifyClientCookie(clientReq, on_ClientVerify.bind(this));
      }
    }
    else if (message.error) {
      this.returnStr += message.error;
      invalidCookies(returnStr);
    }
    else {
      debug_log("In verifyCookies, unexpected 'message' returned in on_SessionVerify");
    }
  }

  function verifyClientCookie(clientReq, on_ClientVerify) {
  // check if clientReq contains a valid client cookie; on_ClientVerify is the callback.
    var sValue = clientReq.signedCookies[sessionCookie];
    var cValue = clientReq.signedCookies[clientCookie];
    if (cValue) {
      if (sessionList[sValue]["cValue"] == cValue) {
        on_ClientVerify({"success": "; and got valid client cookie " + cValue});
      }
      else {
        on_ClientVerify({"error": "; but stored client cookie " + sessionList[sValue]["cValue"] +
                                  " does not match cookie from client " + cValue});
      }
    }
    else {
        on_ClientVerify({"error": "; but no client cookie from client"});
    }
  }

  function on_ClientVerify(message) {
  // callback for verifyClientCookie; message is an object containing either a 'success' or an 'error' key
    if (message.success) {
      this.returnStr += message.success;
      validCookies(this.returnStr);
    }
    else if (message.error) {
      this.returnStr += message.error;
      invalidCookies(this.returnStr);
    }
    else {
      debug_log("In verifyCookies, unexpected 'message' returned in on_ClientVerify");
    }
  }
}

function debug_log() {
// use debug_log() instead of console.log() to control when logging to console occurs with DEBUG_FLAG.
  DEBUG_FLAG && console.log.apply(console, arguments);
}

function normal_log() {
// use normal_log() instead of console.log() to control when0 logging to console occurs with DEBUG_FLAG.
  !DEBUG_FLAG && console.log.apply(console, arguments);
}
