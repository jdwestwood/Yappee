<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Patent visualization</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen">
    <script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/md5.js"></script>
    <script src="http://code.jquery.com/jquery.js"></script>
    <script src="/js/jquery.cookie-1.4.0.js"></script>
    <script src="/js/bootstrap.min.js"></script>
    <script src="/js/underscore.js"></script>
    <script src="/js/moment.min.js"></script>
    <script src="/js/d3.v3.min.js" charset="utf-8"></script>
<!--  <script src="/js/innersvg.js" charset="utf-8"></script> to be able to set '.innerHTML' (or '.innerSVG') on SVG elements -->
    <link rel="stylesheet" href="/css/jdwmainpage.css">
  </head>

  <body>
    <ul class="nav nav-tabs" id="topTabs">
      <li class="active">
	<a id="patMap" href="#Map" data-toggle="tab">Map</a>
      </li>
      <li>
	<a id="gAdvSearchForm" href="#Search" data-toggle="tab">Search</a>
      </li>
    </ul>

    <div class="tab-content" id="topTabsContent">
      <div class="tab-pane active" id="Map">
        <div class="top-content">
          <div class="top-force-container">
            <div class="top-force-left">
              <div class="yappee-logo">
                <svg class="yappee-graphic" width="305" height="80">
                </svg>
              </div>
              <!-- load javascript for yappee graphic -->
              <script src="scripts/map_page/yappee_graphic.js" type="text/javascript"></script>
              <div class="input-group patent-input">
                <span class="input-group-addon">Map:</span>
                <div>
                  <input type="text" class="form-control input-patent" placeholder="Patent/App. number" spellcheck="false">
                  <div class="patent-input-error"></div>
                </div>
                <span class="input-group-addon btn-go">Go!</span>
              </div>
              <div class="btn-group btn-group-left">
                <button type="button" class="btn btn-default btn-random">Random</button>
                <button type="button" class="btn btn-default btn-fun">Fun</button>
              </div>
            </div>
            <div class="top-force-right">
              <div class="btn-group btn-group-right">
                <button type="button" class="btn btn-default btn-undo" disabled="true">Undo</button>
                <button type="button" class="btn btn-default btn-clear" disabled="true">Clear</button>
              </div>
            </div>
          </div>
          <div class="top-patent-lists">
          </div>
        </div>
        <div class="main-content">
          <div class="force-container">
            <div class="status-line">
              <span class="status-line-type">Fetching </span>patents <span class="status-line-queries">0/5</span> tasks done
            </div>
            <div class="mouse-mode-line" title="Shift-click on plot to change modes">
              <span class="mouse-mode-state">Normal</span> mode</div>
            <div class="bib-container">
            </div>
            <svg class="main-svg">
              <defs>
                <!-- svg for the mapped patent cross graphic for a node on the forcePatent map -->
                <g id="force-mapped-cross-def" clip-path="url(#nodeClip)">
                  <rect class="force-mapped-cross" width="20" height="5" transform="translate(-10,-2.5)"></rect>
                  <rect class="force-mapped-cross" width="5" height="20" transform="translate(-2.5,-10)"></rect>
                </g>
    
                <!-- svg for the favorite patent symbol for a node on the forcePatent map -->
                <g id="force-favorite-heart-def" transform="translate(0,8)">
                  <g class="force-favorite-heart" transform="rotate(-135)">
                    <rect height="8" width="10" transform="translate(0,0)"></rect>
                    <circle r="4" transform="translate(10,4)"></circle>
                  </g>
                  <g class="force-favorite-heart" transform="rotate(-45)">
                    <rect height="8" width="10" transform="translate(0,-8)"></rect>
                    <circle r="4" transform="translate(10,-4)"></circle>
                  </g>
                </g>
                <!-- svg for the clipPaths for the top buttons 'Bring To Front', 'Send To Back', and 'Full/Popup' -->
                <ClipPath id="leftBtn">
                  <rect x="-11px" y="-11px" width="21px" height="22px"></rect>
                </clipPath>
                <ClipPath id="midBtn">
                  <rect x="-10px" y="-11px" width="20px" height="22px"></rect>
                </clipPath>
                <ClipPath id="rightBtn">
                  <rect x="-10px" y="-11px" width="21px" height="22px"></rect>
                </clipPath>
              </defs
            </svg>
          </div>
          <!-- load javascript for initial force map -->
          <script src="/scripts/map_page/initial_force_map.js" type="text/javascript" charset="utf-8"></script>
          <div class="patent-lists">
            <div class="patent-list" data-listname="mapped">
              <div class="patent-list-header">Mapped</div>
              <div class="patent-list-patents">
                <!-- HTML from script id 'mapped-list-entry-section' for each patent in the list goes here -->
              </div>
            </div>
            <div class="patent-list" data-listname="favorites">
              <div class="patent-list-header">Favorites</div>
              <div class="patent-list-patents">
                <!-- HTML from script id 'favorites-list-entry-section' for each patent in the list goes here -->
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="tab-pane" id="Search">
        <iframe id="gps" src="" width="1050" height="700" scrolling="no" allowfullscreen="true"
                sandbox="allow-same-origin allow-top-navigation allow-forms allow-scripts">
	</iframe>
      </div>
    </div>

    <script id="advanced-patent-search-style" type="text/template">    <!-- loads in iframe of advanced patent search page -->
      <!-- import styles for the header on the advanced patent search page -->
      <style type="text/css">
        @import url("/css/jdwadvancedpatentsearch.css");
        @import url("/css/jdwpageheader.css");
      </style>
    </script>

    <!-- part of replacement header for advanced patent search page -->
    <script id="advanced-patent-search" type="text/template">
      <span class="advanced-patent-search-header">Advanced Patent Search</span>
    </script>

    <!-- load script to finish setting up the Map page -->
    <script src="/scripts/map_page/map_page_complete.js" type="text/javascript"></script>

    <!-- load script to setup Google Advanced Patent Search page -->
    <script src="/scripts/search_form_page/advanced_patent_search.js" type="text/javascript"></script>

    <!-- load script handling setup of buttons, popovers, and events as each tab is created -->
    <script src="/scripts/tabs/tab_setup.js" type="text/javascript"></script>

    <!-- load script for the PatentPicker and RandomPatentPicker classes associated with the Go, Random, and
         Fun buttons on the Map page -->
    <script src="/scripts/map_page/patent_pickers.js" type="text/javascript"></script>

    <script type="text/javascript">

      var startTime;                     // for debugging elapsed time
      // list of objects containing patent bibliographic, cited, citing, and related patent info; used for querying EPO for mapping
      var patentBiblio = {};
      // list of objects containing patent bibliographic data, but no citation or related patent info; used for favorites list
      var favoriteBiblio = {};
      var epoBiblio = {};                // contains the bibliographic data fetched from EPO
      var patentNoEPOtoGoogle = {};      // a dictionary of epo patent document keys and Google patent document values
      var patentLists = {                // simple lists of patent numbers for each kind of list
         "map": [],
         "favorites": [],
         "deleted": [],                  // track order that patents are deleted, so deletions can be undone
         "cleared":
                   {"map": [],
                    "target": [],
                    "deleted": []
                   },
         "clearFlag": false              // flag set after user clicks the Clear button
      };


      var taskTracker = new TaskTracker();   // tracks queries and updates status line at top of patent map

      function TaskTracker() {
        this.initialize = function(taskType, callback) {
          // if final timeout still running from previous query set
          if (this.runningTimeout && (this.maxCount == this.doneCount)) {
            window.clearTimeout(this.runningTimeout);
            this.tasksComplete();
          }
          $("span.status-line-type").text(taskType + " ");
          this.doneCount = 0;
          this.maxCount = 0;
          this.runningTimeout = undefined;
          this.callback = callback;
        }
        this.startTask = function(num) {
          this.maxCount += num;
          this.updateMessage();
          if (!this.runningTimeout) {    // if no query was running, then need to make the status message visible
            $("div.status-line").addClass("make-visible");
          }
          this.updateTimeout();
        }
        this.finishTask = function(num) {
          this.doneCount += num;
          this.updateMessage();
          this.updateTimeout(); 
        }
        this.updateTimeout = function() {
          if (this.runningTimeout) {
            window.clearTimeout(this.runningTimeout);
          }
          if (this.maxCount > this.doneCount) {                          // at least one query is still running
            var newTime = (this.maxCount - this.doneCount)*2000;
          }
          else {                                                         // all queries in queue have completed
            var newTime = 2000;
          }
          this.runningTimeout = window.setTimeout(this.tasksComplete.bind(this), newTime);
        }
        this.tasksComplete = function() {
          $("div.status-line").removeClass("make-visible");
          this.runningTimeout = undefined;
          if (this.doneCount != this.maxCount) {
            debug("In TaskTracker, " + (this.maxCount - this.doneCount) + " tasks failed to complete");
          }
          if (this.callback) {               // call the callback passed in .initialize if it is defined
            this.callback();
          }
        }
        this.updateMessage = function() {
          $("span.status-line-queries").text(this.report());
        }
        this.report = function() {
          return this.doneCount + "/" + this.maxCount;
        }
      }


<script src="/scripts/related_page/related_setup.js" type="text/javascript"></script>
<script src="/scripts/search_page/search_setup.js" type="text/javascript"></script>
<script src="/scripts/patent_page/patent_setup.js" type="text/javascript"></script>
<script src="/scripts/shared/shared_google.js" type="text/javascript"></script>
<script src="/scripts/shared/map_fav_buttons.js" type="text/javascript"></script>

/*
      function simulateClick(element, eventType, contextWindow) {
      // similate a mouse event 'type' on the 'element' in the 'contextWindow'
      // 11/25/2013: no longer need to use this function to load only patents in the related window; append "#c=p" to the end of the related url
        var event = new MouseEvent(eventType, {
          'view': contextWindow,
          'bubbles': true,
          'cancelable': true
        });
        var canceled = !element.dispatchEvent(event);
        if (canceled) {
        // A handler called preventDefault.
        }
        else {
        // None of the handlers called preventDefault.
        }
      }
*/

      function makeGoogleDate(dateStr) {
      // use moment.js to take a string like 20100416 and return a string Apr 16, 2010 (Google format).
        return moment.utc(dateStr, "YYYYMMDD").format("MMM D, YYYY");
      };

      function makeGoogleName(nameStr) {
      // take an EPO biblio inventor or applicant name (all caps SMITH PAUL L [US]) or MONSANTO LLC [US]) and strip off
      // the [US] and return mixed upper/lower case (Google format) names.
        var s = nameStr.replace(/\s\[\w*\]/g, "");                     // remove [US] from the end of the applicant name
        return makeUpperLower(s);                                      // make mixed upper/lower case
      }

      function makeUpperLower(nameStr) {
      // return mixed upper/lower case (Google format) names; in the regex, \b matches a word boundary; \w matches any
      // alphanumeric character; \s matches any whitespace character, including tabs and special unicode space characters
      // that are sometimes present in the EPO biblio data; occasionally, even Google has names in full caps.
        return nameStr.toLowerCase().replace(/\b\w/g, function(match) {return match.toUpperCase();});
      }


      function makeShort(assignee) {
      // take an assignee name and make a shortened version of it for the purpose of creating the shortAssignee
      // property of biblio objects, which is used in creating legend entries; called from getTIA and parseEPOPatentData
        var coList = ["INC", "INCORP", "LLC", "LIMITE", "LTD", "CO", "COMPAN", "TECHNO",
                      "TECH", "INDUST", "IND", "NV"];
        switch (assignee.slice(0,4).toUpperCase()) {
          case "":                                          // some patents have no assignee
            return "No assignee";
          case "UNIV":
            switch (assignee.slice(0,10).toUpperCase()) {
              case "UNIVERSITY":
                return assignee.slice(0,20);
              default:
                return assignee.slice(0,12);
            }
          default:
            var wordList = assignee.split(/[,\s]+/);    // split into list of words
            if (wordList.length == 1) {
              return wordList[0].slice(0,7);          // use first seven letters of first word as basis of matching an assignee name
            }
            else {
              var word2 = wordList[1].slice(0,6).toUpperCase();
              if (coList.indexOf(word2) == -1) {        // 2nd word is not in coList
                return wordList[0].slice(0,7) + " " + wordList[1].slice(0,7);
              }
              else {
                return wordList[0].slice(0,7);        // use first seven letters of first word as basis of matching an assignee name
              }
            }
        }
      }

      function getTIA($context) {
        // get title, inventor(s), and assignee(s) in a patent document $context; used when setting up a patent tab and in the
        // a patent entry in the patentBiblio object list; called from processPatentPage and tabPopoverManager.setupPatentTab.
        var title = $("span.patent-title", $context).text();
        debug("In getTIA, got title " + (new Date() - startTime)/1000);
        var inventorList = [];
        var assigneeList = [];
        var shortAssigneeList = [];
        $("table.patent-bibdata td.patent-bibdata-heading:contains('Inventors') + td span.patent-bibdata-value a", $context)
            .each(function() {
                    var inventor = $(this).text();
                    inventor = makeUpperLower(inventor);              // correct occasional all uppercase inventor name
                    inventorList.push(inventor);
                  });
        debug("In getTIA, got inventors " + (new Date() - startTime)/1000);
        $("table.patent-bibdata td.patent-bibdata-heading:contains('Assignee') + td span.patent-bibdata-value a", $context)
            .each(function() {
                    var assignee = $(this).text();
                    assignee = makeUpperLower(assignee);              // occasionally name is all uppercase(?)
                    var finalAssignee = assignee.replace(/S A$|Sa$/, "SA").replace(/Llc/, "LLC").replace(/A G$|Ag$/, "AG")
                                                .replace(/G M B H$|Gmbh$/, "GmbH");
                    assigneeList.push(finalAssignee);
                    shortAssigneeList.push(makeShort(finalAssignee))
                  });
        if (assigneeList.length == 0) {                               // Assignee or Applicant, depending on which country
          $("table.patent-bibdata td.patent-bibdata-heading:contains('Applicant') + td span.patent-bibdata-value a", $context)
            .each(function() {
                    var assignee = $(this).text();
                    var finalAssignee = assignee.replace(/S A$|Sa$/, "SA").replace(/Llc/, "LLC").replace(/A G$|Ag$/, "AG")
                                                .replace(/G M B H$|Gmbh$/, "GmbH");
                    assigneeList.push(finalAssignee);
                    shortAssigneeList.push(makeShort(finalAssignee))
                  });
        }
        var inventors = inventorList.join(", ");
        var assignees = assigneeList.join(", ");
        var shortAssignees = shortAssigneeList.sort().join(" ");
        debug("In getTIA, got assignee " + (new Date() - startTime)/1000);
        return {title: title, inventors: inventors, assignee: assignees, shortAssignee: shortAssignees};
      }

      function addEPOPatentDataToForceMap(source_patent, processedList, epoQueryLists, iList) {
        // epoQueryLists is a list of objects containing keys "list" (the query list), "type" (cited, citing, related)
        // and "done" (track when the query completes); one object for each query POSTed;
        // iList is the process number that just finished; processList is a list of patents in EPO format
        // that were successfully parsed and for which biblio data exists in epoBiblio; source_patent is the
        // patent at the focus of the forcePatent diagram.
        epoQueryLists[iList]["done"] = "true";                               // the iList list has been queried and processed
        debug("In addEPOPatentDataToForceMap, retrieved biblio data for the following patents");
        debug(processedList);
        var type = epoQueryLists[iList]["type"];
        var $sourceContainer = $mappedList          // get appropriate jQuery element for source_patent in the Mapped patent list
                           .find("div.patent-list-entry[data-patent='" + source_patent + "'] div.patent-list-patent-container");
        for (var i = 0; i < processedList.length; i++) {                     // add to the forcePatent and forceBiblio maps
          var target_patent = processedList[i];
          addTargetPatentToForceMap(source_patent, target_patent, type, "new");
          addTargetPatentToMappedSublist($sourceContainer, source_patent, target_patent, type, false); 
        }
      }

      function addSourcePatentToForceMap(patent_no, page_type, context) {
      // create a source node for patent_no on the forcePatent and forceBiblio maps; context is the context in which
      // the function is called ('new', 'undo_delete', or 'undo_clear'); called from processSourcePatent and
      // undeletePatent.
        if (!patentsHistory[patent_no]) {                // if not already on the forcePatent and forceBiblio maps at some point
          createForceNode(true, patent_no);              // use 'true' for a source node
        }
        else {                                           // make sure we use biblio from patentBiblio (has references lists)
          updateForceNode(true, patent_no);
        }
        // if source patent not already currently plotted as either a source patent or a target patent,
        // update data lists for force map plotting; re-plot if patent has previously been deleted
        patentLists["map"].push(patent_no);
        if (!patentsPlotted[patent_no]) {
          addPatentToPlottingLists(patent_no);            // update the data lists for force map plotting
        }
        else {                                            // node already exists as a target; change the marker to the source type
          var marker = d3.select("g.force-patent-marker[data-patent=" + patent_no + "]");
          updateMarkerOnForceMap(marker, page_type);
        }
        switch (context) {
          case "new", "undo_clear":
            updateClearedLists(patent_no, "map");
            break;
        }
      }

      function updateClearedLists(patent_no, list) {
      // update patentLists cleared lists now that patent_no is plotted; list is 'map' or 'target'; note that patent_no can be
      // mapped by clicking a map button, from the buttons at the top of the force map, or as a result of being
      // undeleted; called from addSourcePatentToForceMap and addTargetPatentToForceMap.
        var cleared = patentLists["cleared"];
        // if patent_no is mapped from the buttons at the top of the force map, or if an undoClear is being executed,
        // need to check the cleared lists and delete from any in which it appears.
        var ind = cleared[list].indexOf(patent_no);
        if (ind != -1) {
          cleared[list].splice(ind, 1);
        }
        var allEmpty = true;
        for (list in cleared) {
          if (cleared[list].length > 0) {
            allEmpty = false;
          }
        }
        if (allEmpty && patentLists["clearFlag"]) {       // nothing left to un-Clear
          patentLists["clearFlag"] = false;
        }
      }

      function addTargetPatentToForceMap(source_patent, patent_no, type, context) {
      // add patent patent_no as a target patent and create a link between source_patent and patent_no if one does
      // not exist; if patent_no has not been deleted, plot the target patent if not already plotted, and plot the
      // link to source patent on the forcePatent and forceBiblio maps; link 'type' is "cited", "citing", "related",
      // or ""; 'context' is the context in which the function is called ('new', 'undo_delete', or 'undo_clear').
      // if 'source_patent' and 'type' are passed as "", a new link is not added; source_patent and all existing links are plotted;
      //
      // links are only added and possibly plotted when processing
      // target patents since every link is between a patent target and a patent source;
      // source_patent is the patent that is currently being mapped; note that the target patent can have links to more
      // than one source patent; all links to be plotted must be added to the patentLinks list of links attached to the force map
      // biblio data for patent_no must exist in patentBiblio or epoBiblio.
      // called from addEPOPatentDataToForceMap, undeletePatent, addFavoritePatent, and mapExistingTargetPatents,
        if (!patentsHistory[patent_no]) {                // if not already on the forcePatent and forceBiblio maps at some point
          createForceNode(false, patent_no);             // use 'false' for a target node
        }
        // if target patent not already currently plotted as either a source patent or a target patent, and if patent has not
        // already been deleted, update data lists for force map plotting
        switch (context) {
          case "new":
            if (!patentsPlotted[patent_no] && patentLists["deleted"].indexOf(patent_no) == -1) {
              addPatentToPlottingLists(patent_no);
            }
            break;
          case "undo_delete": case "undo_clear":
            if (!patentsPlotted[patent_no]) {
              addPatentToPlottingLists(patent_no);
            }
            break;
        }
        if (source_patent != "") {                       // if we have a specific source patent
        // note: patent_no might be in deleted list already; it will not be plotted, but we might still need to create
        // a link to a newly mapped source_patent; we would not plot the link in this case.
          var patentNode = patentsHistory[patent_no];
          var link_key = source_patent + patent_no + type;
          // check if need to create a link between patent_no and source_patent, and create if not already present
          if (!(link_key in patentNode.sourcePatentLinks)) {
            createForceLink(source_patent, patent_no, type, link_key);  // one of two places where links are created
          }
          if (patentsPlotted[patent_no]) {                       // plot link only if patent itself will be plotted
            var link = patentNode.sourcePatentLinks[link_key];
            addLinkToPlottingList(link);                         // this is one of two places where links are queued for plotting
          }
        }
        // re-plot links to all source patents that are on the force map (case called from undeletePatent and addFavoritePatent).
        else {
          var patentNode = patentsPlotted[patent_no];
          if (patentNode) {                                      // should always be true
            for (link_key in patentNode.sourcePatentLinks) {                   // check links from patentNode as target to
              var sourceLink = patentNode.sourcePatentLinks[link_key];         // each source patent; if source patent is plotted
              var sourcePat = sourceLink.source.patent_no;
              if (patentLists["map"].indexOf(sourcePat) != -1) {               // if source is mapped, add link to list to plot
                addLinkToPlottingList(sourceLink);       // this is one of two places where links are queued for plotting
              }
            } 
          }
        }
        switch (context) { 
          case "undo_clear":
            updateClearedLists(patent_no, "target");
            break;
        }
      }

      function createForceLink(source_patent, target_patent, type, link_key) {
      // creates a new force link between patent_no source_patent and patent_no target_patent with the key link_key;
      // called from addTargetPatentToForceMap and checkDataForPatents
        var targetNode = patentsHistory[target_patent];            // use patentsHistory instead of patentsPlotted
        var sourceNode = patentsHistory[source_patent];            // because need to create links to deleted patents also
        var link = new PatentLink(sourceNode, targetNode, type, link_key);  // the only place where new links are created
        // need ordered list of link_keys to preserve legend colors when deleting and undeleting patents
        sourceNode.targetPatentLinksList.push(link_key);
        sourceNode.targetPatentLinks[link_key] = link;             // link from sourceNode to a target patent
        targetNode.sourcePatentLinks[link_key] = link;             // link from patentNode to a source patent
      }

      function createForceNode(source, patent_no) {
      // create PatentNode, BiblioNode, and BiblioLink data objects and push to the respective lists for the
      // forcePatent and forceBiblio maps; source is a boolean specifying whether the node is a source node (true)
      // or target node (false); called from addSourcePatentToForceMap and addTargetPatentToForceMap
        var biblio = (source) ? patentBiblio[patent_no] : epoBiblio[patent_no];
        var patentNode = new PatentNode(patent_no, source, biblio);               // create a new patentNode
        var biblioNode = new BiblioNode(patent_no, biblio);                       // create a new biblioNode
        var biblioLink = new BiblioLink(patent_no, patentNode, biblioNode)        // create a new biblioLink
        patentNode.biblioNode = biblioNode;                                       // each object references the other
        patentNode.biblioLink = biblioLink;
        biblioNode.patentNode = patentNode;
        biblioNode.biblioLink = biblioLink;
        patentsHistory[patent_no] = patentNode;
      }

      function updateForceNode(source, patent_no) {
      // patent_no is assumed to exist in patentsHistory; update the biblio in patentNode and biblioNode associated with
      // patent_no according to whether patent_no is a source patent
        var useBiblio = (source) ? patentBiblio[patent_no] : epoBiblio[patent_no];
        var patentNode = patentsHistory[patent_no];
        if (source) {
          // do not just substitute useBiblio for the patentNode biblio because assignee names can be different between
          // Google and EPO; it will screw up the legend if patent_no is already on it and the assignee name changes.
          patentNode.biblio.cited_patents = useBiblio.cited_patents;
          patentNode.biblio.citing_patents = useBiblio.citing_patents;
          patentNode.biblio.related_patents = useBiblio.related_patents;
          patentNode.source = source;
        }
      }

      function addLinkToPlottingList(link) {
      // adds link to patentLinks so it will be plotted during the next updateForceMap() call
      // patentLinks is the list of data for the forcePatent force map; called from addPatentToPlottingLists
      // (for links that were created, deleted and now need to be replotted) and addTargetPatentToForceMap
      // (for newly created links being plotted for the first time).
        patentLinks.push(link);
        link.source.plotLinks += 1;
        link.target.plotLinks += 1;
      }

      function addPatentToPlottingLists(patent_no) {
      // called from addSourcePatentToForceMap and addTargetPatentToForceMap
        var patentNode = patentsHistory[patent_no];
        patentsPlotted[patent_no] = patentNode;                            // patent_no can only appear on one tracking list
        // delete patent_no from the other tracking lists; (does not throw an error if patent_no is not in any of them).
        delete patentsUnplotted[patent_no];
        removePatentFromDeletedList(patent_no);                            // only place where patent is removed from deleted list
        addToLegend(patentNode);                                           // add to the legend
        patentNodes.push(patentNode);                                      // add to patent node list for plotting
        biblioNodes.push(patentNode.biblioNode);                           // add to biblio node list for plotting
        biblioLinks.push(patentNode.biblioLink);                           // add to biblio link list for plotting
      }


    </script>

    <script id="customize-bootstrap-styles" type="text/template">    <!-- will load in main window -->
      <!-- import style for popovers on search, patent, and prior art pages -->
      <style type="text/css">
        @import url("/css/jdwpopovers.css");
        @import url("/css/jdwbuttons.css");
      </style>
    </script>

    <!-- html for adding the '+' and 'heart' (add and favorite) buttons to the Google related art page
         piggy back off of the Google css class 'hide-result-btn' for the 'x' that hides a patent;
         edit the /patents/related/static/icons.png file and add +' and 'heart' icons; (this file has many icons);
         save as iconsJDW and serve from the /css directory on my server; we select which icon to use by setting
         the position, height, and width of the background css parameter. -->
    <script id="related-art-page-button-content" type="text/template">
      <span class="hide-result-btn btn-favorite-add" title="Add to favorites"></span>
      <span class="hide-result-btn btn-map-add" title="Add to patent map"></span>
    </script>

    <script id="search-page-button-content" type="text/template">
      <span class="hide-result-btn btn-hide-add" title="Hide"></span>
      <span class="hide-result-btn btn-favorite-add" title="Add to favorites"></span>
      <span class="hide-result-btn btn-map-add" title="Add to patent map"></span>
    </script>

    <script id="search-page-unhide-results" type="text/template">
      <div class="hidden-results-info hidden-show-all">
        <span class="hidden-results-message">0 result hidden below.</span>
        <span class="hidden-results-clear-btn">Show all</span>
      </div>
    </script>

    <script id="prior-art-popover-title" type="text/template">
      Prior art for <%= patent_no %>:<br><span class="popover-subtitle jdwprior"><%- patent_title %></span>
    </script>

    <script id="prior-art-popover-content" type="text/template">
      <table id="jdw20">
        <tbody id="jdw21">
          <tr>
            <td class="jdw22">Search terms:</td>
            <td class="jdw23" id="jdw-pop-search-terms"><%= searchTerms %></td>
          </tr>
          <tr>
            <td class="jdw22">Start date:</td>
            <td class="jdw23" id="jdw-pop-start-date"><%= startDate %></td>
          </tr>
          <tr>
            <td class="jdw22">End date:</td>
            <td class="jdw23" id="jdw-pop-end-date"><%= endDate %></td>
          </tr>
        </tbody>
      </table>
    </script>

    <script id="patent-info-popover" type="text/template">
      <table id="jdw20">
        <tbody id="jdw21">
          <tr>
            <td class="jdw22">Inventors:</td>
            <td class="jdw23"><%= inventors %></td>
          </tr>
          <tr>
            <td class="jdw22">Assignee:</td>
            <td class="jdw23"><%= assignee %></td>
          </tr>
        </tbody>
      </table>
    </script>
   
    <script id="search-term-popover" type="text/template">            <!-- will load in main window -->
      <table id="jdw14">
        <tbody>
          <tr>
            <td class="tcell"><%- t1 %></td>
            <td class="vcell"><%- v1 %></td>
            <td class="tcell"><%- t5 %></td>
            <td class="vcell"><%- v5 %></td>
            <td class="tcell"><%- t9 %></td>
            <td class="vcell"><%- v9 %></td>
            <td class="tcell"><%- t13 %></td>
            <td class="vcell"><%- v13 %></td>
          </tr>
          <tr>
            <td class="tcell"><%- t2 %></td>
            <td class="vcell"><%- v2 %></td>
            <td class="tcell"><%- t6 %></td>
            <td class="vcell"><%- v6 %></td>
            <td class="tcell"><%- t10 %></td>
            <td class="vcell"><%- v10 %></td>
            <td class="tcell"><%- t14 %></td>
            <td class="vcell"><%- v14 %></td>
          </tr>
          <tr>
            <td class="tcell"><%- t3 %></td>
            <td class="vcell"><%- v3 %></td>
            <td class="tcell"><%- t7 %></td>
            <td class="vcell"><%- v7 %></td>
            <td class="tcell"><%- t11 %></td>
            <td class="vcell"><%- v11 %></td>
            <td class="tcell"><%- t15 %></td>
            <td class="vcell"><%- v15 %></td>
          </tr>
          <tr>
            <td class="tcell"><%- t4 %></td>
            <td class="vcell"><%- v4 %></td>
            <td class="tcell"><%- t8 %></td>
            <td class="vcell"><%- v8 %></td>
            <td class="tcell"><%- t12 %></td>
            <td class="vcell"><%- v12 %></td>
            <td class="tcell"><%- t16 %></td>
            <td class="vcell"><%- v16 %></td>
          </tr>
        </tbody>
      </table>
    </script>

    <!-- tweek formating of Gooooogle span so it disappears.  Will load in iframe of search pages -->
    <script id="search-page-more-results-style" type="text/template">
      <style type="text/css">
        @import url("/css/jdwsearchresultpage.css");
      </style>
    </script>

    <!-- loads in iframe of search, patent, related, and hidden related pages -->
    <script id="search-term-table-style" type="text/template">
      <!-- import styles for:
             inserted Map and Favorites buttons
             customized page header
             animation trick to get the prior art div.r's to load properly -->
      <style type="text/css">
        @import url("/css/jdwbuttons.css");
        @import url("/css/jdwpageheader.css");
        @import url("/css/jdwpriorartpage.css");
      </style>
    </script>

    <!-- replacement header for google advanced patent search, search result, related result, and patent pages -->
    <script id="page-header" type="text/template">
      <div id="jdw-top">
        <span id="jdw-top-row">
          <span class="jdw-google">
            <!-- get google logo with this span -->
            <span class="jdw-google-logo">
              <span class="jdw-google-logo1"></span>
            </span>
            </div>
          </span>
        </span>
      </div>
    </script>

    <!-- header for prior art page -->
    <script id="prior-art-table" type="text/template">                  <!-- will load in prior art iframe -->
      <div id="jdw30" class="gbt">
        <h2 id="jdw31">Prior art for <%= patent_no %></h2>
      </div>
    </script>

    <!-- search term table -->
    <script id="search-term-table" type="text/template">                <!-- will load in iframe -->
      <div id="jdw1">
        <div id="jdw2">
          <table>
            <tbody>
              <tr>
                <td><b>Search terms:</b></td>
              </tr>
            </tbody>
          </table>
        </div>
        <div id="jdw3" class="gbt">
          <table id="jdw4">
            <tbody>
              <tr>
                <td class="tcell"><%- t1 %></td>
                <td class="vcell"><%- v1 %></td>
                <td class="tcell"><%- t5 %></td>
                <td class="vcell"><%- v5 %></td>
                <td class="tcell"><%- t9 %></td>
                <td class="vcell"><%- v9 %></td>
                <td class="tcell"><%- t13 %></td>
                <td class="vcell"><%- v13 %></td>
              </tr>
              <tr>
                <td class="tcell"><%- t2 %></td>
                <td class="vcell"><%- v2 %></td>
                <td class="tcell"><%- t6 %></td>
                <td class="vcell"><%- v6 %></td>
                <td class="tcell"><%- t10 %></td>
                <td class="vcell"><%- v10 %></td>
                <td class="tcell"><%- t14 %></td>
                <td class="vcell"><%- v14 %></td>
              </tr>
              <tr>
                <td class="tcell"><%- t3 %></td>
                <td class="vcell"><%- v3 %></td>
                <td class="tcell"><%- t7 %></td>
                <td class="vcell"><%- v7 %></td>
                <td class="tcell"><%- t11 %></td>
                <td class="vcell"><%- v11 %></td>
                <td class="tcell"><%- t15 %></td>
                <td class="vcell"><%- v15 %></td>
              </tr>
              <tr>
                <td class="tcell"><%- t4 %></td>
                <td class="vcell"><%- v4 %></td>
                <td class="tcell"><%- t8 %></td>
                <td class="vcell"><%- v8 %></td>
                <td class="tcell"><%- t12 %></td>
                <td class="vcell"><%- v12 %></td>
                <td class="tcell"><%- t16 %></td>
                <td class="vcell"><%- v16 %></td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </script>

    <!-- scripts for inserting a Bootstrap tab and tab content-->
    <script id="bs_tab-pane" type="text/template">
      <div class="tab-pane" id="<%= tab_content_id %>">
        <iframe class="gps_result" id="<%= iframe_id %>" width="<%= iframe_width %>" height="<%= iframe_height %>" allowfullscreen="true" sandbox="allow-same-origin allow-top-navigation allow-forms allow-scripts" onerror="console.log('Error loading iframe');">
        </iframe>
      </div>
    </script>

    <script id="bs_nav-tab" type="text/template">
      <li>
        <a id="<%= tab_id %>" href="#<%= tab_content_id %>" data-toggle="tab" data-tabname="<%= tab_name %>">
          <span><%= tab_name %></span>
          <div class="tb">
            <button class="close close-tab" type="button" onclick="tabPopoverManager.deleteTab(event)">&times;</button>
          </div>
        </a>
      </li>
    </script>

    <!-- script for adding the Map and Favorites buttons to patent tabs -->
    <script id="tab-buttons" type="text/template">
       <div class="tb tb-left">
          <span class="hide-result-btn btn-map-add" title="Add to patent map"></span>
          <span class="hide-result-btn btn-favorite-add" title="Add to favorites"></span>
       </div>
    </script>

    <!-- script for templating a patent entry in the Mapped patent list -->
    <!-- variables are patent_no -->
    <script id="mapped-list-entry-section" type="text/template">
      <div class="patent-list-entry" data-patent="<%= patent_no %>">
        <div class="patent-list-patent-nav-area">
          <div class="patent-list-dropdown-arrow"></div>
        </div>
        <div class="patent-list-patent-container">
          <!-- HTML from script id 'patent-list-patent-section' for the patent goes here -->
          <!-- HTML from script id 'patent-list-reference-section' for its cited patents goes here -->
          <!-- HTML from script id 'patent-list-reference-section' for its citing patents goes here -->
          <!-- HTML from script id 'patent-list-reference-section' for its related patents goes here -->
        </div>
      </div>
    </script>

    <!-- script for templating a patent entry in the Favorites patent list -->
    <!-- variables are patent_no -->
    <script id="favorites-list-entry-section" type="text/template">
      <div class="patent-list-entry" data-patent="<%= patent_no %>">
        <div class="patent-list-patent-container">
          <!-- HTML from script id 'patent-list-patent-section' for the patent goes here -->
        </div>
      </div>
    </script>

    <!-- script for templating a patent biblio in a patent list -->
    <!-- variables are patent_no, patent_label, source_patent, title, file_date; set source_patent = patent_no
    <!-- if patent_no is a Mapped patent or a Favorite patent -->
    <script id="patent-list-patent-section" type="text/template">
      <div class="patent-list-patent" data-patent="<%= patent_no %>" data-source-patent="<%= source_patent %>">
        <div class="patent-list-patent-main">
          <div class="patent-list-patent-biblio">
            <div class="patent-list-patent-row">
              <div class="patent-list-patent-number">
                <a class="pop1-patent-url" href="/patents/<%= patent_no %>"><%= patent_label %></a>
              </div>
              <div class="patent-list-patent-buttons">
                <span class="hide-result-btn btn-map-add" title="Add to patent map" data-patent="<%= patent_no %>"></span>
                <span class="hide-result-btn btn-favorite-add" title="Add to favorites" data-patent="<%= patent_no %>"></span>
                <span class="hide-result-btn btn-hide-add" title="Delete from map" data-patent="<%= patent_no %>"></span>
              </div>
              <div class="patent-list-patent-date">
                <div>Appl: <%= file_date %></div>
              </div>
            </div>
            <div class="patent-list-patent-title"><%= title %></div>
          </div>
        </div>
        <div class="patent-list-fullview-button" title="Full view" data-patent="<%= patent_no %>" data-querying="false">
          <div class="patent-list-fullview-container"></div>
          <div class="patent-list-full-rect"></div>
        </div>
      </div>
    </script

    <!-- script for templating a citations section under a patent in a patent list -->
    <!-- variables are patent_no, citation_type ('cited', 'citing', or 'related'), citation_no (number of citations)
    <!-- and citation_heading -->
    <script id="patent-list-reference-section" type="text/template">
      <!-- Firefox requires function definitions before function usage; Chrome does not -->
      <% function dropdownArrowHTML(patent_no) {
        // add HTML for the dropdown arrow if a citations list has entries
        return '<div class="citation-list-dropdown-arrow" data-patent="' + patent_no + '"></div>';
         } %>
      <div class="patent-list-references patent-list-<%= citation_type %>-patents" data-patent="<%= patent_no %>" data-citation-type="<%= citation_type %>">
        <div class="patent-list-patent-nav-area patent-list-<%= citation_type %>-nav-area">
          <%= (citation_no > 0) ? dropdownArrowHTML(patent_no) : "" %>
        </div>
        <div class="patent-list-citation-container">
          <div class="patent-list-citation-heading patent-list-<%= citation_type %>-heading"><%= citation_heading %> 
            (<span class="patent-list-citation-mapped">0</span>&nbsp;mapped;&nbsp;
             <span class="patent-list-citation-deleted">0</span>&nbsp;deleted)
          </div>
          <div class="patent-list-subpatent-container">
            <!-- HTML from script id 'patent-list-patent-section' for each citation_type patent goes here -->
          </div>
        </div>
      </div>
    </script>

    <!-- script for templating the biblio popup on the force maps -->
    <!-- variables are patent_no, patent_label, file_date, pub_date, title, inventors, assignee, and abstract -->
    <script id="force-pop1" type="text/template">
      <!-- Firefox requires function definition before usage; Chrome does not -->
      <% function makeLinksHTML(parseStr, queryTerm) {
        // parseStr is a comma separated string of names; from each name construct an <a> tag whose href is a google patent
        // search URL containing the query term queryTerm.
        var aPre = '<a class="pop1-search-url" href="/search?tbo=p&amp;tbm=pts&amp;hl=en&amp;q=' + queryTerm + ':%22';
        var aPost = '%22">';
        var aClose = '</a>';
        var itemArray = parseStr.split(/\s*,\s*/);
        itemArray = itemArray.map( function(name) {return aPre + name.replace(/\s+/g, "+") + aPost + name;});
        return itemArray.join(aClose + ", ") + aClose;
        } %>
      <div class="pop1-container" data-patent="<%= patent_no %>">
        <div class="pop1-top-capture"></div>
        <div class="pop1-patent-row">
          <div class="pop1-patent"><a class="pop1-patent-url" href="/patents/<%= patent_no %>"><%= patent_label %></a></div>
          <div class="pop1-buttons">
            <span class="hide-result-btn btn-map-add" title="Add to patent map"></span>
            <span class="hide-result-btn btn-favorite-add" title="Add to favorites"></span>
            <span class="hide-result-btn btn-pin-add" title="Pin to map"></span>
            <span class="hide-result-btn btn-hide-add" title="Delete from map"></span>
          </div>
          <div class="pop1-dates">
            <div>Appl: <%= file_date %></div>
            <div>Pub: <%= pub_date %></div>
          </div>
        </div>
        <div class="pop1-title"><%- title %></div>
        <div class="pop1-inventors"><%= (inventors !="Inventors not available") ? makeLinksHTML(inventors, "ininventor") : inventors %></div>
        <div class="pop1-assignee"><%= (assignee != "Assignee not available") ? makeLinksHTML(assignee, "inassignee") : assignee %></div>
        <div class="pop1-abstract"><strong>Abstract</strong><br><%- abstract %></div>
        <div class="pop1-top-btns" data-patent="<%= patent_no %>"></div>
      </div>
    </script>

    <script type="text/javascript" charset="utf-8">  -->

      // attach event handlers to buttons above the force map on the Map page
      $("input.input-patent").on("keydown", on_keydown_input_patent)
                             .on("paste", on_keydown_input_patent)        // use same event handler as for keydown
                             .on("keyup", on_keyup_input_patent);
      $("span.btn-go").on("click", on_click_go_btn);
      $("button.btn-random").on("click", on_click_random_btn)
                            .on("mousedown", divMouseDown);  // prevent buttons from getting focus with blue outline when clicked
      $("button.btn-fun").on("click", on_click_fun_btn)
                           .on("mousedown", divMouseDown);
      $("button.btn-undo").on("click", on_click_undo_delete_btn)
                          .on("mousedown", divMouseDown);
      $("button.btn-clear").on("click", on_click_clear_btn)
                           .on("mousedown", divMouseDown);

      var funPatents = ["US2834031", "US6025810", "US5571247", "US4605000", "US5606804", "US6329919", "US6099319",
                        "US4247283", "CA2010302", "US5107620", "US5456625", "US5394661", "US5572207", "US7283427",
                        "US766171",  "US748626",  "US2026082", "US821393",  "US1909537", "US5960411", "US4378116",
                        "US3655201", "US4708078", "US6733797"]

      var pop1P = {
        "minWidth": 300,                                   // styling parameters for div.pop1-container
        "maxWidth": 350
      };

      createNodeLegend();

      // legend parameters
      nLegendEntry = 8;                      // maximum number of legend entries
      nLegendColors = 12;                    // maximum number of legend colors, including dedicated color for 'AllOtehrs' entry

      var d3_format_EPO_date = d3.time.format("%b %e, %Y");     // e.g., Nov 1, 1978

      function PatentNode(patent_no, source, biblio) {
      // constructor for the data object bound to a forcePatent map node 
        this.patent_no = patent_no;
        this.source = source;                              // true if the patent is the focus of the map
        this.biblio = biblio;                              // an object containing all the bibliographic data
        this.label = makePatentLabel(patent_no);           // node labels on the force map omit the kind code
        this.key = patent_no;                              // data key for d3
        this.plotLinks = 0;                                 // number of plotted links incident on this node
        this.date = d3_format_EPO_date.parse(this.biblio.file_date);   // a javascript date
        // x_fix initialized according to the initial x-axis; x_fix never changes even if x-axis is changed
        this.x_fix = patentMapPlot.xForceScale(this.date);
        this.plotX = 0;
        this.plotY = 0;
        // note the x_fix, x,y values used in the forcePatent map are never affected by zooming; plotX,plotY is the data
        // that is actually used in the transform operations on the actual SVG elements; this.x,.y will be created and
        // defined when forcePatent map is created
        this.updatePlotCoord = function() {                           // need to call when the forcePatent map is zoomed
          this.plotX = patentMapPlot.xForceToPlotScale(this.x);
          this.plotY = patentMapPlot.yForceToPlotScale(this.y);       // translate in the y direction but do not zoom
        }
        this.drag = false;                                 // mark a node when it is being dragged
        this.sourcePatentLinks = {};             // contains link_key : patentLink key/value pairs for links to source patentNodes
        this.targetPatentLinks = {};             // contains link_key : patentLink key/value pairs for links to target patentNodes
        this.targetPatentLinksList = [];         // need to track the order that target links are added for undeleting patents
        this.biblioNode = {};                              // reference to associated BiblioNode object
        this.biblioLink = {};                              // reference to associated BiblioLink object
        this.markerRadius = 7;                             // keep track of the radius of the svg circle that is plotted
        this.sortOrder = 3;                                // sort order in DOM so pLinks, bLinks, and pNodes overlay correctly
      }

      function BiblioNode(patent_no, biblio) {
      // constructor for the data object bound to a forceBiblio map node 
        this.patent_no = patent_no;
        this.label = makePatentLabel(patent_no);           // used for text of patent hyperlinks
        this.biblio = biblio;                              // an object containing all the bibliographic data
        this.key = patent_no;                              // data key for d3
        this.plotX = 0;
        this.plotY = 0;
        // note the x,y values used in the forceBiblio map are never affected by zooming;
        // plotX,plotY is the data that is actually used in the 'transform's on the actual SVG elements;
        // this.x,.y will be created and defined when forceBiblio map is created
        this.updatePlotCoord = function() {                          // need to call when the forceBiblio map is zoomed
          this.plotX = patentMapPlot.xForceToPlotScale(this.x);
          this.plotY = patentMapPlot.yForceToPlotScale(this.y);      // translate in the y direction but do not zoom
        }
        this.drag = false;                                 // mark a node when it is being dragged
        this.displayed = false;                            // used in updating forceBiblio map
        this.pinned = false;                               // is the biblio pinned
        this.mouseleave = false;              // needed for styling the css transition of unpinned biblio back to forcePatent node
        this.transition = false;              // needed for timing css styling changes when unpinned biblio transitions
        this.detached = false;                             // is the biblio detached from the associated node
        this.z_index = 0;                                  // css z-index
        this.patentNode = {};                              // reference to associated patentNode
        this.biblioLink = {};                              // reference to associated BiblioLink object
      }

      function BiblioLink(patent_no, patentNode, biblioNode) {  // the data object that is bound to bLinks between forcePatent
        this.patent_no = patent_no;                             // pNnodes and forceBiblio biblios g.pop1-markers
        this.key = patent_no;
        this.patentNode = patentNode;
        this.biblioNode = biblioNode;
        this.sortOrder = 2;                                // sort order in DOM so pLinks, bLinks, and pNodes overlay correctly
      }

      function PatentLink(source, target, type, key) {     // the data object that is bound as the forcePatent map pLink
        this.source = source;
        this.target = target;
        this.type = type;                                  // a string "cited", "citing", "related"
        this.key = key;                                    // data key for d3
        this.sortOrder = 1;                                // sort order in DOM so pLinks, bLinks, and pNodes overlay correctly
      }

      function LegendEntry(assignee, legendColor, patentCount) {  // constructor for a LegendEntry instance
        this.assignee = assignee;
        this.legendColor = legendColor;
        this.patentCount = patentCount;
      }

      var patentNodes = [];                                // forcePatent map patent nodes
      var biblioNodes = [];                                // forceBiblio map biblio nodes (no force map links for biblioNodes)
      var patentLinks = [];                                // rendered as forcePatent map pLink link lines
      var biblioLinks = [];          // rendered as bLink link lines between patentNodes and biblioNodes (are NOT force map links)
      // dictionary of patents currently plotted on forcePatent and forceBiblio maps; keys are patent nos.; values are patentNodes
      var patentsPlotted = {};
      // dictionary of patents that were plotted but then removed due to user unmapping an associated source patent
      // (not deleted by the user)
      var patentsUnplotted = {};
      // dictionary of patents that have been deleted from map by the user clicking the delete button; used for undo
      // dictionary of all patents that have ever been plotted on the map; keys are patent nos.; values are patentNodes
      var patentsHistory = {};
      var legendEntries = [];                        // array of LegendEntry legend entry objects that can be sorted by patentCount
      var plottedLegendEntries = [];                 // the array of LegendEntry objects that are shown in the legend
      var legendObjects = {};                              // need a key-value collection of LegendEntry objects
      var legendColors = ['rgb(141,211,199)','rgb(255,255,179)','rgb(190,186,218)','rgb(251,128,114)','rgb(128,177,211)',
                          'rgb(253,180,98)', 'rgb(179,222,105)','rgb(252,205,229)','rgb(217,217,217)','rgb(188,128,189)',
                          'rgb(204,235,197)','rgb(255,237,111)']

      // topBiblio will contain an object with the div.bib, div.pop1-container, and g.pop1-marker that became visible
      // due to mouseover on a forcePatent node.
      var topBiblio = undefined;
      var labelDistance = 2;

      d3.select(document).on("keydown.biblio", on_keydown_document, true)      // get event in the capture phse
                         .on("keyup.biblio", on_keyup_document, true);

      bib.on("click.biblio", on_click_change_mouse_mode, true)                 // div.bib-container; handle events in capture phase
         .on("mousedown.biblio", on_mousedown_change_mouse_mode, true)
         .on("mouseup.biblio", on_mouseup_change_mouse_mode, true);

      svg_main.on("mouseover.biblio", on_mouse_main_svg)
              .on("mousemove.biblio", on_mouse_main_svg)
              .on("mouseoout.biblio", on_mouse_main_svg)
              .on("mouseover.shift", on_mouseover_focus_main_svg);

      zoom_rect.on("click.biblio", on_click_change_mouse_mode, true)                     // handle events in capture phase
               .on("mousedown.biblio", on_mousedown_change_mouse_mode, true)
               .on("mouseup.biblio", on_mouseup_change_mouse_mode, true)
               .call(patentMapPlot.zoom);

      plot.on("click.biblio", on_click_change_mouse_mode, true)                          // handle events in capture phase
          .on("mousedown.biblio", on_mousedown_change_mouse_mode, true)
          .on("mouseup.biblio", on_mouseup_change_mouse_mode, true);

      var allPatentNodes = [];                              // global variables for the forcePatent tick event handler
      var allPatentLinks = [];                              // and the zoom event handler
      var allBiblioNodes = [];
      var allBiblioLinks = [];                              // rendered as bLinks from pinned biblios to associated nodes
      var visBibs = [];                                     // global variables for the forceBiblio tick event handler
      var visBibLinks = [];                                 // only update plotting info for visible biblios to save time

      var compiledPop1Template = _.template( $("script#force-pop1").html());

      // define the force map for the patent nodes, specifying the pNodes, pLinks, and linkStrengths
      var forcePatent = d3.layout.force().size([fMap.w, fMap.h]).nodes(patentNodes).links(patentLinks)
                    .gravity(0.05).linkDistance(function(link, i) {return Math.abs(link.source.x_fix - link.target.x_fix);})
                    .charge(-100).linkStrength(0.1)     // gravity 0.05; linkDistance = 50; linkStrength = 1; charge -10000
                    .on("start", on_force_patent_start)
                    .on("tick", on_force_patent_tick);

      // define the force map for the biblio nodes, specifying the nodes, links (empty list), and no forces between nodes
      // forceBiblio map is used for its dragging capability and to be able to plot easily with forcePatent
      var forceBiblio = d3.layout.force().size([fMap.w, fMap.h]).nodes(biblioNodes).links([])
                          .gravity(0).linkDistance(0).charge(0).linkStrength(0)
//                          .on("start", on_force_biblio_start)
                            .on("tick", on_force_biblio_tick);

      var force_patent_drag = forcePatent.drag()
                       .on("dragstart.biblio", on_dragstart_force_patent)
                       .on("drag.biblio", on_drag_force_patent)
                       .on("dragend.biblio", on_dragend_force_patent);

      var force_biblio_drag = forceBiblio.drag()
                       .on("dragstart.biblio", on_dragstart_force_biblio)
                       .on("drag.biblio", on_drag_force_biblio)
                       .on("dragend.biblio", on_dragend_force_biblio);

      var updatePLink = function() {                                    // move a pLink to its new position
            this.attr("x1", function(d) {return d.source.plotX;})
                .attr("y1", function(d) {return d.source.plotY;})
                .attr("x2", function(d) {return d.target.plotX;})
                .attr("y2", function(d) {return d.target.plotY;});
            if (this.size() > 0) {
              this.each(pLinkErr);
            }
                                        
      }

      function pLinkErr(d) {
        if (d3.select(this).attr("x2") == "NaN") {
          debug("In updatePLink, link is: ", d3.select(this), d, d.target.plotX, d.target.plotY);
        }
      }

      function bLinkErr(d) {
        if (d3.select(this).attr("x2") == "NaN") {
          debug("In updateBLink, link is: ", d3.select(this), d, d.patentNode.plotX, d.patentNode.plotY);
        }
      }

      var updateBLink = function() {                                    // move a pLink to its new position
            this.attr("x1", function(d) {return d.patentNode.plotX;})
                .attr("y1", function(d) {return d.patentNode.plotY;})
                .attr("x2", function(d) {return d.biblioNode.plotX;})
                .attr("y2", function(d) {return d.biblioNode.plotY + 7;});  // connect to biblio itself, not the marker center
            if (this.size() > 0) {
              this.each(bLinkErr);
            }
      }

      var updatePatentNode = function() {                                    // move a node to its new position
            this.attr("transform", function(d) {return "translate(" + d.plotX + "," + d.plotY + ")";});
      }

      var updateBib = function() {
      // 'this' is the d3 selection of all div.bibs that have div.pop1-container.make-displayed
        // move the div.bibs to their new positions
        this.style({"-webkit-transform": function(d) {return "translate(" + d.plotX + "px," + d.plotY + "px)"},   // Chrome
                    "transform": function(d) {return "translate(" + d.plotX + "px," + d.plotY + "px)"}});         // Firefox
        this.classed({"out-of-bounds": function(d, i) {     // detect if node is out of the plotting region; if so, do not display
                 return (d.plotY < 0 || d.plotY > plotSize.h || d.plotX > plotSize.w || d.plotX < 0);
               }});
      }

      updateForceMap();

      function on_force_patent_start() {
      // event handler for forcePatent.start event; also called by updateForceMap
      // update the nodes, links, biblios that will be updated on the forcePatent map as the forcePatent layout runs
      // tick event handler must update all the visible items on the map
        // need to be sure to select all nodes currently on the map before re-starting
        allPatentNodes = svg.selectAll("g.node")
                            .sort(function(a, b) {                 // sort so the source nodes are drawn last so can see labels
                                    return (a.source < b.source) ? -1 : ((a.source > b.source) ? 1 : 0);
                                  })
                            .order();
        allBiblioNodes = d3.selectAll("div.bib");
        visBibs = allBiblioNodes.filter(hasPop1Displayed);         // update only div.bibs whose biblios are visible
        allPatentLinks = svg.selectAll("line.patent-link");
        allBiblioLinks = svg.selectAll("line.biblio-link");
        // update only line.biblio-links whose biblios are visible; make sure to update visBibs first
        visBibLinks = allBiblioLinks.filter(function(d, i) {return d.biblioNode.displayed});
        forceBiblio.stop();                                  // forceBiblio is a slave to forcePatent
      }

      function hasPop1Displayed(d, i) {
      // 'this' is a div.bib element; returns true if the element has a child div.pop1-container.make-displayed
        d.displayed = (d3.select(this).select("div.pop1-container.make-displayed").size() > 0);
        return d.displayed;
      }

      function on_force_biblio_tick(e) {
      // tick event handler for the forceBiblio map; if a biblio is not pinned, update its coordinates; if it is
      // pinned, do not update coordinates
//debug("Hello from on_force_biblio_tick");
        allBiblioNodes.filter(function(d, i) {return (!d.pinned && !(d.patentNode.drag && pState.mouse == "normal"));}).
          each(function(d, i) {
            d.x = d.patentNode.x;
            d.y = d.patentNode.y;
            d.updatePlotCoord();
          });
        visBibs.call(updateBib);
        visBibLinks.call(updateBLink);
      }

      function on_drag_force_biblio_tick(e) {
      // tick event handler for the forceBiblio map when a node is being dragged
        var draggedBiblio = allBiblioNodes.filter(function(d, i) {return d.drag;});  // get the dragged biblio node
        // update the forceBiblio map coordinates .x and .y
        draggedBiblio.each(function(d, i) { 
//debug("Hello from on_drag_biblio_patent_tick");
//debug("cur tick d: ", d.x, d.y);
              d.plotX = d.orig_plotX + (d.x - d.orig_x);       // follow drag in x direction
              d.x = patentMapPlot.xForceToPlotScale.invert(d.plotX);
//              d.x = d.orig_x;                                // use this to not follow drag in x-direction; do not change d.plotX
              d.plotY = d.orig_plotY + (d.y - d.orig_y);       // drag in y direction
              d.y = patentMapPlot.yForceToPlotScale.invert(d.plotY);
//debug("new tick d: ", d.x, d.y);
            });

        // forcePatent is stopped while dragging biblios, so no need to update the forcePatent map
        visBibs.call(updateBib);
        visBibLinks.call(updateBLink);
      }

      function on_force_patent_tick(e) {
      // tick event handler for the forcePatent map when a node is not being dragged
        allPatentNodes.each(function(d, i) {                                 // update the forcePatent map coordinates .x and .y
//            d.x = d.px + 0.1*(d.x - d.px);
//            d.y = d.py + 0.1*(d.y - d.py);
            d.x = d.x + ((Math.log(10*0.099) - Math.log(10*e.alpha))/(Math.log(10*0.099) - Math.log(10*0.005)))*(d.x_fix - d.x);
                                                      // default value of alpha starts at 0.1 and decays exponentially to 0.005
            d.updatePlotCoord();                                       // update the SVG plotting coordinates .plotX and .plotY
          });
        allPatentNodes.call(updatePatentNode);
        allPatentLinks.call(updatePLink);
        on_force_biblio_tick(e);                               // allow forceBiblio to follow forcePatent
      }

      function on_drag_force_patent_tick(e) {
      // tick event handler for the forcePatent map when a node is being dragged
        allPatentNodes.each(function(d, i) {                   // update the forcePatent map coordinates .x and .y
            if (d.drag) {                                      // this patent node is being dragged
//debug("Hello from on_drag_force_patent_tick");
//debug("cur tick d: ", d.x, d.y);
//                d.plotX = d.orig_plotX + (d.x - d.orig_x);   // use this and next line if want to follow drag in x direction
//                d.x = patentMapPlot.xForceToPlotScale.invert(d.plotX);
              d.x = d.orig_x;                                  // do not drag in x direction; do not change d.plotX
              d.plotY = d.orig_plotY + (d.y - d.orig_y);       // drag in y direction
              d.y = patentMapPlot.yForceToPlotScale.invert(d.plotY);
//debug("new tick d: ", d.x, d.y);
            }
            else {
              d.x = d.x + 0.2*(d.x_fix - d.x);
              d.updatePlotCoord();                             // update the SVG plotting coordinates .plotX and .plotY
            }
          });

        allPatentNodes.call(updatePatentNode);
        allPatentLinks.call(updatePLink);
        on_force_biblio_tick(e);                               // allow forceBiblio to follow forcePatent
      }

      function on_dragstart_force_biblio(d, i) {
//debug("Hello from on_dragstart_force_biblio for patent " + d.patent_no);
        d.drag = true;                              // save the current x position so can restrict the drag to the y direction
        d.orig_x = d.x;
        d.orig_y = d.y;
        d.orig_plotX = d.plotX;
        d.orig_plotY = d.plotY;
        allPatentNodes.filter(function(dd, ii) {return (dd.patent_no != d.patent_no);})
                      .selectAll("circle").classed({"pointer-events-none": true});
        svg_main.on("mouseover.biblio", null)
                .on("mousemove.biblio", null)
                .on("mouseoout.biblio", null);
        // pState.mouse is always 'normal' when dragging a biblio
        var otherBibs = allBiblioNodes.filter(function(dd, i) {return (dd.patent_no != d.patent_no);});
        otherBibs.select("div.pop1-container").classed({"pointer-events-none": true});      // disable mouse events on other
        otherBibs.select("g.pop1-marker").classed({"pointer-events-none": true});           // div.pop1-containers
        // disable mouseenter and mouseleave handlers to avoid biblio disappearing and reappearing during drag
        var divBib = d3.select(this);
        $(divBib.node()).off("mouseenter.biblio");  // remove jQuery event handlers
        $(divBib.node()).off("mouseleave.biblio");  // to protect against slow dragging
        
        forceBiblio.on("tick", on_drag_force_biblio_tick);  // attach special tick event handler when dragging
        fMap.alpha = forcePatent.alpha();
        forcePatent.stop();                         // so will not have competing force maps during drag
      }

      function on_drag_force_biblio(d, i) {
      // When the drag handler is called, event.clientX, event.clientY is the position computed as the d.x, d.y
      // when the drag was started + pixels traveled by dragging; thus the starting point is in force map coordinates,
      // but the distance traveled is in pixels (i.e., plotting coordinates).
      // event.dx, event.dy are the changes in pixels from the previous mouse position;
      // d.x, d.y are the old force coordinates; they have not yet been updated with the current mouse event coordinates
      // by the time the tick handler is called, d.x, d.y values are the same as the drag event.x, event.y;
      // changing: event.x, event.y; event.dx, event.dy; or d.x., d.y in the drag handler has no effect on d in tick event handler
      // if d.x, d.y are changed in the tick handler, those values are still present when the drag handler is called.

        // check if biblio location relative to its associated patentNode should trigger a change in the pinned status
        // 'dist' is the node-biblio distance that triggers changes
        var dist = 1.7*d.patentNode.markerRadius;
        checkPinTrigger(d3.select(this), d, d.patentNode, dist);
      }

      function checkPinTrigger(divBib, bibNode, patNode, dist) {
      // divBib is the d3 object for the biblio div.bib
      // bibNode and patNode are datum objects; one of them is being dragged and the other is stationary 
      // d3 element associated with the 'dragged' element; 'dist' is the node-biblio distance that triggers changes

        // if biblio node near the associated patent node
        if (patNode.plotX - bibNode.plotX < dist && bibNode.plotX - patNode.plotX < dist
                     && patNode.plotY - bibNode.plotY < dist && bibNode.plotY - patNode.plotY < dist) {
          makeBiblioDetached(divBib);                                    // change from pinned to detached
        }

        // if biblio not pinned and getting too far away the associated patent node
        else if (!bibNode.pinned && !(patNode.plotX - bibNode.plotX < dist && bibNode.plotX - patNode.plotX <  dist
                     && patNode.plotY - bibNode.plotY < dist && bibNode.plotY - patNode.plotY < dist)) {
          makeBiblioPinned(divBib);                                       // change from detached to pinned
        }
      }

      function on_dragend_force_biblio(d, i) {
//debug("Hello from on_dragend_force_biblio for patent " + d.patent_no);
        d.drag = false;
          // need to change d.px, d.py because at end of drag they are set to coordinates based on the current mouse position,
          // not the current node position, causing nodes to bounce back into position in weird ways
        d.px = patentMapPlot.xForceToPlotScale.invert(d.plotX);
        d.py = patentMapPlot.yForceToPlotScale.invert(d.plotY);
        var divBib = d3.select(this);
        if (d.detached) {
          makeBiblioUnpinned(divBib);
        }
        // do not render marker or top-capture if biblio is pinned; wait for dragend since might be dragging on the marker
        if (d.pinned) {
          makeBiblioPinnedTop(divBib);
        }
        allPatentNodes.selectAll("circle").classed({"pointer-events-none": false});    // disable mouse events on nodes
        svg_main.on("mouseover.biblio", on_mouse_main_svg)
                .on("mousemove.biblio", on_mouse_main_svg)
                .on("mouseoout.biblio", on_mouse_main_svg);
        // pState.mouse is always 'normal' when dragging a biblio
        var otherBibs = allBiblioNodes.filter(function(dd, i) {return (dd.patent_no != d.patent_no);});
        otherBibs.select("div.pop1-container").classed({"pointer-events-none": false});      // disable mouse events on other
        otherBibs.select("g.pop1-marker").classed({"pointer-events-none": false}); // visible div.pop1-containers
        var divBib = d3.select(this);
        $(divBib.node()).on("mouseenter.biblio", on_mouseenter_force_biblio);  // reattach jQuery event handlers
        $(divBib.node()).on("mouseleave.biblio", on_mouseleave_force_biblio);

        forceBiblio.on("tick", on_force_biblio_tick);
        forceBiblio.stop();
        forcePatent.alpha(Math.max(fMap.alpha, 0.06));                         // restart forcePatent so everything updates
      }

      function on_dragstart_force_patent(d, i) {
//debug("Hello from on_dragstart_force_patent for patent " + d.patent_no);
//debug(d3.event);
        d.drag = true;                              // save the current x position so can restrict the drag to the y direction
        d.orig_x = d.x;
        d.orig_y = d.y;
        d.orig_plotX = d.plotX;
        d.orig_plotY = d.plotY;
        allPatentNodes.filter(function(dd, ii) {return (dd.patent_no != d.patent_no);})
                      .selectAll("circle").classed({"pointer-events-none": true});
        svg_main.on("mouseover.biblio", null)
                .on("mousemove.biblio", null)
                .on("mouseoout.biblio", null);
        if (pState.mouse == "normal") {
          var otherBibs = allBiblioNodes.filter(function(dd, ii) {return (dd.patent_no != d.patent_no);});
          otherBibs.select("div.pop1-container").classed({"pointer-events-none": true});      // disable mouse events on other
          otherBibs.select("g.pop1-marker").classed({"pointer-events-none": true});      // visible div.pop1-containers
          // disable mouseenter and mouseleave handlers to avoid biblio disappearing and reappearing during drag
          var divBib = d3.select("div.bib[data-patent=" + d.patent_no + "]");
          $(divBib.node()).off("mouseenter.biblio");  // remove jQuery event handlers
          $(divBib.node()).off("mouseleave.biblio");  // to protect against slow dragging
        }
        forcePatent.on("tick", on_drag_force_patent_tick);   // attach special tick event handler when dragging
        fMap.alpha = forcePatent.alpha();
        forcePatent.stop();                         // so will not have competing force maps during drag
        d.fixed = true;                             // so node does not move after dragging
      }

      function on_drag_force_patent(d, i) {
      // When the drag handler is called, event.x, event.y is the position computed as the d.x, d.y when the drag was started
      // + pixels traveled by dragging; thus the starting point is in force map coordinates, but the distance traveled is
      // in pixels (i.e., plotting coordinates).
      // event.dx, event.dy are the changes in pixels from the previous mouse position;
      // d.x, d.y are the old force coordinates; they have not yet been updated with the current mouse event coordinates
      // by the time the tick handler is called, d.x, d.y values are the same as the drag event.x, event.y;
      // changing: event.x, event.y; event.dx, event.dy; or d.x., d.y in the drag handler has no effect on d in tick event handler
      // if d.x, d.y are changed in the tick handler, those values are still present when the drag handler is called.

        // check if patentNode location relative to its associated biblioNode should trigger a change in the pinned status
        if (pState.mouse == "normal") {
          var divBib = visBibs.filter(function(dd, ii) {return (dd.patent_no == d.patent_no);});
          var dist = 1.7*d.markerRadius;
          if (divBib.size() > 0) {
            checkPinTrigger(divBib, d.biblioNode, d, dist);
          }
        }
      }

      function on_dragend_force_patent(d, i) {
//debug("Hello from on_dragend_force_patent for patent " + d.patent_no);
        d.drag = false;
          // need to change d.px, d.py because at end of drag they are set to coordinates based on the current mouse position,
          // not the current node position, causing nodes to bounce back into position in weird ways
        d.px = patentMapPlot.xForceToPlotScale.invert(d.plotX);
        d.py = patentMapPlot.yForceToPlotScale.invert(d.plotY);
        var divBib = visBibs.filter(function(dd, ii) {return (dd.patent_no == d.patent_no);});
        if (d.biblioNode.detached) {
          makeBiblioUnpinned(divBib);
        }
        // do not render marker or top-capture if biblio is pinned
        if (d.biblioNode.pinned) {
          makeBiblioPinnedTop(divBib);
        }
        allPatentNodes.selectAll("circle").classed({"pointer-events-none": false});    // re-enable mouse events on nodes
        svg_main.on("mouseover.biblio", on_mouse_main_svg)
                .on("mousemove.biblio", on_mouse_main_svg)
                .on("mouseoout.biblio", on_mouse_main_svg);
        if (pState.mouse == "normal") {
          var otherBibs = allBiblioNodes.filter(function(dd, i) {return (dd.patent_no != d.patent_no);});
          otherBibs.select("div.pop1-container").classed({"pointer-events-none": false});      // disable mouse events on other
          otherBibs.select("g.pop1-marker").classed({"pointer-events-none": false}); // visible div.pop1-containers
          var divBib = d3.select("div.bib[data-patent=" + d.patent_no + "]");
          $(divBib.node()).on("mouseenter.biblio", on_mouseenter_force_biblio);  // reattach jQuery event handlers
          $(divBib.node()).on("mouseleave.biblio", on_mouseleave_force_biblio);
        }
        forcePatent.on("tick", on_force_patent_tick);
        forcePatent.alpha(Math.max(fMap.alpha, 0.06));                           // restart forcePatent so everything updates
      }

      function updateForceMap() {
      // add new nodes to the forcePatent and forceBiblio maps as the patent data is received from EPO
        debug("In updateForceMap, patentNodes: ", patentNodes, "; patentLinks: ", patentLinks);

        // add the new pLinks to the SVG (just new pLinks using .enter.append)
        var pLink = plot.selectAll("line.patent-link").data(forcePatent.links(), function(d) {return d.key;});
        pLink.enter().append("svg:line")
                     .classed({"patent-link": true})
                     .attr({"data-link-key": function(d, i) {return d.key;}})
                     .style({"stroke": function(d, i) {
                                        switch(d.type) {
                                          case "cited":
                                            return "tomato";
                                          case "citing":
                                            return "darkgreen";
                                          case "related":
                                            return "darkblue";
                                        }
                                      },
                           "stroke-width": "1px"});
        pLink.exit().remove();

        // add lines connecting nodes to biblios
        var bLink = plot.selectAll("line.biblio-link").data(biblioLinks, function(d) {return d.key;});
        bLink.enter().append("svg:line").classed({"biblio-link": true})
                     .attr({"data-patent": function(d, i) {return d.patent_no;}});   // add the new biblio-node bLinks
        bLink.exit().remove();

        // add the new nodes to the SVG (just new nodes using .enter.append); attach event handler to g.node, but enable
        // pointer events only on the node circles.
        var curNode = plot.selectAll("g.node").data(forcePatent.nodes(), function(d) {return d.key;});
        var newNode = curNode.enter().append("svg:g")
                             .classed({"node": true})
                             .attr({"data-patent": function(d, i) {return d.patent_no;}})
                             .on("mouseover.biblio", on_mouseover_force_patent)
                             .on("mousemove.biblio", on_mousemove_force_patent);
        curNode.exit().remove();

        // add new div.bibs to the main bib-container div; newBibDiv is just the new divs (.enter.append); must set z-index on
        // the div.bibs because they are siblings in the DOM; setting z-index directly on the div.pop1-containers does not
        // work since they are not siblings.
        var curBibDiv = bib.selectAll("div.bib").data(forceBiblio.nodes(), function(d) {return d.key;});
        var newBibDiv = curBibDiv.enter().append("div")
                                 .classed({"bib": true})
                                 .attr({"data-patent": function(d, i) {return d.patent_no;}})
                                 .style({"z-index": function(d, i) {return d.z_index;}});

        curBibDiv.exit().remove();

        // jQuery mouseleave event is much more useful here than javascript mouseout event (see comments in the event
        // handler for more details); attach to div.bib so can handle events on both div.pop1-container and g.pop1-marker
        newBibDiv.each(function(d, i) {$(this).on("mouseleave.biblio", on_mouseleave_force_biblio)
                                              .on("mouseenter.biblio", on_mouseenter_force_biblio);});

        plot.selectAll("g.node, line.patent-link, line.biblio-link")
            .sort(function(a, b) {                            // order needs to be line.patent-links, then line.biblio-links,
                 if (a.sortOrder < b.sortOrder) return -1;    // then g.nodes, so graphics overlay each other correctly
                 if (a.sortOrder > b.sortOrder) return 1;
                 return 0;
                }).order();

        on_force_patent_start();                   // refresh lists of nodes, links, and visible biblios on forcePatent map

        patentMapPlot.updateXAxisLimits();         // update the x-axis plot limits
        patentMapPlot.updateXAxisContent();        // update tick locations and labels for patentMapPlot.xAxisLabel and .xAxisGrid
        patentMapPlot.updateForceScaling();        // update the patentMapPlot.xForceToPlotScale according to new plot limits

        // insert the html for the biblio popup that appears when the mouse is over a patent node, and then attach event handlers
        newBibDiv.html(function(d, i) {return compiledPop1Template(
                                        {patent_no: d.patent_no, patent_label: d.label, file_date: d.biblio.file_date,
                                         pub_date: d.biblio.pub_date, title: d.biblio.title, inventors: d.biblio.inventors,
                                         assignee: d.biblio.assignee, abstract: d.biblio.abstract});});
        // select the top-level biblio popup containers div.pop1-container in the html added under the div.bib
        var divPop = newBibDiv.select("div.pop1-container")           // select copies d3 data from div.bib to div.pop1-container
                              .style({"min-width": pop1P.minWidth + "px", "max-width": pop1P.maxWidth + "px"});
        divPop.selectAll("a.pop1-patent-url")                                                     // set patent links
                       .on("click.biblio", on_click_new_patent_url_map)
                       .on("mousedown.biblio", on_mousedown_no_drag);                          // prevent triggering dragstart
        divPop.selectAll("a.pop1-search-url")
                       .on("click.biblio", on_click_new_search_url_map)
                       .on("mousedown.biblio", on_mousedown_no_drag);                          // prevent triggering dragstart
        divPop.select("div.pop1-top-btns")
                       .on("click.biblio", on_click_top_buttons_biblio)
                       .on("mouseover.biblio", on_mouseover_top_buttons_biblio)
                       .on("mouseout.biblio", on_mouseout_top_buttons_biblio);
        divPop.each(function(d,i) {setupMapFavButtons(this, document, "map", d.patent_no);});  // set up map and favorite buttons
        divPop.select("div.pop1-buttons").selectAll("span")                                    // select all buttons (map, fav etc)
                       .on("mousedown.biblio", on_mousedown_no_drag);                          // prevent triggering dragstart
        divPop.select("span.btn-hide-add")                                                     // set up the delete button
                       .attr({"data-patent": function(d, i) {return d.patent_no;}})
                       .on("click.biblio", on_click_delete_btn);
        divPop.select("span.btn-pin-add")                                                      // set up the pin/unpin buttons
                       .attr({"data-patent": function(d, i) {return d.patent_no;}})
                       .on("click.biblio", on_click_pin_btn);

        addPopArrowCircleSVG(newBibDiv);           // add svg for arrow and node circle at top of biblio
        addPopTopBtns(newBibDiv);                  // add svg for buttons at top right of biblio
        setBiblioState(newBibDiv);                 // set css pointer-events according to pState.mouse ('normal' or 'transparent')

        if (allPatentNodes.size() > 0) {           // when page initially loads, stop force map from running so animation goes as
          forcePatent.start();                     // smoothly as possible
        }

        // finish appending svg elements 
        newNode.each(setupMarkers);                                         // add the node markers
        newNode.append("svg:text").text(function(d, i) {return d.label})    // add the node labels to the SVG
               .classed("node-label", true)
               .attr({"text-anchor": "middle", "dominant-baseline": "middle",
                     "transform": "translate(0, " + (-labelDistance) + ")",
                     "data-patent": function(d, i) {return d.patent_no;}});

        updateLegend();

        // update the node colors
        allPatentNodes.each(updateForceMapSymbolColor);

        newNode.call(force_patent_drag);                                           // allows nodes to be dragged with the mouse
        newBibDiv.call(force_biblio_drag);
      }

      function updateForceMapSymbolColor(d, i) {
        var legendKey = d.biblio.shortAssignee;
        var legendObject = legendObjects[legendKey];
        var legendIndex = plottedLegendEntries.indexOf(legendObject);
        var legendColor = (legendIndex != -1) ? legendObject.legendColor : legendObjects["AllOthers"].legendColor;
        d3.select(this).selectAll("circle.force-patent-circle, circle.force-mapped-circle, circle.force-favorite-circle")
              .style({"fill": legendColor});        
      }

      function updateLegend() {
      // called from updateForceMap, deletePatentFromMap, removePatentFromMapped
        // determine if we need to have an 'AllOthers' entry in the legend; add a LegendEntry object if needed; always use
        // legendColors[0] for the color of 'AllOthers' if needed
        if (legendEntries.length > nLegendEntry) {            // need to create the 'AllOthers' entry
          if (!legendObjects["AllOthers"]) {
            legendObjects["AllOthers"] = new LegendEntry("Others", legendColors[0], 0);      // always use legendColors[0]
          }
          legendObjects["AllOthers"].patentCount = 0;
          for (var iL = nLegendEntry - 1; iL < legendEntries.length - 1; iL++) {   // the last entry is 'Others' at this point
            var notShownEntry = legendEntries[iL]
            legendObjects["AllOthers"].patentCount += notShownEntry.patentCount;
          }
          plottedLegendEntries = legendEntries.slice(0, nLegendEntry - 1).concat([legendObjects["AllOthers"]]);
        }
        else {
          plottedLegendEntries = legendEntries.slice(0, nLegendEntry);
        }

        // now update the SVG for the legend
        legend.select("rect.legend-frame").remove();
        // show only the first nLegendEntry entries
        var curLegendItem = legend.selectAll("g.legend-entry").data(plottedLegendEntries);
        curLegendItem.select("circle.legend-symbol");                             // propagate the new data to the child elements!
        curLegendItem.select("text.legend-text");
        var newLegendItem = curLegendItem.enter().append("svg:g").classed({"legend-entry": true});     // add new legend entries
        newLegendItem.append("svg:circle").classed({"legend-symbol": true}).attr({"r": 5});
        newLegendItem.append("svg:text").classed({"legend-text": true});
        curLegendItem.exit().remove();
        curLegendItem = legend.selectAll("g.legend-entry");                                 // refresh the data for the legend SVG
        curLegendItem.attr({"transform": function(d, i) {return "translate(0," + i*14 + ")";}});       // list the entries
        curLegendItem.selectAll("circle.legend-symbol")
                            .style({"fill": function(d, i) {return d.legendColor;}});
        curLegendItem.selectAll("text.legend-text").attr({"transform": "translate(15,0)", "dominant-baseline": "middle"})
                            .text(function(d, i) {return d.assignee + " (" + d.patentCount + ")";});
        if (legendEntries.length > 0) {
          var bBox = legend.node().getBBox();                          // get bounding box of an SVG element
          legend.insert("svg:rect", ":first-child").classed({"legend-frame": true})             // first element in g
                       .attr({"x": "-12", "y": "-12", "width": bBox.width + 13, "height": bBox.height + 9});
        }
      }

      function recycleLegendColor(legendEntry) {
      // puts legendEntry.legendColor back in the list of available colors; called from deletePNode and updateLegend.
        legendColors.push(legendEntry.legendColor);                  // add to end of color list
        legendEntry.legendColor = "";
      }

      function getNewLegendColor(legendEntry) {
      // assigns an unused legend color to legendEntry.legendColor
        legendEntry.legendColor = legendColors.pop();                          // pop from end of color list
      }

      function addToLegend(patentNode) {
      // add the patent represented by patentNode to the legend; called from addPatentToPlottingLists
        var assignee = patentNode.biblio.assignee;
        var shortAssignee = patentNode.biblio.shortAssignee;
        var legendEntry = legendObjects[shortAssignee];
        if (!legendEntry)  {                 // add object for this assignee to legendObjects and add to the legendEntries array
          legendEntry = new LegendEntry(assignee, "", 0);
          legendObjects[shortAssignee] = legendEntry;
          legendEntries.push(legendEntry);
        }
        legendEntry.patentCount +=1;
        legendEntries.sort(legendSort);
        var curEntryIndex = legendEntries.indexOf(legendEntry);
        if (curEntryIndex <= nLegendColors - 1 && legendEntry.legendColor == "") {   // we need to assign a legend color
          if (legendColors.length > 1) {
            getNewLegendColor(legendEntry);
          }
          // take color of the nLegendColor'th entry; (one legendColor is always reserved for the 'AllOthers' entry)
          else {
            var lastColoredEntry = legendEntries[nLegendColors-1];
            legendEntry.legendColor = lastColoredEntry.legendColor;
            lastColoredEntry.legendColor = "";
          }
        }
      }

      function deleteFromLegend(patentNode) {
      // delete the patent represented by patentNode from the legend; called from deletePNode.
        var shortAssignee = patentNode.biblio.shortAssignee;
        var legendEntry = legendObjects[shortAssignee];
        legendEntry.patentCount -= 1;
        legendEntries.sort(legendSort);
        var curEntryIndex = legendEntries.indexOf(legendEntry);
        if (curEntryIndex > nLegendColors - 2 && legendEntry.legendColor != "") {   // we need to give the color to another entry
          var lastLegendEntry = legendEntries[nLegendColors - 2]
          lastLegendEntry.legendColor = legendEntry.legendColor;
          legendEntry.legendColor = "";
        }
        if (legendEntry.patentCount == 0) {                             // if no other patents from this company
          legendEntries.splice(curEntryIndex, 1);                       // delete assignee from the legendEntries
          if (legendEntry.legendColor != "") {
            recycleLegendColor(legendEntry);          
          }
          delete legendObjects[shortAssignee];                            // and from the legendObjects collection
        }
      }

      function legendSort(a, b) {
      // sorting function for legendEntries
        if (a.patentCount < b.patentCount) return 1;      // sort in descending order of count
        if (a.patentCount > b.patentCount) return -1;
        // if patentCount is the same:
        // put 'Assignee not available' last
        if (a.assignee == "Assignee not available") return 1;
        if (b.assignee == "Assignee not available") return -1;
        if (a.assignee > b.assignee) return 1;            // sort in ascending alphabetic order
        if (a.assignee < b.assignee) return -1;
        return 0;
      }

      function updateMarkerOnForceMap(marker, page_type) {
      // called from setupMarkers, addSourcePatentToForceMap, addMapPatent, on_mouseover_patent_list_patent,
      // and on_mouseout_patent_list_patent
      // change the marker to type markerType ("normal", "mapped", or "favorite") on the force map,
      // depending on prioritized testing of which list(s) the patent is in;
      // marker is the d3 g.force-patent-marker element containing the circle svg; page_type is page type
      // that the 'map' or 'favorite' button was clicked on or being setup from.

        var patent_no = marker.datum().patent_no;
        // priority of markers is "mapped", "favorite", "normal".
        var onMappedList = (patentLists["map"].indexOf(patent_no) != -1);           // -1 if not in list
        var onFavoritesList = (patentLists["favorites"].indexOf(patent_no) != -1);  // -1 if not in list
        var markerType = (onMappedList) ? "mapped" : ((onFavoritesList) ? "favorite" : "normal");
        switch (markerType) {
          case "normal":
            var markerRadius = 7;
            var circleClass = "force-patent-circle";
            break; 
          case "mapped":
            var markerRadius = 10;
            var circleClass = "force-mapped-circle";
            var iconDef = "#force-mapped-cross-def";
            break;
          case "favorite":
            var markerRadius = 10;
            var circleClass = "force-favorite-circle";
            var iconDef = "#force-favorite-heart-def";
            break;
        }
        marker.attr({"data-marker": markerType});                // update the type of marker it is
        marker.datum().markerRadius = markerRadius;
        marker.select("use").remove();
        var markerCircle = marker.select("circle")
                                 .attr({"class": circleClass, "r": markerRadius});
        switch (page_type) {
          case "mapped-list": case "favorites-list":
            markerCircle.style({"stroke-width": "3px"});
            break;
          default:
            markerCircle.style({"stroke-width": null});
        }        
        if (markerType == "mapped" || markerType == "favorite") {
          marker.append("svg:use").attr({"xlink:href": iconDef});
        }
        d3.select("div.bib[data-patent=" + patent_no + "]").select("circle.pop1-marker").attr({"r": markerRadius});
      }

      function setupMarkers(d, i) {
      // called from updateForceMap to set up node markers on the force map
      // checks if patent_no is in the 'map' or 'favorites' list and changes the node marker if so
      // SVG elements do not have innerHTML properies that allows us to add SVG on the fly using d3 .html() or jQuery .after();
      // one way to get around this is to follow suggestion in d3 documentation, and add innersvg.js polyfill at
      // https://code.google.com/p/innersvg via a script tag in the document header; (need to apply patch to use the <use> tag;
      // the alternative, which I ended up going with is to add all the svg using d3 
        var patentNode = d3.select(this);
        var patent_no = d.patent_no;
        var marker = patentNode.append("svg:g").classed({"force-patent-marker": true})
                               .attr({"data-patent": patent_no});
        marker.append("svg:circle");
        updateMarkerOnForceMap(marker, "map");
      }

      function deletePLink(patentLink) {
      // delete patentLink (of type PatentLink) from the forcePatent map; but do not delete the patentLink itself;
        var linkKey = patentLink.key;
        var index = patentLinks.indexOf(patentLink);
        if (index != -1) {
          patentLinks.splice(index, 1);                                     // remove 1 patentLink from patentLinks at the index
          // note we do not delete the linkKey entry in the targetPatentLinksList, targetPatentLinks, or sourcePatentLinks
          // objects of the source and target patentNodes because we need to keep a record of the patents that are linked
          // together in case a patent is un-deleted and we want to replot all the associated links;  need to call updateForceMap
          // to actually remove the SVG elements associated with patentLink
          patentLink.source.plotLinks -= 1;                                 // update link counts for the sourceNode and targetNode
          patentLink.target.plotLinks -= 1;
        }
        else {
          debug("In deletePLink, tried to delete patentLink that was not on the force map: ", patentLink);
        }
      }

      function deleteBNode(biblioNode) {
      // delete biblioNode from the forceBiblio map by deleting it from the biblioNodes list, but do not delete
      // biblioNode itself; need to call updateForceMap to actually remove the SVG elements associated with biblioNode
        var patent_no = biblioNode.patent_no;
        var index = biblioNodes.indexOf(biblioNode);
        if (index != -1) {
          biblioNodes.splice(index, 1);                                       // remove 1 biblioNode from biblioNodes at the index
        }
        else {
          debug("In deleteBNode, tried to delete biblioNode that was not on the force map: ", biblioNode);
        }
      }

      function deleteBLink(biblioLink) {
      // delete biblioLink from the map by deleting it from the biblioLinks list, but do not delete
      // biblioLink itself; need to call updateForceMap to actually remove the SVG elements associated with biblioLink
        var patent_no = biblioLink.patent_no;
        var index = biblioLinks.indexOf(biblioLink);
        if (index != -1) {
          biblioLinks.splice(index, 1);                                       // remove the entry for the link from biblioLinks
        }
        else {
          debug("In deleteBLink, tried to delete biblioLink that was not on the force map: ", biblioLink);
        }
      }

      function deletePNode(patentNode, deletionType) {
      // remove patentNode (of type PatentNode) from the forcePatent map by deleting it from the patentNodes
      // list, but do not delete the patentNode itself; if deleted patent is a source patent, delete it from the
      // patentLists["map"] list and unclick all the associated map buttons; update the patentsUnplotted or deleted
      // lists according to deletionType: if "unplot", the patentNode is being removed as part of unmapping a source patent;
      // or if "delete", the user clicked the delete button for a patent on the force map; need to call updateForceMap
      // to actually delete the SVG elements associated with the patentNode; called from deletePatentFromMap
      // and deleteLinksToTargetPatentsFromMap
	var patent_no = patentNode.patent_no;
        var index = patentNodes.indexOf(patentNode);
        if (index != -1) {
          patentNodes.splice(index, 1);                                     // remove 1 patentNode from patentNodes at the index
          delete patentsPlotted[patent_no];                                 // remove the entry for the patent from patentsPlotted
          switch (deletionType) {
            case "unplot":
              patentsUnplotted[patent_no] = patentNode;
              break;
            case "delete":
              addPatentToDeletedList(patent_no);                            // only place where patent_no is added to deleted list
              break;
          }
          if (patentNode.source) {                                          // if a sourceNode
            // get jQuery map button associated with this patent on forcePatent map to pass to toggleBtn
            var $mapBtn = $("div.bib[data-patent='" + patent_no + "']").find("span.btn-map-add");
            updatePatentListTrackers("map", $mappedList, patent_no, $mapBtn);
          }
          deleteFromLegend(patentNode);
        }
        else {
          debug("In deletePNode, tried to delete patentNode that was not on the force map: ", patentNode);
        }
      }

      function on_click_delete_btn(d, i) {
      // delete the patent and associated pLinks and bLinks from the forcePatent and forceBiblio maps;
      // keep the biblio data available in case the node is replotted;
      // delete from patentNodes and patentLinks arrays which provide data for d3;
      // delete from patentsPlotted which track which patents and pLinks are plotted;
      // delete nodes whose only pLink is to the node being deleted;
      // if deleted patent is a source patent, delete it from the patentLists["map"] list and unclick all the
      // associated map buttons;
        var deleteBtn = d3.select(this).classed({"make-not-displayed": true});  // hide so cannot click twice quickly
        var patent_no = deleteBtn.attr("data-patent");
        deletePatentFromMap(patent_no, "single", on_delete_complete);

        function on_delete_complete() {
          setUndoButtonState();     // will set Undo button state based on whether deleted list has any patents in  it
          setClearButtonState();    // will set Clear button state based on whether patentsPlotted still has any patents in it
        }
      }

      function deletePatentFromMap(patent_no, deletionType, on_delete_patent) {
      // called from on_click_delete_btn and on_click_clear_btn; remove patent patent_no from the forcePatent
      // and forceBiblio maps; deletionType is 'single' or 'group' (for the Clear button); on_delete_patent is
      // an optional callback called after the deletion is complete
        fMap.alpha = forcePatent.alpha();
        var patentNode = d3.select("g.node[data-patent=" + patent_no + "]").datum();
        d3.select("div.bib[data-patent=" + patent_no + "] div.pop1-container")
          .classed({"make-displayed": false});

        // if patent_no is a source patent, delete target nodes first to help preserve legend colors if patent is undeleted
        if (patentNode.source) {
          // delete pLinks with patent_no as source; nextDeletions is the callback
          deleteLinksToTargetPatentsFromMap(patentNode, nextDeletions);     // nextDeletions is the callback
        }
        else {
          nextDeletions();
        }

        function nextDeletions() {
        // continue the deletion process; called from deletePatentFromMap when deleted patent is a target patent
        // and deleteTargetGroup after all target patents for a deleted source patent have been deleted
          deleteLinksToSourcePatentsFromMap(patentNode);                    // delete pLinks with patent_no as target
          deletePNode(patentNode, "delete");                                // delete patentNode from forcePatent map
          deleteBNode(patentNode.biblioNode);                               // delete associated biblioNode from forceBiblio map
          deleteBLink(patentNode.biblioNode.biblioLink);                    // delete associated biblioLink from forceBiblio map

          deletePatentFromMappedSublists(patent_no);                        // delete from any citation sublists
          removeDeleteButtonInFavoritesEntry(patent_no);                    // remove delete button option if patent in Favorites
          // keep .source property unchanged undeleting a patent will undelete it as a source patent or a reference patent
          switch (deletionType) {
            case "single":
              updateForceMap();
              if (patentNode.source) {
                forcePatent.start();                                        // let map rearrange itself significantly
              }
              else {
                forcePatent.start();
                forcePatent.alpha(Math.max(fMap.alpha, 0.06));              // let map relax somewhat
              }
              break;
            case "group":                                                   // calling function responsible for calling
              break;                                                        // updateForceMap when appropriate
          }
          if (on_delete_patent) {
            on_delete_patent();                                             // call the callback if defined
          }
        }
      }

      function deletePatentFromMappedSublists(patent_no) {
      // utility function called from deletePatentFromMap; idelete the patent from all reference sublists in the Mapped
      // list; patent has already been deleted from the Mapped list as a mapped patent in deletePNode.
        // find all entries in the Mapped list for patent_no appears as a reference; will only be in sublists at this point
        var $citationEntry = $mappedList.find("div.patent-list-patent[data-patent='" + patent_no + "']");
        var $citationContainer = $citationEntry.closest("div.patent-list-citation-container");   // select container
        var $citationListHeading = $citationContainer.find("div.patent-list-citation-heading");  // select heading in the container
        $citationListHeading.each(function() {                                                   // update patent counts
                                    incrementCitationCount( $(this), "deleted", 1);
                                    incrementCitationCount( $(this), "mapped", -1);});
        $citationEntry.remove();
      }

      function removeDeleteButtonInFavoritesEntry(patent_no) {
      // utility function called from deletePatentFromMap; remove delete button from entry for patent_no in the
      // Favorites list on the Map page
        $favoritesList.find("span.btn-hide-add[data-patent='" + patent_no + "']").addClass("make-not-displayed");
      }

      function updateSymbols() {
        allPatentNodes = svg.selectAll("g.node");
        allPatentNodes.each(updateForceMapSymbolColor);
      }

      function deleteLinksToSourcePatentsFromMap(targetNode) {
      // targetNode is a PatentNode instance (not a d3 selection); removes all pLinks where targetNode
      // is the target; does not remove the sourceNode even if targetNode is the only link to it
        for (linkKey in targetNode.sourcePatentLinks) {
          var sourceLink = targetNode.sourcePatentLinks[linkKey];  // sourceLink is the link from patentNode as target
          var sourceNode = sourceLink.source;                      // to sourceNode as source
          if (patentLists["map"].indexOf(sourceNode.patent_no) != -1) {  // if source patent is plotted
            deletePLink(sourceLink);
            if (sourceNode.plotLinks == 0) {            // if sourceNode is now disconnected, let the source node stay on the map
//              deletePNode(sourceNode);                             // delete patentNode from forcePatent map
//              deleteBNode(sourceNode.biblioNode);                  // delete associated biblioNode from forceBiblio map
//              deleteBLink(sourceNode.biblioLink);                  // delete associated biblioLink from forceBiblio map
            }
          }
        }
      }

      function deleteLinksToTargetPatentsFromMap(sourceNode, nextDeletions) {
      // sourceNode is a PatentNode instance (not a d3 selection); removes all pLinks where sourceNode
      // is the source patent; removes the targetNode patent if sourceNode is the only link to it and it is
      // not also a source patent; if called from deletePatentFromMap (user clicks delete button), nextDeletions
      // is a callback to continue the deleting process after timeout to allow the force map to relax; if called
      // from removePatentFromMapped (user clicks unmap button), nextDeletions is null.
        var linksList = sourceNode.targetPatentLinksList;
        if (linksList.length == 0) return;
        var nL = 40;                                         // delete nL links and associated patents at a time
        var groupList = createGroupList(linksList, nL);      // break into list of subgroups of indices in linksList
        // delete target patents one group at a time, so map updates during Delete and Clear of large groups of patents
        // delete linked patents in reverse order to help preserve legend colors if a source patent is undeleted
        var iL = groupList.length - 1;
        if (iL >= 0) {
          taskTracker.initialize("Deleting", undefined);
          taskTracker.startTask(groupList.length);
          deleteTargetGroup();
        }
        else {
          if (nextDeletions) {                               // if deleting a patent, not just unmapping it
            nextDeletions();
          }
        }

        function deleteTargetGroup() {
        // delete the iL'th group of links and asociated patents in linksList
          if (arguments.length > 0) {                       // was called recursively after timeout in this function
            taskTracker.finishTask(arguments[0]);
          }
          var index = groupList[iL];
          // delete in reverse order to help preserve legend colors if use undoes the delete
          for (var jL = index.end - 1; jL >= index.start; jL--) {
            var linkKey = linksList[jL];
            deleteTargetPatentFromMap(sourceNode, linkKey);
          }
          updateForceMap();
          if (iL > 0) {
            iL--;
            // call deleteTargetGroup again after allowing 1 task to finish
            window.setTimeout(deleteTargetGroup.bind(undefined, 1), 500);
          }
          else {
            window.setTimeout(afterFinalGroup, 500);
          }
        }

        function afterFinalGroup() {
          taskTracker.finishTask(1);
          if (nextDeletions) {
            nextDeletions();
          }
        }
      }

      function createGroupList(list, nL) {
      // takes a list and returns a list of groupList objects {start: startIndex, end: endIndex} so that list can
      // processed in groups approximately nL in size
        var groupList = [];
        if (list.length > 0) {
          var kL = Math.ceil(list.length/nL)              // number of subgroups
          nnL = Math.floor(list.length/kL);               // make the groups about the same size
          for (var iL = 0; iL < kL - 1; iL++) {
            groupList.push({start: iL*nnL, end: (iL + 1)*nnL});
          }
          groupList.push({start: (kL - 1)*nnL, end: list.length});
        }
        return groupList;
      }

      function deleteTargetPatentFromMap(sourceNode, linkKey) {
      // delete the target patent associated with linkKey; sourceNode is a PatentNode instance (not a d3 selection);
      // called from deleteLinksToTargetPatentsFromMap
        var targetLink = sourceNode.targetPatentLinks[linkKey];  // targetLink is the link from patentNode as source
        var targetNode = targetLink.target;                      // to targetNode as target
        if (targetNode.patent_no in patentsPlotted) {
          deletePLink(targetLink);
          if (targetNode.plotLinks == 0 && !targetNode.source) {   // if targetNode is now disconnected, unplot the targetNode
            deletePNode(targetNode, "unplot");                     // delete patentNode from forcePatent map
            deleteBNode(targetNode.biblioNode);                    // delete associated biblioNode from forceBiblio map
            deleteBLink(targetNode.biblioLink);                    // delete associated biblioLink from forceBiblio map
          }
        }
      }

      function on_click_new_patent_url_map(d, i) {
      // need to call the on_click_new_patent_url event handler set up by jQuery, which is expecting the event object
      // as the only argument and event data in event.data
        d3.event.data = {$context: document, page: "map"};
        on_click_new_patent_url.call(this, d3.event);
      }

      function on_click_new_search_url_map(d, i) {
      // need to call the on_click_new_search_url event handler set up by jQuery, which is expecting the event object
      // as the only argument
        on_click_new_search_url.call(this, d3.event);
      }

      function on_mouse_main_svg() {
      // when in "transparent" mode (no mouse events on div.pop1-containers), detect whether the mouse is over the
      // top visible biblio (div.pop1-container); if not, call mouse_leave_force_biblio to make the biblio disappear
      // the .elementFromPoint method only returns an element if pointer events are enabled on it
      // <a> elements do not pass mousemove events through them
//debug("Hello from on_mouse_main_svg: ", d3.event);
        var evtTgt = d3.event.target
        // if a biblio is visible and event is from force plot (zoom_rect) or main svg area (svg_main)
        if (topBiblio && (evtTgt == zoom_rect.node() || evtTgt == svg_main.node())) {
          var divBib = topBiblio.divBib;
          switch (pState.mouse) {
            // if div.pop1-containers are transparent to mouse events and there has been a div.pop1-container
            // under the mouse check if it is still under the mouse (there must never be more than one topBiblio)
            case "transparent":
              $(divBib.node()).off("mouseleave.biblio");              // remove jQuery mouseleave and mouseenter event handlers
              $(divBib.node()).off("mouseenter.biblio");              // they will be triggered otherwise
              topBiblio.divPop.classed({"pointer-events-none": false});              // activate mouse events
              topBiblio.gMarker.classed({"pointer-events-none": false});
              // see if the biblio is the topmost element; use .clientX, .clientY to work in FF and Chrome
              // (not .x, .y which works only in Chrome).
              var topElement = document.elementFromPoint(d3.event.clientX, d3.event.clientY);
              topBiblio.divPop.classed({"pointer-events-none": true});
              topBiblio.gMarker.classed({"pointer-events-none": true});
              $(divBib.node()).on("mouseleave.biblio", on_mouseleave_force_biblio);  // reattach mouseleave and mouseenter
              $(divBib.node()).on("mouseenter.biblio", on_mouseenter_force_biblio);  // event handlers
              // note that topElement can be divPop, gMarker or any of its children that also capture mouse
              // events, so cannot simply test for topElement != divPop or gMarker.
              if (topElement == zoom_rect.node() || topElement == svg_main.node()) {
                mouseleave_force_biblio(divBib);
              }
              break;
            case "normal":                                     // sometimes (rarely) happens if mouse is moving very quickly
              if (!divBib.datum().runningTimeout) {
                mouseleave_force_biblio(divBib);                 // and the normal mouseleave event is somehow not triggered
              }
              break;
          }
          if (pState.transition  == 0) {
            forcePatent.alpha(Math.max(fMap.alpha, 0.06));
          }
          return;
        }
        if (d3.event.relatedTarget && (evtTgt == zoom_rect.node() || evtTgt == svg_main.node())
                 && pState.mouse == "normal"  && pState.transition == 0) {  // if mouse enters from a div.pop1-container or a
          forcePatent.alpha(Math.max(fMap.alpha, 0.06));                    // g.pop1-marker, .relatedTarget is not null
        }
      }

      function on_mousemove_force_patent(d, i) {
        if (!d.drag) {                             // stop event from bubbling up to svg_main handler
          d3.event.stopPropagation();              // unless the node is being dragged (exception prevents jerky dragging)
        }
      }

      function clearBiblioTimeout(divBib) {
      // clears a timeout, if any, running before calling on_mouseleave_force_biblio; divBib is a d3 div.bib.
        if (divBib.datum().runningTimeout) {
          window.clearTimeout(divBib.datum().runningTimeout);
          divBib.datum().runningTimeout = undefined;
        }
      }       

      function on_mouseover_force_patent(d, i) {
        if (!d.drag) {                             // stop event from bubbling up to svg_main handler
          d3.event.stopPropagation();              // unless the node is being dragged (exception prevents jerky dragging)
        }
        fMap.alpha = forcePatent.alpha();
        forcePatent.stop();
        var patent_no = d3.select(this).attr("data-patent");
//debug("Hello from mouseover_force_patent for patent " + patent_no);
        // there must never be more than one topBiblio at a time; the following block prevents buggy behavior caused
        // by moving the mouse very quickly over a forcePatent node, can sometimes fail to trigger a mouseenter/mouseleave
        // sequence on the associated biblio; if then move mouse quickly over a different forcePatent node without triggering
        // an event on the zoom_rect background, the original biblio does not disappear.
        // always make any old topBiblio disappear if it is for a different patent_no 
        if (topBiblio && topBiblio.divBib.attr("data-patent") != patent_no) {
          clearBiblioTimeout(topBiblio.divBib);
          mouseleave_force_biblio(topBiblio.divBib);         // sets topBiblio = undefined
        }
        d3.select("text.node-label[data-patent=" + patent_no + "]").classed({"visited-label": true});
        var divBib = d3.select("div.bib[data-patent=" + patent_no + "]");
        var divPop = divBib.select("div.pop1-container");
        var gMarker = divBib.select("g.pop1-marker");
        if (!divBib.datum().pinned) {                        // if the biblio is not pinned (i.e., not already visible)
          var bibLink = plot.select("line.biblio-link[data-patent=" + patent_no + "]");
          divBib.call(updateBib);                            // update current forceBiblio map coordinates of the parent div.bib
          bibLink.call(updateBLink);                         // update bLink position before displaying
          divPop.classed({"make-displayed": true});
          bibLink.classed({"make-displayed": true});
          divBib.select("svg.pop1-arrow-circle").classed({"make-displayed": true});
          visBibs = allBiblioNodes.filter(hasPop1Displayed);       // re-select div.bibs whose biblios are visible
          // reselect line.biblio-links whose biblios are visible; make sure to update visBibs first
          visBibLinks = allBiblioLinks.filter(function(d, i) {return d.biblioNode.displayed});
        }
        topBiblio = {"divBib": divBib, "divPop": divPop, "gMarker": gMarker};
        mouseenter_force_biblio(divBib);
      }

      function mouseenter_force_biblio(divBib) {
      // divBib is a d3 div.bib; function is called from on_mouseover_force_patent (g.node)
      // and on_mouseenter_force_biblio (div.pop1-container) event handlers
        var patent_no = divBib.attr("data-patent");
//debug("Hello from mouseenter_force_biblio function for patent " + patent_no);
        // there must never be more than one topBiblio at a time
        divBib.style({"z-index": pState.zMax + 1});          // bring to front temporarily
        if (pState.mouse == "normal") {                      // only show map, favorites, pin, and delete buttons in "normal" mode
          divBib.select("div.pop1-buttons").classed({"make-visible": true});
        }
        // highlight pLinks and bLinks to the node
        highlightLinks(patent_no);
      }

      function highlightLinks(patent_no) {
      // highlight the link lines to patent_no on the force map
        allPatentLinks.filter(function(d, i) {return (d.source.patent_no == patent_no || d.target.patent_no == patent_no);})
                      .style({"stroke-width": function(d, i) {return (d.source.patent_no == patent_no) ? "3px" : "4px";}});
        allBiblioLinks.filter(function(d, i) {return (d.patentNode.patent_no == patent_no);})
                      .style({"stroke-width": "3px"});
      }

      function unhighlightLinks(patent_no) {
      // unhighlight the link lines to patent_no on the force map
        allPatentLinks.filter(function(d, i) {return (d.source.patent_no == patent_no || d.target.patent_no == patent_no);})
                      .style({"stroke-width": "1px"});
        allBiblioLinks.filter(function(d, i) {return (d.patentNode.patent_no == patent_no);})
                      .style({"stroke-width": "1px"});
      }

      function on_mouseout_force_patent(d, i) {
      // placeholder at this point
//debug("Hello from mouseout_force_patent");
      }

      function on_mouseenter_force_biblio(event) {
      // jQuery event handler for div.bib when it is capturing mouse events
//        event.stopPropagation();
        var divBib = d3.select(this);                        // note 'this' is passed by jQuery
        clearBiblioTimeout(divBib);
        // there must never be more than one topBiblio at a time; the following block prevents buggy behavior caused
        // by moving the mouse very quickly over a forcePatent node, can sometimes fail to trigger a mouseenter/mouseleave
        // sequence on the associated biblio; if then move mouse quickly over a different pinned biblio without triggering
        // an event on the zoom_rect background, the original one does not disappear.
        // always make any old topBiblios disappear:
        if (topBiblio && (topBiblio.divBib.datum().patent_no != divBib.datum().patent_no)) {
          mouseleave_force_biblio(topBiblio.divBib);         // sets topBiblio = undefined
        }

        // if divBib is not already the active biblio because we did not enter the biblio via
        // on_mouseover_force_patent, but entered a pinned biblio directly 
        if (divBib.style("z-index") != pState.zMax + 1) {
          mouseenter_force_biblio(divBib);
        }
      }

      function on_mouseleave_force_biblio(event) {
      // jQuery event handler for div.pop1-container when it is capturing mouse events ("normal" mouse mode); use the jQuery
      // mouseleave event, which fires when the mouse leaves the element to which the event handler is attached.  In the
      // present case, the div.pop1-container is the parent of child elements that trigger mouseover and mouseout
      // events when the mouse enters and leaves each one; mouseleave is only triggered when the mouse leaves the parent
      // div.pop1-container.
        var divBib = d3.select(this);                    // note 'this' is passed by jQuery
        // condition needed because mouseleave event always triggers when entering "transparent" mode and need to prevent
        // the biblio from disappearing when it is not pinned
        if (pState.mouse == "normal" || divBib.datum().pinned) {
//debug("Hello from mouseleave_force_biblio event handler");
          divBib.datum().runningTimeout = window.setTimeout(mouseleave_force_biblio.bind(this, divBib), 500);
        }
        else {                    // special case when mouseleave is triggered during transition from "normal" to "transparent"
          divBib.select("div.pop1-buttons").classed({"make-visible": false});
        }
      }

      function mouseleave_force_biblio(divBib) {
      // divBib is a d3 div.bib; function is called from the div.bib mouseleave event handler and from
      // on_mouseover_force_patent, on_mouse_main_svg (as part of simulating a mouseout event on a
      // div.pop1-container when it is transparent to mouse events), on_transitionend_opacity_biblio,
      // and on_mouseenter_force_biblio.
        divBib.datum().runningTimeout = undefined;
        var patent_no = divBib.attr("data-patent");
//debug("Hello from mouseleave_force_biblio function for patent " + patent_no);
        if (!divBib.datum().pinned) {                         // if the biblio is not pinned (i.e., already visible)
          if (!divBib.datum().transition) {                   // if the biblio is not transitioning back to its patent node
            divBib.select("div.pop1-container").classed({"make-displayed": false});
            plot.select("line.biblio-link[data-patent=" + patent_no + "]").classed({"make-displayed": false});
            divBib.select("svg.pop1-arrow-circle").classed({"make-displayed": false});
          }
          visBibs = allBiblioNodes.filter(hasPop1Displayed);       // re-select div.bibs whose biblios are visible
          // reselect line.biblio-links whose biblios are visible; make sure to update visBibs first
          visBibLinks = allBiblioLinks.filter(function(d, i) {return d.biblioNode.displayed});
        }
        topBiblio = undefined;
        divBib.style({"z-index": function(d, i) {return d.z_index;}});     // set z_index back to original position
        divBib.select("div.pop1-buttons").classed({"make-visible": false});  // return map, favorite, etc buttons to default state
        // normal width pLinks and bLinks to the node
        unhighlightLinks(patent_no);
      }

      function on_click_pin_btn(d, i) {
      // event handler for clicking the pin/unpin button, in which case 'this' is the span element for the pin button
//debug("Hello from on_click_pin_btn");
        var divBib = d3.select("div.bib[data-patent=" + d.patent_no + "]");
        var coord = {};
        // clone the d3.event properties as they will disappear later; use .clientX, .clientY to work in both FF and
        // Chrome (.x, .y works only in Chrome).
        $.extend(coord, {"x": d3.event.clientX, "y": d3.event.clientY});
        // when biblio is unpinned, the mousedown/mouseup sequence triggers the biblio dragstart/dragend handlers;
        // the biblio returns to the forcePatent node due to setting the forcePatent alpha value at the end of
        // dragend, which causes all positions to update; the biblio will also disappear if the mouseleave event is
        // triggered by the biblio moving out from under the mouse
        if (d.pinned) {                                            // unpin the biblio
          fMap.alpha = forcePatent.alpha();
          // stop the forcePatent force map to prevent biblio returning immediately to the patentNode; 
          // forceBiblio is automatically started during any biblio drag operation, but is stopped in the
          // dragend handler for the biblio.
          forcePatent.stop();
          $(divBib.node()).on("mousemove.transition", on_mousemove_unpinned_biblio);       // jQuery event
          makeBiblioUnpinned(divBib);
          // set up the new biblio position back at the node
          d.x = d.patentNode.x; d.y = d.patentNode.y;
          d.updatePlotCoord();                                     // biblio .datum() now has the new plot coordinates
          // use d3 to make a CSS transition in the transform property (doing up the transition using the CSS 'transition'
          // does not seem to mix well with doing the next transition on the biblioLink using d3; the biblio transition
          // gets canceled) 
          d.transition = true;
          pState.transition += 1;                                  // number of biblios transitioning
          divBib.transition().ease("linear").duration(1000*pState.transformTime)
                             .style({"-webkit-transform": "matrix(1,0,0,1," + d.plotX + "," + d.plotY + ")",
                                     "transform": "matrix(1,0,0,1," + d.plotX + "," + d.plotY + ")"})
                             .each("end", on_transitionend_unpinned_biblio);
          d3.select("line.biblio-link[data-patent=" + d.patent_no + "]").transition() // trigger the animation on the biblio-link
                     .ease("linear").duration(1000*pState.transformTime)
                     .attr({"x2": d.plotX, "y2": d.plotY});
          var transTimeout = window.setTimeout(checkMouseOverBiblio, 50);
        }
        else {                                                                       // pin the biblio
          makeBiblioPinned(divBib);
          makeBiblioPinnedTop(divBib);
        }

        function checkMouseOverBiblio() {
        // timeout function to check if mouse is still over divBib; set d.mouseleave accordingly
          d.mouseleave = !isMouseOverBiblio(divBib, coord);
//debug("Hello from checkMouseOverBiblio");
          if (!d.mouseleave && d.transition) {                                       // if mouse still over biblio during
            transTimeout = window.setTimeout(checkMouseOverBiblio, 50);              // transition check again in 50 msec
          }
        }

        function on_transitionend_unpinned_biblio(dd, ii) {
        // note that the d3.event object is not available for d3 transition 'end' events
        // called when the biblio is finished moving back to its patentNode in on_click_pin_btn
//debug("Hello from on_transitionend_unpinned_biblio");
          window.clearTimeout(transTimeout);
          var divBib = d3.select(this);
          // fires when the transition of the unpinned biblio back to its forcePatent node is complete
          if (d.mouseleave) {                                                    // if mouse is no longer over the biblio
            d.mouseleave = false;                                                // animate its disappearance at the node
            divBib.transition().duration(1000*pState.opacityTime)
                               .style({"opacity": 0})                            // animate disappearance of biblio at the node
                               .each("end", on_transitionend_opacity_biblio);
          }
          else {
            d.transition = false;                                                // transition ended with mouse still over biblio
            pState.transition -= 1;
            if (pState.transition  == 0) {
              forcePatent.alpha(Math.max(fMap.alpha, 0.06));
            }
          }
          $(divBib.node()).off("mousemove.transition");                          // remove transition mousemove handler
        }

        function on_transitionend_opacity_biblio(dd, ii) {
        // fires when the transition of the biblio to transparent is complete (if biblio is no longer under mouse)
        // note that the d3.event object is not available for d3 transition 'end' events
//debug("Hello from on_transitionend_opacity_biblio");
          d.transition = false;                                               // transition ended with mouse no longer over biblio
          pState.transition -= 1;
          var divBib = d3.select(this);
          if (divBib.style("z-index") != d.z_index) {                          // mouseleave was never called; biblio still on top
            clearBiblioTimeout(divBib);
            mouseleave_force_biblio(divBib);                                   // call the normal mouseleave function
          }
          else {                                                               // mouseleave was called with d.transition = true
            divBib.select("div.pop1-container").classed({"make-displayed": false});    // make the remaining changes that were
            plot.select("line.biblio-link[data-patent=" + d.patent_no + "]").classed({"make-displayed": false});
            divBib.select("svg.pop1-arrow-circle").classed({"make-displayed": false}); // postponed in mouseleave_force_biblio
          }
          divBib.style({"opacity": 1});                                        // reset to normal value
          if (pState.transition  == 0) {
            forcePatent.alpha(Math.max(fMap.alpha, 0.06));
          }
        }

        function on_mousemove_unpinned_biblio(event) {                         // handling jQuery event
//debug("Hello from on_mousemove_unpinned_biblio");
        // update coord if user moves the mouse while the biblio is transitioning; also triggered by disappearance of
        // the pin/unpin button and its replacement under the mouse by the delete button; then as the biblio moves, it
        // is triggered as new biblio HTML elements move under the mouse pointer.
          $.extend(coord, {"x": event.clientX, "y": event.clientY});   // clone the event properties as they will disappear later
        }
      }

      function isMouseOverBiblio(divBib, coord) {
      // part of routine used in transitioning an unpinned biblio back to its patentNode; use elementFromPoint and
      // jQuery .find() to detemine if mouse at coordinates coord is over the divBib biblio
        var curElement = document.elementFromPoint(coord.x, coord.y);
        var $findElement = $(divBib.node()).find(curElement);          // jQuery here
        return ($findElement.size() > 0);
      }

      function makeBiblioPinned(divBib) {
      // make the style changes associated with pinning a biblio; called from checkPinTrigger during dragging and
      // from on_click_pin_btn event handler on the pin/unpin button
        divBib.datum().pinned = true;
        divBib.datum().detached = false;
        divBib.select("span.btn-pin-add")
              .classed({"btn-pin-add-display": true, "show-result-btn": true}); // show button; give it the pressed look
        divBib.select("path.pop1-arrow").classed({"make-hidden": true});      // hide the arrow pointing to the patent node
        divBib.select("circle.pop1-marker").classed({"ghost-marker": false}); // no dashed outline for node circle
      }

      function makeBiblioPinnedTop(divBib) {
      // style changes that need to happen after dragging is finished; called from checkPinTrigger during dragging and
      // from on_click_pin_btn event handler on the pin/unpin button
        divBib.select("div.pop1-top-capture").classed({"make-not-displayed": true});
        divBib.select("svg.pop1-arrow-circle").classed({"make-displayed": false});   // default is marker not displayed
      }

      function makeBiblioUnpinned(divBib) {
      // make the style changes associated with unpinning a biblio; called from checkPinTrigger during dragging and
      // from on_click_pin_btn event handler on the pin/unpin button
        divBib.datum().pinned = false;
        divBib.datum().detached = false;
        divBib.select("span.btn-pin-add")
              .classed({"btn-pin-add-display": false, "show-result-btn": false});// do not show button; give it unpressed look
        divBib.select("svg.pop1-arrow-circle").classed({"make-displayed": true});   // default is marker not displayed
        divBib.select("div.pop1-top-capture").classed({"make-not-displayed": false});  // back to default
        divBib.select("path.pop1-arrow").classed({"make-hidden": false});     // hide the arrow pointing to the patent node
        divBib.select("circle.pop1-marker").classed({"ghost-marker": false}); // no dashed outline for node circle
      }

      function makeBiblioDetached(divBib) {
      // make the style changes associated with putting biblio in the detached state; called from checkPinTrigger
      // when dragging a biblio or a patent node
        divBib.datum().pinned = false;
        divBib.datum().detached = true;
        divBib.select("span.btn-pin-add")
              .classed({"btn-pin-add-display": false, "show-result-btn": false});// do not show button; give it unpressed look
        divBib.select("svg.pop1-arrow-circle").classed({"make-displayed": true});   // default is marker not displayed
        divBib.select("div.pop1-top-capture").classed({"make-not-displayed": false});  // back to default
        divBib.select("path.pop1-arrow").classed({"make-hidden": false});     // hide the arrow pointing to the patent node
        divBib.select("circle.pop1-marker").classed({"ghost-marker": true});  // dashed outline for node circle
      }

      function on_mouseover_top_buttons_biblio(d, i) {
      // event handler attached to div.pop1-top-buttons, handling mouseover event on front, back, full/short buttons;
      // had a lot a trouble getting svg buttons to pop up all the time; found the solution at:
      // http://stackoverflow.com/questions/3485365/how-can-i-force-webkit-to-redraw-repaint-to-propagate-style-changes
      // when style changes, and re-draw is needed, apparently Chrome has some issues; need to force a redraw; can do
      // a couple ways - one shown below and the other is to simply access the .offsetHeight or other property which
      // forces the browser to check the visual layout and apparently update it in the process; problem occurs in event
      // handlers only
        // note the event needs to propagate so the handler for mouseenter on the div.pop1-container is also triggered.
//debug("Hello from on_mouseover_top_buttons_biblio");
        var divTop = d3.select(this);
        var patent_no = divTop.attr("data-patent");
        var divBib = d3.select("div.bib[data-patent=" + patent_no + "]");
        divBib.on("mousedown.drag", null);                        // remove drag handler from the div.bib
        // opacity: 0 makes the div and descendants not visible but still responding to mouse events;
        // visibility: hidden causes trouble because hidden HTML elements do not respond to mouse events;
        // hidden SVG elements can respond to mouse events, but behavior is fun when they are inside a div
        // with visibility: hidden.
        divTop.classed({"make-opaque": true});
//      using opacity instead of visibility makes the following trick unnecessary
//        divTop.classed({"make-not-displayed": true});           // force redraw - step 1 set display to none
//        // step 2 - force browser to check which element is on top; use .clientX, .clientY to work in FF and Chrome;
//        // (.x, .y works only in Chrome).
//        document.elementFromPoint(d3.event.clientX, d3.event.clientY);
//        divTop.classed({"make-not-displayed": false});          // step 3 - set display back to block
      }

      function on_mouseout_top_buttons_biblio(d, i) {
      // event handler attached to div.pop1-top-buttons, handling mouseover event on front, back, full/short buttons
//debug("Hello from on_mouseout_top_buttons_biblio");
        var divTop = d3.select(this);
        var patent_no = divTop.attr("data-patent");
        var divBib = d3.select("div.bib[data-patent=" + patent_no + "]");
        divBib.call(force_biblio_drag);                         // reattach drag handler to div.bib
        divTop.classed({"make-opaque": false});
      }

      function on_click_top_buttons_biblio(d, i) {
      // event handler is attached to the div.pop1-top-btns element; event target elements are
      // rect.pop1-full-btn, rect.pop1-close-btn, rect.pop1-front-btn, and rect.pop1-back-btn.
        d3.event.stopPropagation();
        d3.event.preventDefault();
        debug("Hello from on_click_top_buttons_biblio. Event is ", d3.event);
        var patent_no = d3.select(this).attr("data-patent");
        var clickedBtn = d3.select(d3.event.target);
        switch (true) {
          case clickedBtn.classed("pop1-full-btn"):                        // go to the full biblio
            var divPop = d3.select("div.pop1-container[data-patent=" + patent_no+"]");
            divPop.selectAll("div.pop1-inventors, div.pop1-abstract").classed({"make-displayed": true});
            d3.select(this).select("g.pop1-close").classed({"make-not-displayed": false});
            d3.select(this).select("g.pop1-full").classed({"make-not-displayed": true});
            break;
          case clickedBtn.classed("pop1-close-btn"):                       // go to the short biblio - undo changes above
            d3.select(this).select("g.pop1-full").classed({"make-not-displayed": false});
            d3.select(this).select("g.pop1-close").classed({"make-not-displayed": true});
            var divPop = d3.select("div.pop1-container[data-patent=" + patent_no+"]");
            divPop.selectAll("div.pop1-inventors, div.pop1-abstract").classed({"make-displayed": false});
            break;
          case clickedBtn.classed("pop1-front-btn"):
            pState.zMax += 1;
            d3.select(this).datum().z_index = pState.zMax;
            break;
          case clickedBtn.classed("pop1-back-btn"):
            pState.zMin -= 1;
            d3.select(this).datum().z_index = pState.zMin;
            break;
        }
      }

      function on_click_change_mouse_mode(d, i) {
      // called from the zoom rectangle (zoom_rect), biblio containers (div.pop1-container), and force plot container
      // (g.force-plot)
//debug("In on_click_change_mouse_mode, event and target are: ", d3.event, d3.event.target);
        // event.defaultPrevented is set true if the click event was from a drag (see d3js force.drag() documentation)
        if (d3.event.shiftKey && !d3.event.defaultPrevented) {
          d3.event.preventDefault();     // prevents Shift-click from opening new browser window from links in biblio!
          d3.event.stopPropagation();
          var divBib = d3.selectAll("div.bib");
          switch (pState.mouse) {
            case "normal":
              debug("Mouse mode changed from normal to transparent");
              setPlotState("transparent");
              setBiblioState(divBib);                              // called after setting pState.mouse = 'transparent'
              break;
            case "transparent":
              debug("Mouse mode changed from tranparent to normal");
              setPlotState("normal");
              setBiblioState(divBib);                              // called after setting pState.mouse = 'normal'
              if (topBiblio) {
                // need to simulate the mouse enter event on the top biblio because reenabling pointer-events when
                // mouse is already over a biblio does not trigger the mouseenter event.
                mouseenter_force_biblio(topBiblio.divBib);
              }
              break;
          }
        }
      }

      function setBiblioState(divBib) {
      // given a d3 selection of div.bib's, set the visibility of various features according to the mouse state
      // in pState.mouse ('normal' or 'transparent'); called from on_click_change_mouse_mode and updateForceMap
      // when new biblios are added to the force map.
        switch (pState.mouse) {                               // from normal to transparent
          case "transparent":
            // changing pointer-events on div.pop1-container propagates to children div.pop1-buttons, a.pop1-patent-url,
            // and a.pop1-search-url
            // setting pointer-events to none on div.pop1-container will always trigger the mouseleave event
            // when the mouse is over it; cannot prevent it by removing the mouseleave event handler in the
            // present event handler; note that if the mouse is on a pinned biblio, we do want to trigger the mouseleave
            // event so the link highlighting and the z-index get reset to their defaults
            divBib.select("g.pop1-marker").classed({"pointer-events-none": true});        // marker for bilibo
            divBib.select("div.pop1-container").classed({"pointer-events-none": true});   // triggers mouseleave over pinned biblio
            divBib.selectAll("rect.pop1-top-btn").classed({"pointer-events-none": true}); // all pop1-top-btns
            break;
          case "normal":                                 // from transparent to normal
            // changing pointer-events on div.pop1-container propagates to children div.pop1-buttons, a.pop1-patent-url,
            // and a.pop1-search-url
            divBib.select("div.pop1-container").classed({"pointer-events-none": false});    // will fire mouseenter event
            divBib.select("g.pop1-marker").classed({"pointer-events-none": false});         // marker for biblio
            divBib.selectAll("rect.pop1-top-btn").classed({"pointer-events-none": false});  // all pop1-top-btns
            break;
        }
      }      

      function on_mouseover_focus_main_svg(d, i) {
      // give document the focus when mouse moves over svg_main so the Shift-click behavior works the first time
//debug("Hello from on_mouseover_focus_main_svg");
        window.focus();
        $(document).click();
      }

      function on_keydown_document(d, i) {
      // detect if shift key is pressed
        if (!pState.shiftKey && d3.event.shiftKey) {                       // if this is the first keydown event
//debug("Hello from on_keydown_document");
          pState.shiftKey = true;
          allBiblioNodes.select("div.pop1-container").classed({"default-cursor": true});  // disable the 'move' cursor
          allBiblioNodes.selectAll("span.hide-result-btn").classed({"default-cursor": true});  // disable the 'pointer' cursor
          allBiblioNodes.selectAll("a.pop1-patent-url, a.pop1-search-url").classed({"default-cursor": true});
          allBiblioNodes.select("g.pop1-marker").classed({"default-cursor": true});
          allPatentNodes.select("circle").classed({"default-cursor": true});
        }
      }

      function on_keyup_document(d, i) {
      // detect if shift key is released
        if (d3.event.keyCode == 16) {                                      // the shift key
//debug("Hello from on_keyup_document");
          pState.shiftKey = false;
          allBiblioNodes.select("div.pop1-container").classed({"default-cursor": false});  // disable the 'move' cursor
          allBiblioNodes.selectAll("span.hide-result-btn").classed({"default-cursor": false});
          allBiblioNodes.selectAll("a.pop1-patent-url, a.pop1-search-url").classed({"default-cursor": false});
          allBiblioNodes.select("g.pop1-marker").classed({"default-cursor": false});
          allPatentNodes.select("circle").classed({"default-cursor": false});
        }
      }

      function on_mousedown_change_mouse_mode(d, i) {
      // needed for Shift-click behavior
//debug("Hello from on_mousedown_change_mouse_mode");
        if (d3.event.shiftKey && !d3.event.defaultPrevented) {
          d3.event.preventDefault();     // prevents Shift-click from opening new browser window from links in biblio!
          d3.event.stopImmediatePropagation();
        }
        else {
          // needed to prevent text selection during biblio drag in Firefox even with CSS -moz-user-select: none
          // added as fix to Firefox 4/8/2014; did not seem to break anything in Chrome.
          d3.event.preventDefault();
        }
      }

      function on_mouseup_change_mouse_mode(d, i) {
      // needed for Shift-click behavior
//debug("Hello from on_mouseup_change_mouse_mode");
        if (d3.event.shiftKey && !d3.event.defaultPrevented) {
          d3.event.preventDefault();     // prevents Shift-click from opening new browser window from links in biblio!
          d3.event.stopImmediatePropagation();
        }
      }

      function on_mousedown_no_drag(d, i) {
      // event handler attached to all links and buttons (map, fav, etc) within a biblio; do not let mousedown
      // initiate a drag event.
        d3.event.stopPropagation();
      }

      function addPopArrowCircleSVG(bibDiv) {
      // add svg for arrow and node circle at top of biblio
        var bibArrowCircle = bibDiv.append("svg:svg").classed({"pop1-arrow-circle": true})
                       .attr({"data-patent": function(d, i) {return d.patent_no;}});
        bibArrowCircle.append("svg:path").classed({"pop1-arrow": true})
                      .attr({"d": "M 0,0 L 0,8 8,0 z", "transform": "translate(12, 12) rotate(45)"});
        var bibMarker = bibArrowCircle.append("svg:g").classed({"pop1-marker": true})
                      .attr({"transform": "translate(12, 12)"});
        bibMarker.append("svg:rect").attr({"x": "-7px", "y": "0px", "width": "14px", "height": "9px"});
        bibMarker.append("svg:circle").classed({"pop1-marker": true})
                      .attr({"r": function(d, i) {return d.patentNode.markerRadius;},
                             "cx": "0px", "cy": "0px"});
      }

      function addPopTopBtns(bibDiv) {
      // add svg for the buttons at the top right of the biblio
        var svgTopBtn = bibDiv.select("div.pop1-top-btns").append("svg:svg")
                              .classed({"pop1-top-btns-svg": true})
                              .attr({"width": "62px", "height": "22px"});
        // buttons have overlapping boundaries; use clippaths to divide the borders between buttons down the
        // middle, so half of the border belongs to one button and half to the other.
        var gPop1Front = svgTopBtn.append("svg:g").classed({"pop1-front": true}).attr({"clip-path": "url(#leftBtn)"});
        gPop1Front.append("svg:title").text("Bring to front");
        gPop1Front.append("svg:rect").classed({"pop1-top-btn": true, "pop1-front-btn": true})
                  .attr({"x": "-10px", "y": "-10px", "rx": "7px", "ry": "7px", "width": "20px", "height": "20px"});
        gPop1Front.append("svg:rect").classed({"pop1-front-back-unfilled": true})
                  .attr({"x": "-5px", "y": "-5px", "width": "7px", "height": "7px"});
        gPop1Front.append("svg:rect").classed({"pop1-front-back-filled": true})
                  .attr({"x": "-2px", "y": "-2px", "width": "7px", "height": "7px"});
        // clip-path url's are in a <defs> section in the main svg element; for Firefox, there must be one unique
        // #id for each clipPath; Chrome uses the #id in the local svg block and applies in correctly to all
        // buttons; in Firefox, even if a #id is given in the local svg block, it will use the first #id found in
        // the entire document, which caused me much head-scratching before I figured it out.
        var gPop1Back = svgTopBtn.append("svg:g").classed({"pop1-back": true}).attr({"clip-path": "url(#midBtn)"});
        gPop1Back.append("svg:title").text("Send to back");
        gPop1Back.append("svg:rect").classed({"pop1-top-btn": true, "pop1-back-btn": true})
                  .attr({"x": "-10px", "y": "-10px", "rx": "7px", "ry": "7px", "width": "20px", "height": "20px"});
        gPop1Back.append("svg:rect").classed({"pop1-front-back-filled": true})
                  .attr({"x": "-5px", "y": "-5px", "width": "7px", "height": "7px"});
        gPop1Back.append("svg:rect").classed({"pop1-front-back-unfilled": true})
                  .attr({"x": "-3px", "y": "-3px", "width": "8px", "height": "8px"});
        var gPop1Full = svgTopBtn.append("svg:g").classed({"pop1-full": true}).attr({"clip-path": "url(#rightBtn)"});
        gPop1Full.append("svg:title").text("Full view");
        gPop1Full.append("svg:rect").classed({"pop1-top-btn": true, "pop1-full-btn": true})
                  .attr({"x": "-10px", "y": "-10px", "rx": "7px", "ry": "7px", "width": "20px", "height": "20px"});
        gPop1Full.append("svg:rect").classed({"pop1-full-rect": true})
                  .attr({"x": "-5px", "y": "-4px", "width": "10px", "height": "8px"});
        var gPop1Short = svgTopBtn.append("svg:g").classed({"pop1-close": true, "make-not-displayed": true})
                                  .attr({"clip-path": "url(#rightBtn)"});
        gPop1Short.append("svg:title").text("Popup view");
        gPop1Short.append("svg:rect").classed({"pop1-top-btn": true, "pop1-close-btn": true})
                  .attr({"x": "-10px", "y": "-10px", "rx": "7px", "ry": "7px", "width": "20px", "height": "20px"});
        gPop1Short.append("svg:line").classed({"pop1-close-x1": true})
                  .attr({"x1": "-8px", "y1": "0px", "x2": "8px", "y2": "0px"});
        gPop1Short.append("svg:line").classed({"pop1-close-x2": true})
                  .attr({"x1": "-8px", "y1": "0px", "x2": "8px", "y2": "0px"});
      }

      function createNodeLegend() {
      // use d3js to create the svg for the node legend at the upper right of the force map; nodeLegend is the
      // d3js containing 'g' element
        var gNodeLegend = nodeLegend.append("svg:g").classed({"node-legend": true})
                                    .attr({"transform": "translate(71,54)"});
        gNodeLegend.append("svg:line").classed({"node-legend-cited": true})
                   .attr({"x1": "0", "y1": "0", "x2": "-40", "y2": "0"});
        gNodeLegend.append("svg:line").classed({"node-legend-citing": true})
                   .attr({"x1": "0", "y1": "0", "x2": "20", "y2": "-35"});
        gNodeLegend.append("svg:line").classed({"node-legend-related": true})
                   .attr({"x1": "0", "y1": "0", "x2": "20", "y2": "35"});
        var gNodeLegendMap = gNodeLegend.append("svg:g").attr({"transform": "translate(0,0)"});
        gNodeLegendMap.append("svg:circle").classed({"node-legend-node": true})
                      .attr({"r": "10", "cx": "0", "cy": "0"});
        gNodeLegendMap.append("svg:use").attr({"xlink:href": "#force-mapped-cross-def"});
        var gNodeLegendMapText = gNodeLegendMap.append("svg:text").classed({"node-label": true})
                      .attr({"text-anchor": "middle", "x": "30", "y": "-8"})
                      .text("Mapped");
        gNodeLegendMapText.append("svg:tspan")
                          .attr({"text-anchor": "middle", "x": "30", "y": "4"})
                          .text("patent");
        var gNodeLegendCited = gNodeLegend.append("svg:g").attr({"transform": "translate(-40,0)"});
        gNodeLegendCited.append("svg:circle").classed({"node-legend-node": true})
                        .attr({"r": "7", "cx": "0", "cy": "0"});
        var gNodeLegendCitedText = gNodeLegendCited.append("svg:text").classed({"node-label": true})
                      .attr({"text-anchor": "middle", "x": "0", "y": "-20"})
                      .text("Cited patent");
        gNodeLegendCitedText.append("svg:tspan")
                          .attr({"text-anchor": "middle", "x": "0", "y": "-8"})
                          .text("(USPTO)");
        var gNodeLegendCiting = gNodeLegend.append("svg:g").attr({"transform": "translate(20,-35)"});
        gNodeLegendCiting.append("svg:circle").classed({"node-legend-node": true})
                        .attr({"r": "7", "cx": "0", "cy": "0"});
        var gNodeLegendCitingText = gNodeLegendCiting.append("svg:text").classed({"node-label": true})
                      .attr({"text-anchor": "middle", "x": "-31", "y": "-11"})
                      .text("Citing patent");
        gNodeLegendCitingText.append("svg:tspan")
                          .attr({"text-anchor": "middle", "x": "-31", "y": "1"})
                          .text("(USPTO)");
        var gNodeLegendRelated = gNodeLegend.append("svg:g").attr({"transform": "translate(20,35)"});
        gNodeLegendRelated.append("svg:circle").classed({"node-legend-node": true})
                        .attr({"r": "7", "cx": "0", "cy": "0"});
        var gNodeLegendRelatedText = gNodeLegendRelated.append("svg:text").classed({"node-label": true})
                      .attr({"text-anchor": "middle", "x": "-32", "y": "-10"})
                      .text("Related patent");
        gNodeLegendRelatedText.append("svg:tspan")
                          .attr({"text-anchor": "middle", "x": "-32", "y": "2"})
                          .text("(Google)");
        var bBox = nodeLegend.node().getBBox();                        // get bounding box of an SVG element
        nodeLegend.insert("svg:rect", ":first-child").classed({"legend-frame": true})
                       .attr({"x": "-4", "y": "-4", "width": bBox.width + 11, "height": bBox.height + 8});
      }

      var compiledMappedListEntryTemplate = _.template( $("script#mapped-list-entry-section").html());
      var compiledFavoritesListEntryTemplate = _.template( $("script#favorites-list-entry-section").html());
      var compiledPatentListBiblioTemplate = _.template( $("script#patent-list-patent-section").html());
      var compiledPatentListCitationsTemplate = _.template( $("script#patent-list-reference-section").html());
      var $mappedList = $("div.patent-list[data-listname='mapped']");         // global variables for the jQuery elements for the
      var $favoritesList = $("div.patent-list[data-listname='favorites']");   // Mapped and Favorites lists on the Mapped page

      function addTargetPatentToMappedSublist($sourceContainer, source_patent, target_patent, citation_type, undeleted) {
      // add the biblio info for target_patent to the list of referenced patents of type 'type' for source_patent in the
      // Mapped patent list; 'type' is 'cited', 'citing', or 'related'; $sourceContainer is the div.patent-list-patent-container
      // for the source patent in the Mapped patent list; 'undelete' is a boolean indicating whether target_patent was
      // deleted and then undeleted; called from addEPOPatentDataToForceMap and mapExistingTargetPatents
        // addTargetPatentToForceMap has already been called, so patent will only be in patentsPlotted if it was not
        // deleted previously
        var $citationSectionHeading = $sourceContainer.find("div.patent-list-" + citation_type + "-heading");
        if (target_patent in patentsPlotted) {
          incrementCitationCount($citationSectionHeading, "mapped", 1);
          if (undeleted) {
            incrementCitationCount($citationSectionHeading, "deleted", -1);
          }
          var $refsContainer = $sourceContainer.find("div.patent-list-" + citation_type +
                                                     "-patents div.patent-list-subpatent-container");
          var refBiblio = epoBiblio[target_patent];
          var refPatentHTML = compiledPatentListBiblioTemplate(
                              {"patent_no": target_patent, "patent_label": makePatentLabel(target_patent),
                               "source_patent": source_patent, "title": refBiblio["title"], "file_date": refBiblio["file_date"]});
          $refsContainer.append(refPatentHTML);
          var $refPatent = $refsContainer.find("div.patent-list-patent[data-patent='" + target_patent + "']");
          setupMapFavButtons($refPatent, document, "mapped-list", target_patent);
          setupDeleteButton($refPatent, target_patent);
          setupPatentLink($refPatent, "mapped-list");
          setupPatentHighlight($refPatent, target_patent, "mapped-list");
          setupPatentFullView($refPatent, target_patent, "mapped-list");
        }
        else {
          incrementCitationCount($citationSectionHeading, "deleted", 1);
        }
      }

      function addSourcePatentToMappedList(patent_no) {
      // create an entry for patent_no in the Mapped patents list on the Mapped page; uses global variables
      // $mappedList and patentBiblio; called from processSourcePatent.
        var patentObj = patentBiblio[patent_no];
        var patentEntryHTML = compiledMappedListEntryTemplate({"patent_no": patent_no});
        $mappedList.find("div.patent-list-patents").prepend(patentEntryHTML);                         // add at beginning of list
        var $patentEntry = $mappedList.find("div.patent-list-entry[data-patent='" + patent_no + "']");
        var $patentContainer = $patentEntry.find("div.patent-list-patent-container");
        var patentSectionHTML = compiledPatentListBiblioTemplate(
                                {"patent_no": patent_no, "patent_label": makePatentLabel(patent_no), "source_patent": patent_no,
                                 "title": patentObj["title"], "file_date": patentObj["file_date"]});
        $patentContainer.append(patentSectionHTML);
        nCited = patentObj["cited_patents"].length;
        nCiting = patentObj["citing_patents"].length;
        nRelated = patentObj["related_patents"].length;
        var citedSectionHTML = compiledPatentListCitationsTemplate(
               {"patent_no": patent_no, "citation_type": "cited", "citation_no": nCited, "citation_heading": "Cited patents"});
        var citingSectionHTML = compiledPatentListCitationsTemplate(
               {"patent_no": patent_no, "citation_type": "citing", "citation_no": nCiting, "citation_heading": "Citing patents"});
        var relatedSectionHTML = compiledPatentListCitationsTemplate(
               {"patent_no": patent_no, "citation_type": "related", "citation_no": nRelated,
                "citation_heading": "Related patents - Google"});
        $patentContainer.append(citedSectionHTML);
        $patentContainer.append(citingSectionHTML);
        $patentContainer.append(relatedSectionHTML);
        // add click handlers for dropdown/dropup arrows
        $patentEntry.find("div.patent-list-dropdown-arrow").on("click", on_click_patent_dropdown);
        $patentContainer.find("div.citation-list-dropdown-arrow").on("click", on_click_citation_dropdown);
        setupMapFavButtons($patentContainer, document, "mapped-list", patent_no);
        setupDeleteButton($patentContainer, patent_no);
        setupPatentLink($patentContainer, "mapped-list");
        setupPatentHighlight($patentContainer, patent_no, "mapped-list");
        setupPatentFullView($patentContainer, patent_no, "mapped-list");

        function on_click_patent_dropdown(event) {
        // when user clicks on the dropdown/dropup arrow for a patent entry in the Mapped list
          var $dropArrow = $(this);
          var $patentEntry = $dropArrow.closest("div.patent-list-entry");
          var $patentEntryContainer = $patentEntry.closest("div.patent-list-patents");
          var $refSections = $patentEntry.find("div.patent-list-references");
          if ($dropArrow.hasClass("patent-list-dropup-arrow")) {                // hide the dropdown content
            $dropArrow.removeClass("patent-list-dropup-arrow");
            $refSections.removeClass("make-displayed-flex");
            $patentEntryContainer.css("min-height", "0px");
          }
          else {                                                                // display the dropdown content
            $dropArrow.addClass("patent-list-dropup-arrow");
            $refSections.addClass("make-displayed-flex");
            $patentEntryContainer.css("min-height", "118px");
          }
        }

        function on_click_citation_dropdown(event) {
        // when user clicks on the dropdown/dropup arrow for a cited, citing, or related patent section of a patent
        // entry in the Mapped list
          var $dropArrow = $(this);
          var $refSection = $dropArrow.closest("div.patent-list-references");
          var $mainContainer = $refSection.closest("div.patent-list-patents");
          var mainContainerHeight = $mainContainer.css("height");       // e.g., "50px"
          var curMainHeight = parseInt(mainContainerHeight.slice(0, mainContainerHeight.length - 2));
          var patent_no = $refSection.attr("data-patent");
          var citation_type = $refSection.attr("data-citation-type");
          var $refsContainer = $refSection.find("div.patent-list-subpatent-container");
          if ($dropArrow.hasClass("citation-list-dropup-arrow")) {             // hide the dropdown content
            $dropArrow.removeClass("citation-list-dropup-arrow");
            $refsContainer.removeClass("make-displayed-flex");
            $refSection.css("height", "25px");
            $mainContainer.css("height", (curMainHeight - 47) + "px");
          }
          else {                                                                // display the dropdown content
            $dropArrow.addClass("citation-list-dropup-arrow");
            $refsContainer.addClass("make-displayed-flex");
            $refSection.css("height", "72px");
            $mainContainer.css("height", (curMainHeight + 47) + "px");
          }
        }
      }

      function incrementCitationCount($citationSectionHeading, count_type, increment) {
      // change the count of count_type 'mapped' or 'deleted' citations by increment for citations of type
      // citation_type under the $citationSectionHeading jQuery element (div.patent-list-'citation_type'-heading).
      // called from addTargetPatentToMappedSublist and deletePatentFromMappedSublists
        switch (count_type) {
          case "mapped":
            var $spanCount = $citationSectionHeading.find("span.patent-list-citation-mapped");
            break;
          case "deleted":
            var $spanCount = $citationSectionHeading.find("span.patent-list-citation-deleted");
            break;
        }
        var newCount = parseInt($spanCount.text()) + increment;
        $spanCount.text(newCount.toString());
      }

      function setupPatentFullView($patContext, patent_no, page_type) {
        $patContext.find("div.patent-list-fullview-button")
                   .on("mouseover", {patent_no: patent_no, page_type: page_type}, on_mouseover_fullview_button)
                   .on("mouseout", {patent_no: patent_no, page_type: page_type}, on_mouseout_fullview_button);
      }

      function on_mouseover_fullview_button(event) {
      // handler for mouseover event on the fullview button for a patent in the Mapped or Favorites List on the Map page      
        var $fullBtn = $(this);
        // to avoid multiple queries when multiple events are triggered in quick succession
        if ($fullBtn.attr("data-querying") == "true") return;
        var patent_no = event.data.patent_no;
        var patentObj = (patentBiblio[patent_no]) ?
                         patentBiblio[patent_no] : ((epoBiblio[patent_no]) ? epoBiblio[patent_no] : undefined);
        if (!patentObj) {                                         // occurs when patent is in the Favorites list
          var epoPatList = makeEPOQueryList([patent_no]);         // Google format to EPO format
          $fullBtn.attr("data-querying", "true");
          taskTracker.initialize("Fetching", undefined);
          taskTracker.startTask(1);
          getEPOPatentData(epoPatList, on_EPO_query_success);
        }
        else {
          setupFullView(patent_no, patentObj);
        }

        function on_EPO_query_success(data) {
          var processedList = parseEPOPatentData(data);
          taskTracker.finishTask(1);
          $fullBtn.attr("data-querying", "false");
          if (processedList) {
            var patentObj = epoBiblio[patent_no];
            if (patentObj) {
              debug("In on_mouseover_fullview_button, got EPO API for patent " + patent_no);
              setupFullView(patent_no, patentObj);
            }
            else {
              debug("In on_mouseover_fullview_button, no data in epoBiblio for patent " + patent_no);
            }
          }
          else {
            debug("In on_mouseover_fullview_button, failed to get EPO data for patent " + patent_no);
          }
        }

        function setupFullView(patent_no, patentObj) {
          var pop1HTML = compiledPop1Template({patent_no: patent_no, patent_label: makePatentLabel(patent_no),
                                 file_date: patentObj.file_date, pub_date: patentObj.pub_date, title: patentObj.title,
                                 inventors: patentObj.inventors, assignee: patentObj.assignee, abstract: patentObj.abstract});
          var divFullView = $fullBtn.find("div.patent-list-fullview-container").html(pop1HTML);
          var divFVPos = divFullView.offset();
          var divPop = divFullView.find("div.pop1-container").addClass("pop1-in-patent-list");
          divPop.css("top", (divFVPos.top - 3) + "px").css("left", (divFVPos.left - pList.w - 12) + "px");
          divPop.find("div.pop1-top-capture").remove();
          divPop.find("div.pop1-buttons").remove();
          divPop.find("div.pop1-top-btns").remove();
          divPop.find("div.pop1-inventors").addClass("make-displayed");
          divPop.find("div.pop1-abstract").addClass("make-displayed");
        }
      }

      function on_mouseout_fullview_button(event) {
        var patent_no = event.data.patent_no;
        $(this).find("div.pop1-container").remove();
      }

      function setupPatentHighlight($patentContainer, patent_no, page_type) {
      // setup mouseover and mouseout event handlers for patent biblio in the Mapped or Favorites Lists on the Map page
        if ($patentContainer.hasClass("patent-list-patent")) {        // called from addTargetPatentToMappedSublist
          $patentContainer.on("mouseover", {patent_no: patent_no, page_type: page_type}, on_mouseover_patent_list_patent)
                          .on("mouseout", {patent_no: patent_no, page_type: page_type}, on_mouseout_patent_list_patent);
        }
        else {                             // called from addSourcePatentToMappedList and addFavoritePatentToFavoritesList
          $patentContainer.find("div.patent-list-patent")
                          .on("mouseover", {patent_no: patent_no, page_type: page_type}, on_mouseover_patent_list_patent)
                          .on("mouseout", {patent_no: patent_no, page_type: page_type}, on_mouseout_patent_list_patent);
        }
      }

      function on_mouseover_patent_list_patent(event) {
      // handler for mouseover on a biblio in the Mapped or Favorites Lists on the Map page; highlight the patent and links on the
      // force map that the mouse is over in the list
        var patent_no = event.data.patent_no;
        var page_type = event.data.page_type;                         // 'mapped-list' or 'favorites-list'
        if (patentsPlotted[patent_no]) {                              // if patent is mapped (might not be if on Favorites list)
          highlightLinks(patent_no);
          var marker = d3.select("g.force-patent-marker[data-patent=" + patent_no + "]");
          updateMarkerOnForceMap(marker, page_type);        
        }
      }

      function on_mouseout_patent_list_patent(event) {
      // handler for mouseout on a biblio in the Mapped or Favorites Lists on the Map page;
      // unhighlight the patent and links on the force map that the mouse was over in the list
        var patent_no = event.data.patent_no;
        mouseout_patent_list_patent(patent_no);
      }

      function mouseout_patent_list_patent(patent_no) {
      // called from on_mouseout_patent_list_patent event handler and special cases in removePatentFromFavorites
      // and removePatentFromMapped
        if (patentsPlotted[patent_no]) {                              // if patent is mapped (might not be if on Favorites list)
          unhighlightLinks(patent_no);
          var marker = d3.select("g.force-patent-marker[data-patent=" + patent_no + "]");
          updateMarkerOnForceMap(marker, "map");
        }
      }

      function setupPatentLink($linkContext, page_type) {
      // called from addSourcePatentToMappedList, addTargetPatentToMappedList, and addFavoritePatentToFavoritesList
      // set up event handler for click on a patent link in the list; $linkcontext is the jQuery element that
      // contains the link for patent_no.
        $("a.pop1-patent-url", $linkContext).on("click", {$context: $linkContext, page: page_type}, on_click_new_patent_url);
      }

      function setupDeleteButton($btnContext, patent_no) {
      // called from addSourcePatentToMappedList, addTargetPatentToMappedList, and addFavoritePatentToFavoritesList;
      // set up event handler for click on the 'Delete' button for patent patent_no in the list; $btnContext is the
      // jQuery element that contains the 'Delete' button span element for patent patent_no.
        var $deleteBtn = $btnContext.find("span.btn-hide-add");
        if ((patent_no in patentsPlotted)) {                // if patent_no is mapped (as either a source or target patent)
          $deleteBtn.on("click", {patent_no: patent_no}, on_click_delete_btn$);  // add click event handler to 'Delete' button
        }
        else {                                              // do not display the 'Delete' button if patent no is not on the map
          $deleteBtn.addClass("make-not-displayed");
        }
      }

      function on_click_delete_btn$(event) {
      // for click event handler attached to Mapped or Favorites list 'Delete' buttons using jQuery;
      // like on_click_delete_btn attached to force map biblios using d3.
        $(this).addClass("make-not-displayed");
        deletePatentFromMap(event.data.patent_no, "single", on_delete_complete);

        function on_delete_complete() {
          setUndoButtonState();     // set Undo button state based on whether deleted list has any patents in it
          setClearButtonState();    // will set Clear button state based on whether patentsPlotted still has any patents in it
        }
      }

      function on_keydown_input_patent(event) {
      // handler for keydown and paste events in the text input box above the force map on the Map page
        event.stopImmediatePropagation();                  // needed to stop keydown event from often firing twice!!
        patentPicker.clearError();
        if (event.keyCode == 13) {                         // Enter key
          $(this).off("keydown");                          // do not respond if use holds the key down
          on_click_go_btn(event);
        }
      }


      function on_keyup_input_patent(event) {
      // handler for keyup event in the text input box above the force map on the Map page
        event.stopImmediatePropagation();
        if (event.keyCode == 13) {                         // Enter key
          $(this).on("keydown", on_keydown_input_patent);  // re-attach event handler
        }
      }

      function on_click_go_btn(event) {
      // handler for click event on the Go button above the force map on the Map page; also called from on_keydown_input_patent
      // (handler when user presses the Enter key in the patent number input box)
        $("input.input-patent").on("keydown", on_keydown_input_patent);  // re-attach event handler
        var enteredText = $("input.input-patent").val();
        debug("In on-click_go_btn, input text is " + enteredText);
        setGoButtonState(true);                                  // disable button and click handler while mapping random patent
        patentPicker.validatePatent(enteredText, on_patent_validated);

        function on_patent_validated(validResp) {
        // callback for patentPicker.validatePatent; if enteredText is a valid patent, validResp is an object containing
        // a valid Google url for the patent (with kind code) and the label (without the kind code) for labeling
        // the patent tab; if enteredText has an invalid format or is not in Google's database, validResp contains an
        // error message.
          if (validResp.url) {
            patentPicker.getPatent(validResp.url, validResp.label, on_patent_data_complete);
          }
          else {
            patentPicker.showError(validResp.error);
            setGoButtonState(false);                             // re-enable button and click handler
          }
        }

        function on_patent_data_complete(patentLabel) {
        // callback for patentPicker.getPatent
          window.setTimeout(delayClick.bind(undefined, patentLabel), 1000);

          function delayClick() {
            var patentLabel = arguments[0];
            var $aTab = $("a[data-tabname='" + patentLabel + "']");
            $aTab.click();
            setGoButtonState(false);                                    // re-enable button
          }
        }

        function setGoButtonState(state) {
        // set appearance of the 'Go' button at the top of the force map.
          var $btn = $("span.btn-go");
          if (state) {
            $btn.addClass("disabled");
          }
          else {
            $btn.removeClass("disabled");
          }
        }
      }

      function on_click_random_btn(event) {
        setRandomButtonState(true);                                    // disable button while random patent is mapped
        randomPatentPicker.mapRandomPatent(on_random_patent_complete); // on_random_patent_complete is the callback

        function on_random_patent_complete(patentLabel) {
          window.setTimeout(delayClick.bind(undefined, patentLabel), 1000);

          function delayClick() {
            var patentLabel = arguments[0];
            var $aTab = $("a[data-tabname='" + patentLabel + "']");
            $aTab.click();
            setRandomButtonState(false);                                 // re-enable button when done mapping
          }
        }

        function setRandomButtonState(state) {
        // set appearance of the 'Random' button at the top of the force map.
            $("button.btn-random").prop('disabled', state);
        }
      }

      function on_click_fun_btn(event) {
        setFunButtonState(true);                                    // disable button while fun patent is mapped
        var randIndex = Math.floor(funPatents.length*Math.random());
        var patent_label = funPatents[randIndex];
        var patent_url = "/patents/" + patent_label;

        checkGooglePatent(patent_url, on_check_patent_complete);

        function on_check_patent_complete(respObject) {
        // checkGooglePatent returns an object with properties 'data' and 'textStatus' for a valid Google patent_url or
        // 'error' and 'textStatus' for an invalid Google patent_url.
          if (!respObject.error) {
            patentPicker.getPatent(patent_url, patent_label, on_fun_patent_complete);
          }
          else {
            debug("In on_click_fun_button, patent " + patent_label + " was not found on Google patents");
            setFunButtonState(false);
          }
        }

        function on_fun_patent_complete(patentLabel) {
        // callback for patentPicker.getPatent
          window.setTimeout(delayClick.bind(undefined, patentLabel), 1000);

          function delayClick() {
            var patentLabel = arguments[0];
            var $aTab = $("a[data-tabname='" + patentLabel + "']");
            $aTab.click();
            setFunButtonState(false);                                 // re-enable button
          }
        }

        function setFunButtonState(state) {
        // set appearance of the 'Fun' button at the top of the force map.
            $("button.btn-fun").prop('disabled', state);
        }
      }

      function on_click_undo_delete_btn(event) {
      // click event handler for the 'Undo' button on the Map page
        if (patentLists["clearFlag"]) {
          undoClear(on_undelete_complete);
        }
        else {
          var patent_no = patentLists["deleted"].slice(-1)[0];         // take last entry in the deleted list
          undeletePatent(patent_no, "single", "undo_delete", on_undelete_complete);
        }

        function on_undelete_complete() {
          setUndoButtonState();                            // set state based on whether deleted list contains any patents
          // last action is to enable the Clear button, but set the state based on whether patentsPlotted has any patents
          setClearButtonState();
        }
      }

      function undeletePatent(patent_no, deletionType, context, on_undelete_complete) {
      // undelete deleted patent patent_no; call the callback function on_undelete_complete when done; 'context' is the
      // context in which the function is called ('undo_delete' or 'undo_clear'); called from
      // on_click_undo_delete_btn, and restoreClearedPatents
        var patentNode = patentsHistory[patent_no];
        if (patentNode.source) {
          addSourcePatentToForceMap(patent_no, "map", context);   // also maintains deleted list
          addSourcePatentToMappedList(patent_no);                 // re-create entry in Mapped list on the Map page
          // undelete the reference patents associated with patent_no;
          mapExistingTargetPatents(patent_no, on_map_complete);   // on_map_complete is the callback
        }
        else {
          addTargetPatentToForceMap("", patent_no, "", context);    // recreate patent_no and all links to it on force map
          on_map_complete();
        }

        function on_map_complete() {
        // complete task of undeleting a patent called from undeletePatent when undeleting a target patent or
        // mapExistingTargetPatents after timeout when undeleting a source patent
          updateMapFavButtons(patent_no);
          remakeDeletedCitationListEntries(patent_no, patentNode);
          switch (deletionType) {
            case "single":
              updateForceMap();
              break;
            case "group":
              break;            // functions specifying 'group' undeletes are responsible for calling updateForceMap themselves
          }
          if (patent_no in patentLists["favorites"]) {     // show delete button in Favorites list entry
            var $patentContainer = $favoritesList
                                 .find("div.patent-list-entry[data-patent='" + patent_no + "'] div.patent-list-patent-container");
            setupDeleteButton($patentContainer, patent_no);
          }
          if (on_undelete_complete) {                      // call the callback if it was passed
            on_undelete_complete();
          }
        }

        function updateMapFavButtons(patent_no) {
        // need to set state of Map and Favorite buttons on patent, search, and related tabs; button state for biblios on the
        // force map are set when updateForceMap is called; button state in the Mapped and Favorites lists on the Map page are
        // set when patent_no is added to the list
          if (patentLists["map"].indexOf(patent_no) != -1) {
            toggleButton(patent_no, "btn-map-add", "add");
          }
          if (patentLists["favorites"].indexOf(patent_no) != -1) {
            toggleButton(patent_no, "btn-favorite-add", "add");
          }
        }
      }


      function mapExistingTargetPatents(source_patent, on_map_complete) {
      // plot reference patents for which epoBiblio data has already been queried and processed
        var sourceNode = patentsPlotted[source_patent];       // source_patent must already be plotted on the force map
        var $sourceContainer = $mappedList       // get appropriate jQuery element for source_patent in Mapped patent list
                       .find("div.patent-list-entry[data-patent='" + source_patent + "'] div.patent-list-patent-container");
        var linksList = sourceNode.targetPatentLinksList;
        var nL = 40;                                          // replot nL links and associated patents at a time
        var groupList = createGroupList(linksList, nL);       // break into list of subgroups of indices in linksList
        // plot target patents one group at a time, so map updates when undeleting a source patent with lots of references
        if (groupList.length > 0) {
          var iL = 0;
          taskTracker.initialize("Fetching", undefined);
          taskTracker.startTask(groupList.length);
          plotTargetGroup();
        }
        else {
          on_existing_map_complete();
        }

        function plotTargetGroup() {
        // plot the iL'th group of links and associated patents in linksList
          if (arguments.length > 0) {                         // was called recursively after timeout in this function
            taskTracker.finishTask(arguments[0]);
          }
          var targetPatentsList = [];
          var index = groupList[iL];
          // map in the same order that links were originally mapped
          for (var jL = index.start; jL < index.end; jL++) {
            var link = linksList[jL];                           // to help preserve legend colors
            var linkToTargetPatent = sourceNode.targetPatentLinks[link];
            var target_patent = linkToTargetPatent.target.patent_no;
            var type = linkToTargetPatent.type;
            addTargetPatentToForceMap(source_patent, target_patent, type, "new");
            addTargetPatentToMappedSublist($sourceContainer, source_patent, target_patent, type, false);
            targetPatentsList.push(target_patent);
          }
          updateForceMap();
          debug("In mapExistingTargetPatents, for source patent " + source_patent + ", already have EPO data for "
                    + targetPatentsList.length + " reference patents: ", targetPatentsList);
          iL++;
          if (iL < groupList.length) {
            // call plotTargetGroup again after allowing 1 task to finish
            window.setTimeout(plotTargetGroup.bind(undefined, 1), 500);
          }
          else {
            window.setTimeout(afterFinalGroupPlotted, 500);    // after final group plotted
          }
        }

        function afterFinalGroupPlotted() {
          taskTracker.finishTask(1);
          on_existing_map_complete();
        }

        function on_existing_map_complete() {
          if (on_map_complete) {
            on_map_complete();                                 // call the callback function
          }
        }
      }

      function remakeDeletedCitationListEntries(patent_no, patentNode) {
      // create reference sublist entries in the Mapped patent list for patent_no under all source patents it is linked
      // to that are on the Mapped list; called from on_click_undo_delete and addFavorite patent
        for (link in patentNode.sourcePatentLinks) {
          var linkToSourcePatent = patentNode.sourcePatentLinks[link];
          var source_patent = linkToSourcePatent.source.patent_no;
          if (patentLists["map"].indexOf(source_patent) != -1) {         // if source_patent is currently mapped
            var type = linkToSourcePatent.type;
            var $sourceContainer = $mappedList     // get appropriate jQuery element for source_patent in Mapped patent list
                       .find("div.patent-list-entry[data-patent='" + source_patent + "'] div.patent-list-patent-container");
            addTargetPatentToMappedSublist($sourceContainer, source_patent, patent_no, type, true);
          }
        }
      }

      function addPatentToDeletedList(patent_no) {
      // add patent_no to deleted list and update CSS for the undo button
        patentLists["deleted"].push(patent_no);
      }

      function removePatentFromDeletedList(patent_no) {
      // test if patent_no is in the deleted list and if so remove it.
        var index = patentLists["deleted"].indexOf(patent_no);
        if (index != -1) {
          patentLists["deleted"].splice(index, 1);   // remove from the deleted list
        }
      }

      function setUndoButtonState(state) {
      // set appearance of the 'Undo' button at the top of the force map; if state is provided, set the button to
      // that state; if not, set the state based on whether deleted list contains any patents; called from
      // on_click_delete_btn$, on_click_delete_btn, on_click_clear_btn, and undoClear
        if (arguments.length > 0) {
          $("button.btn-undo").prop('disabled', state);
        }
        else {
          if (patentLists["deleted"].length == 0) {
            $("button.btn-undo").prop('disabled', true);
          }
          else {
            $("button.btn-undo").prop('disabled', false);
          }
        }
      }

      function setClearButtonState(state) {
      // set appearance of the 'Clear' button at the top of the force map; if state is provided, set the button to
      // that state; if not, set the state based on whether patentsPlotted contains any patentNodes; called from
      // mapNewTargetPatents, on_click_clear_btn, and undoClear.
        if (arguments.length > 0) {
          $("button.btn-clear").prop('disabled', state);
        }
        else {
          if (_.isEmpty(patentsPlotted)) {
            $("button.btn-clear").prop('disabled', true);
          }
          else {
            $("button.btn-clear").prop('disabled', false);
          }
        }
      }

      function initializeClearedLists() {
      // empty out the patent lists that support clear and undoing clear; called from on_click_map_buttons and
      // undoClear.
        var cleared = patentLists["cleared"];
        cleared["map"] = [];
        cleared["target"] = [];
        cleared["deleted"] = [];
        patentLists["clearFlag"] = false;
      }

      function initializeDeletedList() {
      // called from on_click_map_buttons and on_click_clear_btn.
        patentLists["deleted"] = [];                                    // remove 'Clear' from deleted list; it is now empty
      }

      function preserveClearedLists() {
      // preserve legend and deleted lists needed to undo a Clear command; called from on_click_clear_btn.
        var cleared = patentLists["cleared"];
        cleared["deleted"] = patentLists["deleted"].slice();            // save deleted list in case we need to Undo the Clear
        cleared["map"] = patentLists["map"].slice();                    // clone the mapped patent list
      }

      function on_click_clear_btn(event) {
      // event handler for the 'Click' button at the top of the force map
        setClearButtonState(true);                     // first action is to disable the Clear button, so user cannot click it twice
        preserveClearedLists();                        // preserve some history in case user undoes the Clear;
        var mapPatentList = patentLists["cleared"]["map"];
        // delete mapped patents one at a time in reverse order; the deletePatentFromMap function takes care of
        // calling updateForceMap when 'single' mapped patents and associated target patents are deleted
        var iP = mapPatentList.length;
        deleteMappedPatent();

        function deleteMappedPatent() {
          if (iP > 0) {
            iP--;
            var patent_no = mapPatentList[iP];
            deletePatentFromMap(patent_no, "single", deleteMappedPatent);    // deleteMappedPatent is the callback
          }
          else {
            deleteRemainingTargetPatents();
          }
        }

        function deleteRemainingTargetPatents() {
        // delete any remaining target patents whose source patent(s) were not plotted 
          for (patent_no in patentsPlotted) {
            deletePatentFromMap(patent_no, "group", undefined);
            patentLists["cleared"]["target"].unshift(patent_no);        // add to beginning of list to help preserve legend colors
          }
          // need to call updateForceMap since remaining target patents were deleted as a 'group'.
          updateForceMap();
          // the deleted list contains the patents that were just deleted; we need a new list now
          initializeDeletedList();
          patentLists["clearFlag"] = true;
          setUndoButtonState(false);                                     // set Undo button state enabled so can undo the Clear
        }
      }

      function undoClear(on_undo_clear_complete) {
      // undo a Clear command; called from on_click_undo_delete_btn; call on_undo_clear_complete when done.
        setUndoButtonState(true);                // immediately disable the Undo button (might be re-enabled later)
        // bring back the list of deleted patents when Clear was clicked so do not re-plot them
        restoreClearedLists();
        patentMapPlot.initialize();              // we will disregard any zooming that was done before the Clear
        restoreClearedPatents(on_restore_complete);

        function on_restore_complete() {
          initializeClearedLists();
          on_undo_clear_complete();
        }
      }

      function restoreClearedLists() {
      // restore deleted lists to previous saved state; called from undoClear.
        patentLists["deleted"] = patentLists["cleared"]["deleted"];
      }

      function restoreClearedPatents(on_restore_complete) {
      // remap the patents that were deleted when the 'Clear' button was originally clicked; called from undoClear;
      // on_restore_complete is the callback called when function is finished
        var mapPatentList = patentLists["cleared"]["map"];
        var targetPatentList = patentLists["cleared"]["target"];
        // undelete formerly mapped patents and isolated target patents in reverse order that they were Cleared
        restoreTargetPatents();

        function restoreTargetPatents() {
        // undelete any isolated target patents in reverse order that they were Cleared
          var nP = targetPatentList.length;                           // as each patent was undeleted, it was removed from the list
          if (nP > 0) {
            var patent_no = targetPatentList[0];                        // always take the first entry
            undeletePatent(patent_no, "group", "undo_clear", restoreTargetPatents);      // restoreTargetPatents is the callback
          }
          else {
            // for 'group' undeletes, undeletePatent does not call updateForceMap; we need to call it here
            updateForceMap();
            restoreMappedPatents();
          }
        }

        function restoreMappedPatents() {
        // undelete mapped patents in the order they were originally plotted to try to preserve the original legend colors.
        // undelete the patent at index 0 in mapPatentList; waits for undeleting of each mapped patent and associated
        // target patents to be completed before recursively calling itself on the next mapped patent
          var nP = mapPatentList.length;                            // as each patent was undeleted, it was removed from the list
          if (nP > 0) {
            var patent_no = mapPatentList[0];                       // always take the first entry
            if (nP > 1) {
              // for 'single' undeletes, undeletePatent takes care of calling updateForceMap
              undeletePatent(patent_no, "single", "undo_clear", restoreMappedPatents);    // restoreMappedPatent is the callback
            }
            else {                                                          // last patent in the list
              undeletePatent(patent_no, "single", "undo_clear", on_restore_complete);     // on_restore_complete is the callback
            }
          }
          else {
            on_restore_complete();
          }
        }
      }

      function randomizeArray(array) {
      // randomize array using the javascript .sort with a random sort function; .sort sorts in place
        array.sort(function() {return (0.5 - Math.random());});
      }

      function divMouseDown(event) {
      // prevent the blue outline from appearing on a clicked div button; attached to div#right-toolbar-buttons on
      // Google Patent page and to bootstrap buttons at the top of the Map page
        event.preventDefault();
//          event.stopPropagation();
      }

    </script>
  </body>
</html>
