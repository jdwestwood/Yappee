<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Patent visualization</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen">
    <script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/md5.js"></script>
    <script src="http://code.jquery.com/jquery.js"></script>
    <script src="/js/bootstrap.min.js"></script>
    <script src="/js/underscore.js"></script>
    <script src="/js/moment.min.js"></script>
    <script src="/js/d3.v3.min.js" charset="utf-8"></script>
<!--  <script src="/js/innersvg.js" charset="utf-8"></script> to be able to set '.innerHTML' (or '.innerSVG') on SVG elements -->
    <link rel="stylesheet" href="/css/jdwmainpage.css">
  </head>

  <body>
    <ul class="nav nav-tabs" id="topTabs">
      <li class="active">
	<a id="patMap" href="#Map" data-toggle="tab">Map</a>
      </li>
      <li>
	<a id="gAdvSearchForm" href="#Search" data-toggle="tab">Search</a>
      </li>
    </ul>

    <div class="tab-content" id="topTabsContent">
      <div class="tab-pane active" id="Map">
        <div class="top-content">
          <div class="top-force-container">
            <div class="top-force-left">
              <div>Top Content</div>
              <div class="input-group patent-input">
                <span class="input-group-addon">Map:</span>
                <div>
                  <input type="text" class="form-control input-patent" placeholder="Patent/App. number" spellcheck="false">
                  <div class="patent-input-error"></div>
                </div>
                <span class="input-group-addon btn-go">Go!</span>
              </div>
              <div class="btn-group btn-group-left">
                <button type="button" class="btn btn-default btn-random">Random</button>
                <button type="button" class="btn btn-default btn-weird">Weird</button>
              </div>
            </div>
            <div class="top-force-right">
              <div class="btn-group btn-group-right">
                <button type="button" class="btn btn-default btn-undo" disabled="true">Undo</button>
                <button type="button" class="btn btn-default btn-clear" disabled="true">Clear</button>
              </div>
            </div>
          </div>
          <div class="top-patent-lists">
          </div>
        </div>
        <div class="main-content">
          <div class="force-container">
            <div class="status-line"><span class="status-line-type">Fetching </span>patents <span class="status-line-queries">0/5</span> tasks done</div>
            <div class="mouse-mode-line" title="Shift-click on plot to change modes">
              <span class="mouse-mode-state">Normal</span> mode</div>
            <div class="bib-container">
            </div>
            <svg class="main-svg">
              <defs>
                <!-- svg for the mapped patent cross graphic for a node on the forcePatent map -->
                <g id="force-mapped-cross-def" clip-path="url(#nodeClip)">
                  <rect class="force-mapped-cross" width="20" height="5" transform="translate(-10,-2.5)"></rect>
                  <rect class="force-mapped-cross" width="5" height="20" transform="translate(-2.5,-10)"></rect>
                </g>
    
                <!-- svg for the favorite patent symbol for a node on the forcePatent map -->
                <g id="force-favorite-heart-def" transform="translate(0,8)">
                  <g class="force-favorite-heart" transform="rotate(-135)">
                    <rect height="8" width="10" transform="translate(0,0)"></rect>
                    <circle r="4" transform="translate(10,4)"></circle>
                  </g>
                  <g class="force-favorite-heart" transform="rotate(-45)">
                    <rect height="8" width="10" transform="translate(0,-8)"></rect>
                    <circle r="4" transform="translate(10,-4)"></circle>
                  </g>
                </g>
              </defs
            </svg>
          </div>

      <script type="text/javascript" charset="utf-8">

      // iframe heights for search and related result pages
      // physical screen height - (browser window real estate) - top tabs height - allowance for scroll bar.
      var srchIFrameHeight = Math.min(window.screen.height, 1024) - (window.outerHeight - window.innerHeight) - 
                             $("ul#topTabs").outerHeight() - 30;

      // forcePatent and forceBiblio map calculation space (somewhat arbitrary)
      var fMap = {
        "w": 1000,
        "h": 550,
        "minDate": new Date("01-01-1976"),
        "maxDate": new Date("01-01-2014"),
        "alpha": 0.1
      };

      // div.force-container parameters; if css for div.force-container changes, these parameters must be updated manually
      var fCont = {
        "padding" : {"top": 0, "bottom": 0, "left": 0, "right": 0},
        "border" : {"top": 14, "bottom": 14, "left": 14, "right": 14},
        "margin" : {"top": 0, "bottom": 0, "left": 2, "right": 2}
      }
      fCont.totH = fCont.padding.left + fCont.padding.right + fCont.border.right + fCont.border.left
                           + fCont.margin.left + fCont.margin.right;
      fCont.totV = fCont.padding.top + fCont.padding.bottom + fCont.border.top + fCont.border.bottom
                           + fCont.margin.top + fCont.margin.bottom;

      // div.patent-list parameters; if css for div.patent-list changes, these parameters must be updated manually
      var pList = {
        "w" : 350,                                         // width is 350 px
        "padding" : {"top": 0, "bottom": 0, "left": 0, "right": 0},
        "border" : {"top": 2, "bottom": 2, "left": 2, "right": 2},
        "margin" : {"top": 0, "bottom": 5, "left": 0, "right": 0}
      }
      pList.totW = pList.w + pList.padding.left + pList.padding.right + pList.border.right + pList.border.left
                           + pList.margin.left + pList.margin.right;

      // svg.main-svg parameters
      var svgP = {
        // physical screen width - (browser window real estate) - total width of patent lists - force container horizontal
        // boundary overhead - allowance for scroll bar.
        "w" : Math.min(window.screen.width, 1280) - (window.outerWidth - window.innerWidth) - pList.totW -
                       fCont.totH - 25,                                                                     // was 960

        // physical screen height - (browser window real estate) - div.main-content offset relative to document -
        // force container vertical boundary overhead - allowance for scroll bar.
        "h" : Math.min(window.screen.height, 1024) - (window.outerHeight - window.innerHeight) - 
                       $("div.main-content").offset().top - fCont.totV - 30,                                // was 600
        // need large margins to accomodate mouse dragging of nodes behind biblio divs
        "margin" : {"top": 18, "bottom" : 35, "left": 18, "right": 18},
        "nodeLegend": {
               "w": 120 + 8,                               // 120px for the legend and 8 px for the bounding box
               "h": 100,
               "margin": {"top": 10, "bottom" : 10, "left": 10, "right": 5}
        }
      };

      // div.top-force-container parameters; same width as div.force-container width + padding + borders
      var topfCont = {
        "w" : svgP.w + fCont.border.left + fCont.border.right + fCont.padding.left + fCont.padding.right
      }
      $("div.top-force-container").css("width", topfCont.w + "px");

      var plotWidth = svgP.w - svgP.margin.left - svgP.margin.right;
      var plotHeight = svgP.h - svgP.margin.top - svgP.margin.bottom;

      var bibConP = {                                      // set width, height of div.bib-container
        "w": plotWidth + 1,
        "h": plotHeight + 1
      };

      // plotting and map display parameters
      var pParam = {
        "minDate": undefined,                              // min, max based on patent data
        "maxDate": undefined,
        "minX": undefined,                                 // min, max of the x (filing date) axis
        "maxX": undefined,
        "minY": 0,
        "maxY": fMap.h,
        "scale": 1,
        "panTransY": 0,                    // need to track the panning and zooming contributions to the y translation reported
        "zoomTransY": 0,                                   // by d3 zoom.translation()
        "zMin": 0,                                         // for tracking the css z-index of biblios
        "zMax": 0,
        "mouse" : "normal",                                // mouse events on biblios behave "normal" or "transparent"
        "shiftKey": false,                                 // tracks whether shift key is pressed
        "transformTime": 0.7,                              // CSS transition parameters when biblios are unpinned
        "opacityTime": 0.3,
        "transition": 0                                    // number of biblios that are transitioning after being unpinned
      };

      // create div container element for the short biblio popovers; overlays the forcePatent map svg content;
      // need to add 1px to plotWidth and plotHeight so the bib-container completely masks the force plot at the
      // right and bottom edges if pointer-events are enabled on the bib-container to block mouse events
      // from reaching the force map.
      var bib = d3.select("#Map").select("div.bib-container")
                  .style({"width": bibConP.w + "px", "height": bibConP.h + "px",
                          "margin-top": svgP.margin.top + "px", "margin-bottom": svgP.margin.bottom + "px",
                          "margin-left": svgP.margin.left + "px", "margin-right": svgP.margin.right + "px"});

      // create the main svg element and attach mouse event handlers that will control when biblio pop-ups disappear
      // and allow mouse events to go through biblio pop-ups
      var svg_main = d3.select("#Map").select("svg.main-svg").attr({"width": svgP.w, "height": svgP.h});

      // create g container element to contain the graphics; note var svg is actually the g element child of the
      // svg document element; appends to svg will be children of the g element
      var svg = svg_main.append("svg:g").attr("transform", "translate(" + svgP.margin.left + "," + svgP.margin.top + ")")

      // create a clipping region for the force map; does not actually clip anything until it is applied to a particular
      // graphics element via the clip-path attribute; apply to plot data, but not to axes
      svg.append("svg:clipPath").attr({"id": "clip"})
                                .append("svg:rect").attr({"width": plotWidth, "height": plotHeight});

      // create a clipping region for the mapped patent markers. (Append it here to avoid multiple copies for each marker)
      svg.append("svg:clipPath").attr({"id": "nodeClip"})
                                .append("svg:circle").attr({"id": "nodeMarker", "r": 7.5});

      // define the x-axis scale for the force map: domain is patent filing date; range is force map coordinates
      var xForceScale = d3.time.scale().domain([fMap.minDate, fMap.maxDate]).range([0, fMap.w]);
      // define the x- and y-axis scales for plotting: domain is patent filing date; range is pixel coordinates for plotting
      var xPlotScale = d3.time.scale().domain([pParam.minDate, pParam.maxDate]).range([0, plotWidth]);
      var yPlotScale = d3.scale.linear().domain([pParam.minY, pParam.maxY]).range([0, plotHeight]);

      // define the x- and y-axis scales for transforming forcePatent and forceBiblio map coordinates to plotting coordinates
      var xForceToPlotScale = d3.scale.linear().domain([xForceScale(fMap.minDate), xForceScale(fMap.maxDate)])
                                               .range([xPlotScale(fMap.minDate), xPlotScale(fMap.maxDate)]);
      var yForceToPlotScale = d3.scale.linear().domain([0, fMap.h])
                                               .range([yPlotScale(0), yPlotScale(fMap.h)]);

      // create the x-axis with labels only
      var xAxisLabel = d3.svg.axis().orient("bottom").tickPadding(4).tickSize(2).scale(xPlotScale);
      var xAxisLabelSVG = svg.append("g").classed({"x-axis-label": true})
                             .attr({"transform": "translate(0," + plotHeight +")"}); // create x axis label SVG elements

      // create the x-axis gridlines
      var xAxisGrid = d3.svg.axis().orient("bottom").tickPadding(0).innerTickSize(plotHeight).outerTickSize(0)
                      //.innerTickSize(plotHeight).outerTickSize(0)
                          .scale(xPlotScale);

      // x axis gridline SVG; override default stroke:white, fill:black
      var xAxisGridSVG = svg.append("g").classed({"x-axis-grid": true})
                             .attr({"transform": "translate(0,0)"})
//                             .attr({"transform": "translate(0," + plotHeight +")"})
                             .style({"stroke": "lightgray", "fill": "transparent"});

      // container to process zoom events; is the target of mouse events when biblios are transparent to mouse events
      var zoom_rect = svg.append("svg:rect").attr({"class": "zoom-pane", "width": plotWidth, "height": plotHeight});

      // create g container for the plot elements that will be clipped; plot elements will be drawn last so they are the
      // first to receive events
      var plot = svg.append("svg:g").classed({"force-plot": true}).attr({"clip-path": "url(#clip)"});

      // create the company legend container; place after the force plot, so legends will be on top
      var legend = svg.append("svg:g").classed({"legend": true}).attr({"transform": "translate(20, 18)"});

      // create the node legend container and use d3js to construct it using createNodeLegend
      var nodeLegend = svg.append("svg:g").classed({"node-legend-container": true})
              .attr({"transform": "translate(" + (plotWidth - svgP.nodeLegend.w - svgP.nodeLegend.margin.right) +  ",9)"});

      </script>

          <div class="patent-lists">
            <div class="patent-list" data-listname="mapped">
              <div class="patent-list-header">Mapped</div>
              <div class="patent-list-patents">
                <!-- HTML from script id 'mapped-list-entry-section' for each patent in the list goes here -->
              </div>
            </div>
            <div class="patent-list" data-listname="favorites">
              <div class="patent-list-header">Favorites</div>
              <div class="patent-list-patents">
                <!-- HTML from script id 'favorites-list-entry-section' for each patent in the list goes here -->
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="tab-pane" id="Search">
        <iframe id="gps" src="advanced_patent_search" width="1050" height="700" scrolling="no" allowfullscreen="true" sandbox="allow-same-origin allow-top-navigation allow-forms allow-scripts">
	</iframe>
      </div>
    </div>

    <script type="text/javascript">

      $(document).ready(setupInitialTabs);

      function setupInitialTabs() {
        $("head").append($("script#customize-bootstrap-styles").html());      // append customized bootstrap styles (for tabs and popover html content)
        var aTab = $("a[data-toggle='tab']");
        aTab.on('shown.bs.tab', function(event) { // setup eventListeners so popovers on other tabs are disabled/reenabled correctly
          if (event.relatedTarget) {
            var $previousTab = $(event.relatedTarget);
            if ($previousTab.popover) {
              $previousTab.popover('enable');
              var tab_id = $previousTab.attr("id");
              if (tab_id.slice(0,10) == 'relatedTab') {                    // update the popover content of a related tab
                updateRelatedTabPopover($previousTab);
              }  
            }
          }
        });
      }

      function updateRelatedTabPopover($aTab) {
        // $aTab is a jQuery object containing the <a> element that is used to activate a bootstrap tab
	var divID = $aTab.attr("href");         // need to get the document in iframe of the div element associated with this tab
	var $context = $("div"+divID+" iframe").contents();
	var searchEntries = extractPriorArtSearchEntries($context);
	var popoverObject = $aTab.data('bs.popover');                     // get reference to popover instance; the .tip() method
	var popoverObjectContent = popoverObject.options.content;         // get popover html content
	var $popoverObjectContent = $(popoverObjectContent, popoverObjectContent);    // make into a jQuery object
	var $newTDsearch = $("td#jdw-pop-search-terms", popoverObjectContent).html(searchEntries.searchTerms);
	var $newTDstartDate = $("td#jdw-pop-start-date", popoverObjectContent).html(searchEntries.startDate);
	var $newTDendDate = $("td#jdw-pop-end-date", popoverObjectContent).html(searchEntries.endDate);
	$("td#jdw-pop-search-terms", $popoverObjectContent).replaceWith($newTDsearch);
	$("td#jdw-pop-start-date", $popoverObjectContent).replaceWith($newTDstartDate);
	$("td#jdw-pop-end-date", $popoverObjectContent).replaceWith($newTDendDate);
	popoverObject.options.content = $popoverObjectContent[0].outerHTML;
      }

      function extractPriorArtSearchEntries($context) {
	// extract patent number, title, search terms, and search dates for popover
	var searchTerms = '';
	$("div.search-term-wrapper span.jfk-checkbox-checked", $context).parent().parent()
	  .each( function(index) {
	    if (index == 0) {
	        searchTerms += $(this).text().trim();
	      }
	      else {
	        searchTerms += '<br>' + $(this).text().trim();
	    }
	  });
	var startDate = $("tr#start-date input", $context).val();
	if (startDate == '') startDate = 'Any';
	var endDate = $("tr#end-date input", $context).val();
	if (endDate == '') endDate = 'Any';
	return {searchTerms: searchTerms, startDate: startDate, endDate: endDate};
      }

      function deleteTab(event) {
        var clickedButton = $(event.target);
        var assocTab = clickedButton.closest("a");             // previous sibling element of the parent
        var activeTab = $("li.active > a");
        if (activeTab.get(0) == assocTab.get(0)) {             // are the HTML elements the same (the jQuery objects are not!)
            nextTab = assocTab.parent().prev().children("a");  // the previous tab
          }
          else {
            nextTab = activeTab
        }
        nextTab.tab("show");          // show nextTab before deleting the clicked tab and its content so popovers behave properly
        $("div"+assocTab.attr("href")).remove();             // remove the content of the tab; (the href of the anchor starts with '#' and references the div)
        clickedButton.closest("li").remove();                // remove the list element for the tab itself
      }

    </script>

    <script type="text/javascript">

      var startTime;                     // for debugging elapsed time
      var nSearchResultTabs = 0, nPatentTabs = 0, nRelatedTabs = 0;
      var patentBiblio = {};             // list of objects containing patent bibliographic, cited, citing, and related patent info; used for querying EPO for mapping
      var favoriteBiblio = {};           // list of objects containing patent bibliographic data, but no citation or related patent info; used for favorites list
      var epoBiblio = {};                // contains the bibliographic data fetched from EPO
      var patentNoEPOtoGoogle = {};      // a dictionary of epo patent document keys and Google patent document values
      var patentLists = {                // simple lists of patent numbers for each kind of list
         "map": [],
         "favorites": [],
         "deleted": [],                  // track order that patents are deleted, so deletions can be undone
         "cleared":
                   {"map": [],
                    "target": [],
                    "deleted": []
                   },
         "clearFlag": false              // flag set after user clicks the Clear button
      };

      // parse patent document number of form country code, prefix, number postfix, kind code into its components; used in
      // PatentPicker and makePatentLabel.
      var rExpPat = /([A-Z]{2})([A-Z]*)(\d+)([A-C,G]?(?=([A-Z]\d?)?$))/
      var patentRange = {                // range of numbers for random US patent selection
         "min": 1,
         "max": 8670000
      }

      var randomPatentPicker = new RandomPatentPicker();
      var patentPicker = new PatentPicker();

      function makePatentLabel(patent_no) {
      // given a valid patent_no, which can be either the full document number or the full document number without the
      // kind code, return the patent number without the kind code; to be used to label patents on the force diagram,
      // label patent tabs, and as the text of patent hyperlinks in biblios and patent lists.
        var rExpKC = /([A-Z]|[A-Z]\d)$/;
        return patent_no.replace(rExpKC, "");
      }

      function PatentPicker() {
      // map a patent number entered by the user in the input box at the top of the force map; called from on_click_btn.

        this.validatePatent = function(inputText, on_patent_validated) {
        // check if inputText is a valid patent number; if so, call callback on_patent_validated with an object
        // containing the full patent number (includes the kind code) and the patent_no (used for labeling the
        // tab and internally in the program); if not return an error message.
          var patent_url = ""; patentLabel = ""; var error = "";
          var enteredPatent = inputText.toUpperCase();
          enteredPatent = enteredPatent.replace(/\s/g, "");                // get rid of all whitespace
          if (enteredPatent.search(/[\W_]/) != -1) {                       // if any non alphanumeric characters
             // prompt for valid patent
          }
          var match = rExpPat.exec(enteredPatent);
          if (match) {                                                     // if has the form of a patent
            var fullMatch = match[0];
            var cc = match[1]; var pref = match[2]; var num = match[3]; var post = match[4]; var kc = match[5];
            if (cc in patForm) {                                           // if valid country code
              var cObj = patForm[cc];
              checkKC();
              // user appended a valid kind code or no kind code; user entered a valid prefix or no prefix; user entered a
              // valid postfix or no postfix
              if (hasValidKindCode(kc, cObj)) {
                if (hasValidPrefPost(pref, kc, cObj, "pref")) {
                  if (hasValidPrefPost(post, kc, cObj, "post")) {
                    patent_url = "/patents/" + fullMatch;                  // patent number entry has valid format
                    patentLabel = makePatentLabel(fullMatch);              // omit kind code from the label for the patent tab
                    checkGooglePatent(patent_url, on_check_patent_url_complete);          
                  }
                  else {
                    error = "Please try again"           // postfix code is not valid for this country
                  }
                }
                else {
                  error = "Please try again"             // prefix code not valid for this country
                }
              }
              else {
                error = "Please try again"               // kind code is not valid for this country
              }  
            }
            else {
              error = "Invalid country code"                               // country code appears to be invalid
            }
          }
          else {
            error = "Please try again"                   // prompt for valid patent number
          }
          on_patent_validated({"url": "", "label": "", "error": error});

          function on_check_patent_url_complete(respObject) {
          // callback for checkGooglePatent
            console.log("In patentPicker, checkGooglePatent response is ", respObject);
            if (!respObject.error) {
              on_patent_validated({"url": patent_url, "label": patentLabel, "error": ""});
            }
            else {
              on_patent_validated({"url": "", "label": "", "error": "Patent not found"});
            }            
          }

          function checkKC() {
            if (!kc && post) {                           // if parsed no kind code, but parsed a post
              if (cObj.post) {                           // if country has postfixes
                for (kc_post in cObj.post) {             // for each kind code that allows a postfix
                  // if post is legitimate for any kind code, assume it is meant to be a post
                  if (cObj.post[kc_post].indexOf(post) != -1) return;
                }
              }
              // assume the parsed post is actually the kind code if postfixes are not allowed or if postfixes are allowed
              // but the post is not a legitimate postfix for any kind code.
              kc = post;
              post = "";
            }
          }

          function hasValidKindCode(kc, cObj) {
            if (!kc) return true;
            return (cObj.kc.indexOf(kc) != -1) ? true: false;
          }

          function hasValidPrefPost(value, kc, cObj, type) {
            if (!value) return true;                                   // if user entered no pre-/post-fix
            if (cObj[type]) {                                          // if country has pre-/post-fixes in some patent numbers
              if (!kc) return true;                                    // assume valid if no kind code to check against
              if (kc in cObj[type]) {                                  // if this kind code can have a patent number pre-/post-fix
                return (cObj[type][kc].indexOf(value) != -1) ? true: false; // if pre-/post-fix value is in list for this kind code
              }
              else {                                                   // has pre-/post-fix, but this kind code never has one
                return false;
              }
            }
            else {                                                     // has pre-/post-fix, but country's patents cannot have one
              return false;
            }
          }
        }

        this.getPatent = function(patent_url, patentLabel, on_get_patent_complete) {
        // make a patent tab labeled patentLabel, and map the patent; on_get_patent_complete is the callback;
        // patent_url must be a valid Google patent url for a patent in the Google database (use this.validatePatent).
          taskTracker.initialize("Fetching patent", undefined);
          taskTracker.startTask(1);
          // note that patent_url does not necessarily match the url that Google would use for a link to the patent.
console.log("In patentPicker, getting Google patent url " + patent_url + " and making a patent tab labeled " + patentLabel);

          patentTab(patent_url, patentLabel, on_patent_tab_complete);    // with getting the patent and creating a tab for it

          function on_patent_tab_complete(patent_no) {
          // callback called from patentTab with patent_no parsed from the Google patent document
            taskTracker.finishTask(1);
            toggleButton(patent_no, "btn-map-add", "add");
            addMapPatent(patent_no, "map", onMapComplete);
          }

          function onMapComplete() {
            var $aTab = $("a[data-tabname='" + patentLabel + "']");
            $aTab.click();
            setUndoButtonState();
            setClearButtonState();
            if (on_get_patent_complete) {
              on_get_patent_comlete();
            }
          }
        }

        this.showError = function(error) {
          $("div.patent-input-error").addClass("make-displayed").text(error);   // show error message
          $("input.input-patent").focus();
          $("input.input-patent").select();
        }

        this.clearError = function() {
          $("div.patent-input-error").removeClass("make-displayed").text("");   // clear error message
        }

        var patForm = {
          "AP" : {"kc": ["A", "D0"]},
          "AR" : {"kc": ["A1", "A2", "A3", "A4", "A6", "Q"]},
          "AT" : {"kc": ["A", "A1", "A2", "A3", "A4", "A5", "A8", "A9", "B", "B1", "B2", "B8", "B9", "D", "T",
                  "U1", "U2", "U3", "U8", "U9"], "pref": {"A": ["A"]}},
          "AU" : {"kc": ["A", "A1", "A2", "A3", "A4", "A5", "A6", "A8", "A9", "B", "B1", "B2", "B3", "B4", "B8",
                  "B9", "C", "C1", "C4", "C8", "C9", "D0", "S"], "pref": {"D0": ["PN", "PM", "PO", "PP", "PA", "PR", "PW"]}},
          "BA": {"kc": ["A", "B1", "D"]},
          "BE": {"kc": ["A", "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "B3", "B5", "B6", "D", "T1", "T2"]},
          "BG": {"kc": ["A", "A1", "A2", "A3", "A4", "B1", "B2", "U", "U1", "Y1", "Y2"]},
          "BR": {"kc": ["A", "A2", "A8", "B", "B1", "B8", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "D0", "E2",
                 "F1", "K1", "S", "S1", "U", "U2", "Y1", "Y8"],
                 "pref": {"A": ["PI"], "A2": ["PI"], "A8": ["PI"], "B": ["PI"], "B1": ["PI"], "B8": ["PI"],
                         "C1": ["PI"], "C2": ["PI"], "C3": ["PI"], "C4": ["PI"], "C5": ["PI"], "C6": ["PI"],
                         "C7": ["PI"], "C8": ["PI"], "E2": ["PI"], "F1": ["PI"], "S": ["D"], "U": ["MU"],
                         "U2": ["MU"], "Y1": ["MU"], "Y8": ["MU"]}},
          "BY": {"kc": ["C1", "U"]},
          "CA": {"kc": ["A", "A1", "A2", "B", "C", "C2", "E", "F", "S"]},
          "CH": {"kc": ["A", "A1", "A2", "A3", "A4", "A5", "A8", "A9", "B", "B1", "B5", "B8", "B9", "C1", "C2", "C3",
                 "C9", "D", "E", "H1", "H2", "H3", "H9"], "post": {"A3": ["G"]}},
          "CL": {"kc": ["A1", "B", "S1", "U", "Y"]},
          "CN": {"kc": ["A", "B", "C", "K1", "K2", "K3", "K4", "K5", "S", "U", "Y"]},
          "CO": {"kc": ["A1", "A2", "U", "U1"]},
          "CR": {"kc": ["A", "S", "U"]},
          "CS": {"kc": ["A", "A1", "A2", "B1", "B2", "B3", "B4", "B5", "B6", "C"]},
          "CU": {"kc": ["A", "A1", "A2", "A3", "A5", "A6", "A7", "B6", "B7", "L"]},
          "CY": {"kc": ["A", "B1", "B2", "T1"]},
          "CZ": {"kc": ["A3", "B6", "U1"]},
          "DD": {"kc": ["A", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "B", "B1", "B2", "B3", "B5", "C2",
                 "C4", "C5", "T1", "U"]},
          "DE": {"kc": ["A", "A1", "A5", "A8", "A9", "B", "B1", "B2", "B3", "B4", "B8", "B9", "C", "C1", "C2", "C3",
                 "C4", "C5", "C8", "C9", "D1", "D2", "I1", "I2", "T", "T1", "T2", "T3", "T4", "T5", "T8", "T9",
                 "U", "U1", "U8", "U9"]},
          "DK": {"kc": ["A", "B", "B1", "B2", "B3", "C", "D0", "K1", "L", "T1", "T3", "T4", "T5", "U1", "U3", "U4", "Y3",
                 "Y4", "Y5", "Y6", "Z6"]},
          "DO": {"kc": ["A", "S", "U"], "pref": {"A": ["P"], "S": ["S"], "U": ["U"]}},
          "DZ": {"kc": ["A1"]},
          "EA": {"kc": ["A1", "A2", "A3", "A8", "B1", "B2", "B8", "B9"]},
          "EC": {"kc": ["A", "S", "U"], "pref": {"A": ["SP"], "S": ["SDI"], "U": ["SM", "SMU"]}},
          "EE": {"kc": ["A", "B1", "U1"]},
          "EG": {"kc": ["A"]},
          "EP": {"kc": ["A1", "A2", "A3", "A4", "A8", "A9", "B1", "B2", "B3", "B8", "B9"]},
          "ES": {"kc": ["A1", "A2", "A3", "A4", "A6", "A8", "A9", "B1", "B2", "B3", "B8", "B9", "D", "D0", "H1", "H3",
                 "K1", "R", "R1", "R2", "T1", "T2", "T3", "T4", "T5", "T7", "T8", "T9", "U", "U4", "U8", "U9",
                 "X1", "X3", "Y", "Y4"]},
          "FI": {"kc": ["A", "A0", "A1", "A7", "B", "B1", "B2", "B3", "C", "L", "U0", "U1"]},
          "FR": {"kc": ["A", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "B", "B1", "B2", "B3", "B4", "E", "F", "M", "T"]},
          "GB": {"kc": ["A", "A8", "A9", "B", "B8", "C", "C2", "D0"]},
          "GC": {"kc": ["A"]},
          "GE": {"kc": ["A", "B", "U", "Y"], "pref": {"A": ["AP"], "B": ["P", "AP"], "U": ["U", "AU"], "Y": ["U"]}},
          "GR": {"kc": ["A", "A1", "A7", "B", "B1", "B2", "T1", "T3", "T7", "U", "Y"]},
          "GT": {"kc": ["A", "S", "U"], "post": {"A": ["A", "B", "C"]}},
          "HK": {"kc": ["A", "A1", "A2"]},
          "HN": {"kc": ["A", "S1", "U"]},
          "HR": {"kc": ["A2", "A8", "A9", "B1", "B3", "B4", "B8", "B9", "C1", "T1", "T2", "T3", "T4", "T5", "T8"],
                 "pref": {"A2": ["P"], "A8": ["P"], "A9": ["P"], "B1": ["P", "PK"], "B3": ["PK"], "B4": ["PK"], "B8": ["P"],
                          "B9": ["P"], "C1": ["P"], "T1": ["P"], "T2": ["P"], "T3": ["P"], "T4": ["P"], "T5": ["P"], "T8": ["P"]}},
          "HU": {"kc": ["A", "A1", "A2", "A3", "A9", "B", "B1", "D0", "U", "V0"], "pref": {"A": ["H", "T"]}},
          "ID": {"kc": ["A", "B", "S"]},
          "IE": {"kc": ["A1", "A2", "B1", "B2", "L"], "pref": {"A2": ["S"], "B2": ["S"], "L": ["S"]}},
          "IL": {"kc": ["A", "D0"]},
          "IN": {"kc": ["A1", "E"]},
          "IS": {"kc": ["A", "A7", "B", "B2", "B3", "B6"]},
          "IT": {"kc": ["A", "A1", "A3", "A4", "B", "B1", "D0", "T1", "T2", "T3", "U1", "U3", "U4", "V0", "Y1", "Z2"],
                 "pref": {"A1": ["BO", "SS", "GO", "VI", "AN", "AP", "AR", "PA", "UD", "LE", "TO", "MI", "WX", "VT", "AG",
                                 "MI", "AL", "VV", "VR", "AQ", "SV", "PS", "PD", "NA", "SA", "CS", "GE", "TP", "IS", "FI",
                                 "BG", "VC", "BS", "PG"],
                          "A3": ["BO", "SS", "GO", "VI", "AN", "AP", "AR", "PA", "UD", "LE", "TO", "MI", "WX", "VT", "AG",
                                 "MI", "AL", "VV", "VR", "AQ", "SV", "PS", "PD", "NA", "SA", "CS", "GE", "TP", "IS", "FI",
                                 "BG", "VC", "BS", "PG"],
                          "A4": ["BO", "SS", "GO", "VI", "AN", "AP", "AR", "PA", "UD", "LE", "TO", "MI", "WX", "VT", "AG",
                                 "MI", "AL", "VV", "VR", "AQ", "SV", "PS", "PD", "NA", "SA", "CS", "GE", "TP", "IS", "FI",
                                 "BG", "VC", "BS", "PG"],
                          "DO": ["BO", "SS", "GO", "VI", "AN", "AP", "AR", "PA", "UD", "LE", "TO", "MI", "WX", "VT", "AG",
                                 "MI", "AL", "VV", "VR", "AQ", "SV", "PS", "PD", "NA", "SA", "CS", "GE", "TP", "IS", "FI",
                                 "BG", "VC", "BS", "PG"],
                          "T1": ["BO", "SS", "GO", "VI", "AN", "AP", "AR", "PA", "UD", "LE", "TO", "MI", "WX", "VT", "AG",
                                 "MI", "AL", "VV", "VR", "AQ", "SV", "PS", "PD", "NA", "SA", "CS", "GE", "TP", "IS", "FI",
                                 "BG", "VC", "BS", "PG"],
                          "T2": ["BO", "SS", "GO", "VI", "AN", "AP", "AR", "PA", "UD", "LE", "TO", "MI", "WX", "VT", "AG",
                                 "MI", "AL", "VV", "VR", "AQ", "SV", "PS", "PD", "NA", "SA", "CS", "GE", "TP", "IS", "FI",
                                 "BG", "VC", "BS", "PG"],
                          "T3": ["BO", "SS", "GO", "VI", "AN", "AP", "AR", "PA", "UD", "LE", "TO", "MI", "WX", "VT", "AG",
                                 "MI", "AL", "VV", "VR", "AQ", "SV", "PS", "PD", "NA", "SA", "CS", "GE", "TP", "IS", "FI",
                                 "BG", "VC", "BS", "PG"],
                          "U1": ["BO", "SS", "GO", "VI", "AN", "AP", "AR", "PA", "UD", "LE", "TO", "MI", "WX", "VT", "AG",
                                 "MI", "AL", "VV", "VR", "AQ", "SV", "PS", "PD", "NA", "SA", "CS", "GE", "TP", "IS", "FI",
                                 "BG", "VC", "BS", "PG"],
                          "U3": ["BO", "SS", "GO", "VI", "AN", "AP", "AR", "PA", "UD", "LE", "TO", "MI", "WX", "VT", "AG",
                                 "MI", "AL", "VV", "VR", "AQ", "SV", "PS", "PD", "NA", "SA", "CS", "GE", "TP", "IS", "FI",
                                 "BG", "VC", "BS", "PG"],
                          "U4": ["BO", "SS", "GO", "VI", "AN", "AP", "AR", "PA", "UD", "LE", "TO", "MI", "WX", "VT", "AG",
                                 "MI", "AL", "VV", "VR", "AQ", "SV", "PS", "PD", "NA", "SA", "CS", "GE", "TP", "IS", "FI",
                                 "BG", "VC", "BS", "PG"],
                          "V0": ["BO", "SS", "GO", "VI", "AN", "AP", "AR", "PA", "UD", "LE", "TO", "MI", "WX", "VT", "AG",
                                 "MI", "AL", "VV", "VR", "AQ", "SV", "PS", "PD", "NA", "SA", "CS", "GE", "TP", "IS", "FI",
                                 "BG", "VC", "BS", "PG"],
                          "Y1": ["BO", "SS", "GO", "VI", "AN", "AP", "AR", "PA", "UD", "LE", "TO", "MI", "WX", "VT", "AG",
                                 "MI", "AL", "VV", "VR", "AQ", "SV", "PS", "PD", "NA", "SA", "CS", "GE", "TP", "IS", "FI",
                                 "BG", "VC", "BS", "PG"]}},
          "JO": {"kc": ["B"]},
          "JP": {"kc": ["A", "A1", "B", "B1", "B2", "C1", "C2", "K1", "K2", "K4", "K5", "S", "U", "U3", "Y1", "Y2", "Z1", "Z2"],
                 "pref": {"A": ["S", "H"], "A1": ["WO"], "B1": ["S", "H"], "B2": ["S", "H"], "K1": ["S", "H"], "K2": ["S", "H"],
                         "K4": ["S", "H"], "K5": ["S", "H"], "U": ["S", "H"], "Y1": ["S", "H"], "Y2": ["S", "H"]}},
          "KE": {"kc": ["A", "D"]},
          "KR": {"kc": ["A", "B1", "K1", "K2", "S", "U", "Y1"]},
          "KZ": {"kc": ["A", "B"]},
          "LT": {"kc": ["A", "B", "R3"]},
          "LU": {"kc": ["A", "A1", "A2", "A7", "D", "I2"]},
          "LV": {"kc": ["A", "A3", "A4", "B", "B4"]},
          "MA": {"kc": ["A1", "B1"]},
          "MC": {"kc": ["A", "E"]},
          "MD": {"kc": ["A", "A0", "A1", "A2", "A3", "B1", "B2", "C1", "C2", "E", "F1", "F2", "F3", "G2", "U", "W1", "W2", "Y",
                 "Y1", "Y2", "Z", "Z2"]},
          "ME": {"kc": ["A"]},
          "MN": {"kc": ["A6"]},
          "MT": {"kc": ["A"], "pref": {"A": ["P"]}},
          "MW": {"kc": ["A1"]},
          "MX": {"kc": ["A", "B", "E"], "pref": {"A": ["PA", "YU", "GT", "JL", "NL"]}},
          "MY": {"kc": ["A", "U"]},
          "NI": {"kc": ["A"]},
          "NL": {"kc": ["A", "A1", "B", "C", "C1", "C2", "C8", "I1", "I2", "T"]},
          "NO": {"kc": ["A", "B", "B1", "B2", "B3", "C", "D0", "I1", "I2", "L"]},
          "NZ": {"kc": ["A"]},
          "OA": {"kc": ["A", "E"]},
          "PA": {"kc": ["A1", "A2"]},
          "PE": {"kc": ["A1", "Z"]},
          "PH": {"kc": ["A", "U"]},
          "PL": {"kc": ["A1", "A2", "A3", "A4", "A5", "A6", "B1", "B2", "B3", "B4", "T3", "U1", "U3", "Y1", "Y3"]},
          "PT": {"kc": ["A", "A1", "B", "B1", "D", "E", "T", "U", "W", "Y"]},
          "RO": {"kc": ["A", "A0", "A1", "A2", "A3", "A7", "A8", "B", "B1", "B2", "B8", "B9", "C1", "U1", "U2", "U8"]},
          "RS": {"kc": ["A", "A1", "A2", "A3", "B", "U"]},
          "RU": {"kc": ["A", "A8", "C", "C1", "C2", "C8", "C9", "K1", "K3", "S", "U1", "U8"]},
          "SE": {"kc": ["A", "A0", "A1", "A2", "B", "C", "C1", "C2", "C3", "C5", "C8", "D0", "E", "E5", "K3", "L"]},
          "SG": {"kc": ["A1", "A2", "G"]},
          "SI": {"kc": ["A", "A1", "A2", "A8", "B", "T1", "T2"]},
          "SK": {"kc": ["A3", "B6", "U1", "Y1", "Y2"]},
          "SM": {"kc": ["A", "B", "S", "S1", "S2", "S3", "S4"], "pref": {"A": ["AP"], "B": ["P", "T"], "S4": ["C"]}},
          "SU": {"kc": ["A", "A1", "A2", "A3", "A4", "K1", "T"]},
          "SV": {"kc": ["A"]},
          "TH": {"kc": ["A"]},
          "TJ": {"kc": ["A", "B", "R3", "U", "Y3"]},
          "TR": {"kc": ["A", "A1", "A2", "A3", "T1", "T2", "T3", "T4", "U", "U1", "U2", "Y"]},
          "TT": {"kc": ["B"]},
          "TW": {"kc": ["A", "B", "K1", "K2", "S", "U"], "pref": {"B": ["I"], "K2": ["I"], "S": ["D"], "U": ["M"]}},
          "UA": {"kc": ["A", "A1", "C2", "U"]},
          "US": {"kc": ["A", "A1", "A2", "A9", "B", "B1", "B2", "B3", "C1", "C2", "E", "E1", "F1", "F2", "H", "H1", "I1", "I3",
                 "I4", "I5", "P", "P1", "P2", "P3", "S", "S1"],
                 "pref": {"E": ["RE"], "E1": ["RE"], "F1": ["RE"], "H": ["H"], "H1": ["H"], "I1": ["X"], "I3": ["AI"],
                          "I4": ["T"], "I5": ["B"], "S": ["D"], "S1": ["D"]}},
          "UY": {"kc": ["A", "A1", "A2", "A3", "Q", "U"]},
          "UZ": {"kc": ["B"]},
          "VN": {"kc": ["A1", "A6", "U"]},
          "WO": {"kc": ["A1", "A2", "A3", "A4", "A8", "A9", "B1", "B8", "K1"]},
          "YU": {"kc": ["A", "B", "U"], "pref": {"A": ["P"], "U": ["MP"]}},
          "ZA": {"kc": ["A", "D"]},
          "ZM": {"kc": ["A1", "D"]},
          "ZW": {"kc": ["A1"]}
        }
      }

      function RandomPatentPicker() {
      // object to choose and plot a randomly select US patent on the force map; callback argument for
      // .mapRandomPatent is an optional callback.
        this.maxTries = 20;

        this.initialize = function() {
          taskTracker.initialize("Finding random patent", undefined);
          taskTracker.startTask(1);
        }

        this.mapRandomPatent = function(on_map_random_complete) {
        // generate a random US patent number and map it; call optional callback when done
          this.initialize();
          var reTries = 0;
          var patentLabel = "";
          var patent_url = "";
          USpatent = getRandomPatentNo();                    // get a random US patent number without the kind code
          if (USpatent) {
            taskTracker.startTask(1);
            patent_url = "/patents/" + USpatent;
            checkGooglePatent(patent_url, on_check_patent_url_complete.bind(this));          
          }
          else {
            console.log("In randomPatentPicker, could not find a patent that was not already mapped!"); 
          }

          function on_check_patent_url_complete(respObject) {
          // if patent_no exists in Google database, proceed with creating the tab and mapping the patent; if not
          // try again with a different random patent number.
            taskTracker.finishTask(1);
            if (!respObject.error) {
              patentLabel = makePatentLabel(USpatent);
              patentTab(patent_url, patentLabel, on_patent_tab_complete);
            }
            else {
              if (reTries < maxTries) {
                console.log("In randomPatentPicker, retry " + reTries);
                reTries += 1;
                this.mapRandomPatent(on_map_random_complete);
              }
              else {
                console.log("In randomPatentPicker, max retries " + this.maxTries + " exceeded. Exiting...");
              }
            }
          }

          function on_patent_tab_complete(patent_no) {
          // callback called from patentTab with patent_no parsed from the Google patent document
            taskTracker.finishTask(1);
            toggleButton(patent_no, "btn-map-add", "add");
            addMapPatent(patent_no, "map", onMapComplete);
          }

          function onMapComplete() {
            var $aTab = $("a[data-tabname='" + patentLabel + "']");
            $aTab.click();
            setUndoButtonState();
            setClearButtonState();
            if (on_map_random_complete) {
              on_map_random_complete();
            }
          }

          function getRandomPatentNo() {
            for (var i = 0; i < 20; i++) {
              var random_no = patentRange.min + Math.floor((patentRange.max - patentRange.min + 1)*Math.random());
              var randomUS = "US" + random_no;
              var alreadyMapped = false;
              var mapList = (patentLists["map"].length > 0) ? patentLists["map"]: patentLists["cleared"]["map"];
              for (iPat = 0; mapList.length; iPat++) {
                var patent_no = mapList[iPat];                         // the full Google patent document patent number
                if (makePatentLabel(patent_no) == makePatentLabel(randomUS)) {
                  alreadyMapped = true;
                  break;
                }
              }
              if (!alreadyMapped) {
                return randomUS;
              }
            }
            return undefined;
          }
        }
      }

      var taskTracker = new TaskTracker();   // tracks queries and updates status line at top of patent map

      function TaskTracker() {
        this.initialize = function(taskType, callback) {
          // if final timeout still running from previous query set
          if (this.runningTimeout && (this.maxCount == this.doneCount)) {
            window.clearTimeout(this.runningTimeout);
            this.tasksComplete();
          }
          $("span.status-line-type").text(taskType + " ");
          this.doneCount = 0;
          this.maxCount = 0;
          this.runningTimeout = undefined;
          this.callback = callback;
        }
        this.startTask = function(num) {
          this.maxCount += num;
          this.updateMessage();
          if (!this.runningTimeout) {    // if no query was running, then need to make the status message visible
            $("div.status-line").addClass("make-visible");
          }
          this.updateTimeout();
        }
        this.finishTask = function(num) {
          this.doneCount += num;
          this.updateMessage();
          this.updateTimeout(); 
        }
        this.updateTimeout = function() {
          if (this.runningTimeout) {
            window.clearTimeout(this.runningTimeout);
          }
          if (this.maxCount > this.doneCount) {                          // at least one query is still running
            var newTime = (this.maxCount - this.doneCount)*2000;
          }
          else {                                                         // all queries in queue have completed
            var newTime = 2000;
          }
          this.runningTimeout = window.setTimeout(this.tasksComplete.bind(this), newTime);
        }
        this.tasksComplete = function() {
          $("div.status-line").removeClass("make-visible");
          this.runningTimeout = undefined;
          if (this.doneCount != this.maxCount) {
            console.log("In TaskTracker, " + (this.maxCount - this.doneCount) + " tasks failed to complete");
          }
          if (this.callback) {               // call the callback passed in .initialize if it is defined
            this.callback();
          }
        }
        this.updateMessage = function() {
          $("span.status-line-queries").text(this.report());
        }
        this.report = function() {
          return this.doneCount + "/" + this.maxCount;
        }
      }

      var external_URLs = ['worldwide.espacenet.com',
                           'register.epo.org',
                           'uspto.gov',
                           'wipo.int',
                           'scholar.google.com',
                           'docs.google.com',
                           'sipo',
                           '.bibtex',
                           '.enw',
                           '.ris'];

      var rExp_patno_from_url = /\/(?:patents|related)\/(\w+)(?:[\?#%&]|$)/;  // match /patent_num?,# or end of url string; (?:...) specifies non-capturing

      var formFields = {
        "as_q" : "All of: ",
        "as_epq" : "Exactly: ",
        "as_oq" : "At least one: ",
        "as_eq" : "None of: ",
        "as_pnum" : "Patent: ",
        "as_vt" : "Title: ",
        "as_pinvent" : "Inventor: ",
        "as_pasgnee" : "Assignee: ",
        "as_pusc" : "US class: ",
        "as_pintlc" : "Int'l class: ",
        "as_pcoopc" : "Coop class: ",
        "as_ptypeorstatus" : "Type: ",
        "as_drrb_is" : "ChkBoxPatDateOptions",    // value 'q' anytime; value 'b' between dates
        "as_minm_is" : "MinMonth",
        "as_miny_is" : "MinYear",
        "as_maxm_is" : "MaxMonth",
        "as_maxy_is" : "MaxYear",
        "as_pdatetype" : "Restrict by"          // value '1' application date; value '2' issue date
      };

      var typeValues = {
        "0" : "Any", "1" : "Application", "2" : "Issued", "3" : "Utility", "4" : "Design", "5" : "Plant",
        "6" : "Other", "7" : "Other", "8" : "Other"
      };

      var restrictByValues = {
        "1" : "Appl. date", "2" : "Issue date"
      };

      var monthValues = {
       "0" : "", "1" : "Jan ", "2" : "Feb ", "3" : "Mar ", "4" : "Apr ", "5" : "May ", "6" : "Jun ",
        "7" : "Jul ", "8" : "Aug ", "9" : "Sep ", "10" : "Oct ", "11" : "Nov ", "12" : "Dec "
      };

      function TableTemplateVars() {
        return {
          "t1" : "", "v1" : "",
          "t2" : "", "v2" : "",
          "t3" : "", "v3" : "",
          "t4" : "", "v4" : "",
          "t5" : "", "v5" : "",
          "t6" : "", "v6" : "",
          "t7" : "", "v7" : "",
          "t8" : "", "v8" : "",
          "t9" : "", "v9" : "",
          "t10" : "", "v10" : "",
          "t11" : "", "v11" : "",
          "t12" : "", "v12" : "",
          "t13" : "", "v13" : "",
          "t14" : "", "v14" : "",
          "t15" : "", "v15" : "",
          "t16" : "", "v16" : ""};
      }

      $("iframe#gps").load(function() {
        var $context = $(this).contents();
        $("a[href='http://www.google.com/'] > img", $context).unwrap();    // delete link associated with the Google logo
        $("a[href='/about.html']", $context).remove();                     // delete the 'About Google' link
        $("center:contains('\u00A9')", $context).remove();                 // delete the Google copyright notice
        $("form[action='/patents']", $context).on("submit", on_submit_form);  // intercept the form submit request...


        function on_submit_form(event) {
          event.preventDefault();
          var searchTerms = $(this).serializeArray();                           // an array of objects {name: input field name, value: input field value}
          var url = $(this).attr('action');
          var formData = $(this).serialize();                                   // get the form query data
//          $.get(url, formData, function(resp) {                               // do a GET request to do the search
          make_search_result_tab(url + '?' + formData, '', searchTerms);
        }

      });

      function make_related_tab(related_url) {
        nRelatedTabs += 1;
        var link_match = rExp_patno_from_url.exec(unescape(related_url));        // javascript unescape() function to remove %2F
        var patent_no = link_match ? link_match[1] : '';
        var tab_name = 'Re-' + patent_no;
        var tab_id = "relatedTab_" + nRelatedTabs;
        var tab_content_id = "related_" + nRelatedTabs;
        var iframe_id = "gps_related_" + nRelatedTabs;
        var navTabHTML = _.template( $("script#bs_nav-tab").html(), {tab_id: tab_id, tab_content_id: tab_content_id, tab_name: tab_name});
        var tabContentHTML = _.template( $("script#bs_tab-pane").html(),
          {tab_content_id: tab_content_id, iframe_id: iframe_id, iframe_width: 1220, iframe_height: srchIFrameHeight});
        $("div.tab-pane.active").after(tabContentHTML);
        $("ul#topTabs li.active").after(navTabHTML);
        var htmlPriorArtHeader = _.template( $("script#prior-art-table").html(), {patent_no: patent_no});
        $("iframe#" + iframe_id).load(function() {on_related_load(this, tab_id, htmlPriorArtHeader);});
        $("iframe#" + iframe_id).attr("src", related_url);
//          $("a#" + tab_id).tab("show");
//          window.scrollTo(0,0);
      }

      function make_search_result_tab(search_url, tab_title, searchTerms) {
        nSearchResultTabs += 1;
        var tab_name = (tab_title == '') ? 'S-' + nSearchResultTabs.toString() : tab_title;
        var tab_id = "searchTab_" + nSearchResultTabs;
        var tab_content_id = "result_" + nSearchResultTabs;
        var iframe_id = "gps_result_" + nSearchResultTabs;
        var navTabHTML = _.template( $("script#bs_nav-tab").html(), {tab_id: tab_id, tab_content_id: tab_content_id, tab_name: tab_name});
        var tabContentHTML = _.template( $("script#bs_tab-pane").html(),
          {tab_content_id: tab_content_id, iframe_id: iframe_id, iframe_width: 1050, iframe_height: srchIFrameHeight});
        $("div.tab-pane.active").after(tabContentHTML);
        $("ul#topTabs li.active").after(navTabHTML);
        var htmlSearchTermsTable = createHTMLSummaryTable("script#search-term-table", searchTerms);   // table at the top of the search result page
        var htmlPopoverTable = createHTMLSummaryTable("script#search-term-popover", searchTerms);     // table in the popover for the page
        $("iframe#" + iframe_id).load(function() {on_search_result_load(this, tab_id, htmlSearchTermsTable, htmlPopoverTable);});
        $("iframe#" + iframe_id).attr("src", search_url);
//          $("a#" + tab_id).tab("show");
//          window.scrollTo(0,0);
      }

      function make_more_result_tab($currentIFrame, more_result_url) {
      // load more search results into the current iframe ($currentIFrame is a jQuery object)
        htmlSearchTermsTable = $("div#jdw1", $currentIFrame.contents()).clone();
        $currentIFrame.off("load");                                                                   // remove original search result load event handler
        $currentIFrame.on("load", function() {on_more_result_load(this, htmlSearchTermsTable);});
        $currentIFrame.attr("src", more_result_url);
        window.scrollTo(0,0);
      }

      function setupSearchTab(tab_id, htmlPopoverTable) {
        var aTab = $("a#" + tab_id);
        aTab.popover( {placement: "bottom", trigger: "hover", html: true, title: "Search:", content: htmlPopoverTable} );   // use trigger: "click" for debugging
        aTab.popover('disable');                       // disable initially since we are already looking at this tab
        var popoverObject = aTab.data('bs.popover');                                              // get reference to popover instance; the .tip() method
        $(popoverObject.tip()).addClass('jdwsearch').children("div,h3").addClass('jdwsearch');    // returns the top div element of the popover so can add my own css
        aTab.on('shown.bs.tab', on_tab_shown);
      }

      function setupMapFavButtons($btnContext, $docContext, page_type, patent_no) {
        var btnMap = $("span.btn-map-add", $btnContext);
        var btnFav = $("span.btn-favorite-add", $btnContext);
        $("span.btn-map-add, span.btn-favorite-add", $btnContext)
                 .attr("data-patent", patent_no)
                 .on("click", {$context: $docContext, page: page_type}, on_click_map_buttons);
        if (patentLists["map"].indexOf(patent_no) != -1) btnMap.addClass("show-result-btn");
        if (patentLists["favorites"].indexOf(patent_no) != -1) btnFav.addClass("show-result-btn");
      }

      function on_related_load(iframeElement, tab_id, htmlPriorArtHeader) {
        var $context = $(iframeElement).contents();
        $("head", $context).append($("script#search-term-table-style").html());    // append the style for the replacement page header
        // the main prior art patent list and parent patent info is loaded via javascript after the rest of the page loads; we need to detect
        // when those parts are populated with content; a hack to do this is to attach an animation to the div.r elements via css
        // see http://stackoverflow.com/questions/6997826/alternative-to-domnodeinserted
        $("body", $context).addClass("make-invisible");          // so user does not see the web page manipulations
        $("td.content-td",$context)
          .on('webkitAnimationStart', "div.r", function() {on_divr_added(this, $context);}); // Chrome animation event
        $("td.content-td",$context)
          .on('animationstart', "div.r", function() {on_divr_added(this, $context);});       // Firefox animation event
        $("td.metadata-td",$context)
          .on('webkitAnimationStart', "div.metadata", function() {on_divmeta_added(this, tab_id, $context);}); // Chrome animation event
        $("td.metadata-td",$context)
          .on('animationstart', "div.metadata", function() {on_divmeta_added(this, tab_id, $context);});       // Firefox animation event
        process_links($context, "related");

        // generate click for prior art patents only
        // 11/25/2013: do not need to simulate click if append '#c=p' to the end of the related url; only the patents load now
//          var patentsOnlyOption = $("div#left-toolbar-buttons div:contains('Patents')", $context).get(0);   // get underlying Element of Patents nav option
//          simulateClick(patentsOnlyOption, 'mousedown', patentsOnlyOption.ownerDocument.defaultView);     // so can send mousedown, mouseup event
//          simulateClick(patentsOnlyOption, 'mouseup', patentsOnlyOption.ownerDocument.defaultView);
        $("div#pocs", $context).remove();
        $("div.kd-appbar", $context).remove();                   // Prior Art Finder options row
        $("div#footer", $context).remove();
        $("div#gb", $context).replaceWith($("script#page-header").html());       // replace the google content with a greatly simplified version
        $("div#jdwTop", $context).append(htmlPriorArtHeader);                    // append html for the prior art page header
        var aTab = $("a#" + tab_id);                                          // attach on_tab_shown hander here. Firefox does not start animations until the page is visible
        aTab.on('shown.bs.tab', on_tab_shown);                                // Chrome starts them when the HTML for the animated element is loaded
        aTab.tab("show")                                                     // note that the div.r's and divmeta have not finished loading yet
        window.scrollTo(0,0);
      }

      function on_divr_added(divr, $context) {
      // called for each div.r that is added
        var divrContext = $(divr, $context);
        process_links(divrContext, "related");
        var $span_t = $("span.t", divrContext)
        if ($("span", $span_t).length == 1) {                                  // if the 'map' and 'favorites' buttons have not been added
          $("span.hide-result-btn", $span_t).addClass("btn-original");
          $span_t.append($("script#related-art-page-button-content").html());  // add them
          var btnMap = $("span.btn-map-add", $span_t);
          var patent_no = getPatentURL_No(btnMap, $context, "related").patent_no;
          setupMapFavButtons($span_t, $context, "related", patent_no);
          $("span.btn-original", $span_t).attr("title", "Hide");
        }
      }

      function setupPriorArtTab(tab_id, $context) {
        var patent_no = $("div#patent-metadata-box h2 a", $context).text();
        var patent_title = $("div#patent-metadata-box div#title", $context).text();
        var searchEntries = extractPriorArtSearchEntries($context);
        var htmlPopoverTitle = _.template( $("script#prior-art-popover-title").html(),
          {patent_no: patent_no, patent_title: patent_title});
        var htmlPopoverContent = _.template( $("script#prior-art-popover-content").html(),
          {searchTerms: searchEntries.searchTerms, startDate: searchEntries.startDate, endDate: searchEntries.endDate});
        var aTab = $("a#" + tab_id);
        aTab.popover( {placement: "bottom", trigger: "hover", html: true, title: htmlPopoverTitle, content: htmlPopoverContent} );  // or "click" and 'enable' to debug
        aTab.popover('disable');                       // disable initially since we are already looking at this tab
        var popoverObject = aTab.data('bs.popover');                                              // get reference to popover instance; the .tip() method
        $(popoverObject.tip()).addClass('jdwprior').children("div,h3").addClass('jdwprior');    // returns the top div element of the popover so can add my own css
      }

      function on_divmeta_added(divmeta, tab_id, $context) {
        // the divmeta div; the page_type is 'related-root' - the root patent of the prior art search
        var $divmetaContext = $(divmeta, $context);
        process_links($divmetaContext, "related-root");
        $("div#discuss-this-parent", $context).remove();    // the 'Discuss the patent' button ('patent' misspelled as 'parent' in the div id!)
        $("div.metadata h2", $context).append($("script#related-art-page-button-content").html());
        var btnMap = $("div.metadata span.btn-map-add", $context);
        patent_no = getPatentURL_No(btnMap, $context, "related-root").patent_no;
        setupMapFavButtons($divmetaContext, $context, "related-root", patent_no);
        setupPriorArtTab(tab_id, $context);                 // set up the popover for the tab for this page
        $("body", $context).removeClass("make-invisible");
        $("a#" + tab_id).click();
      }

/*
      function simulateClick(element, eventType, contextWindow) {
      // similate a mouse event 'type' on the 'element' in the 'contextWindow'
      // 11/25/2013: no longer need to use this function to load only patents in the related window; append "#c=p" to the end of the related url
        var event = new MouseEvent(eventType, {
          'view': contextWindow,
          'bubbles': true,
          'cancelable': true
        });
        var canceled = !element.dispatchEvent(event);
        if (canceled) {
        // A handler called preventDefault.
        }
        else {
        // None of the handlers called preventDefault.
        }
      }
*/

      function process_search_result_contents($context, htmlSearchTermsTable) {
      // process the content of a search page
        $("div#pocs", $context).remove();
        $("div#main div#top_nav", $context).remove();
        $("div#main div#topabar", $context).remove();
        $("p#bfl", $context).parent().remove();                      // Page bottom: advanced search and other links
        $("div#gfn", $context).remove();                             // Page bottom: empty div
        $("div#fll", $context).remove();                             // Page bottom: Google home and other links
        $("div#footcnt", $context).remove();                         // Page bottom: Help Feedback Privacy
        // contents() gets both text nodes and elements; remove the hyphen and the 'Discuss' link
        $("div.osl", $context).each ( function() { $(this).contents().slice(-2).remove();} );
        $("head", $context).append($("script#search-term-table-style").html());    // append style for the replacement page header
        $("div#mngb", $context).replaceWith($("script#page-header").html()); 
        $("div#jdwTop", $context).append(htmlSearchTermsTable);      // append html for the search term table
        $("body", $context).append($("script#search-page-more-results-style").html());  // append style for Goooogle page links
        $("li.g", $context).each(deleteNonPatents);                            // get rid of occasion Wikipedia links
        $("li.normal-footer, li.normal-footer + hr.rgsep", $context).remove(); // and associated elements
        // buttons to map, add to favorites, or hide patent
        $("div#ires h3.r", $context).append($("script#search-page-button-content").html());
        $("li.g span.btn-hide-add", $context).on("click", function(event) {on_click_hide_button(event, $context); });
        $("li.g span.btn-map-add", $context)
            .each(function() {
               var patent_no = getPatentURL_No(this, $context, "search").patent_no;
               $(this).attr("data-patent", patent_no).on("click", {$context: $context, page: "search"}, on_click_map_buttons);
               if (patentLists["map"].indexOf(patent_no) != -1) $(this).addClass("show-result-btn");
             });
        $("li.g span.btn-favorite-add", $context)
            .each(function() {
               var patent_no = getPatentURL_No(this, $context, "search").patent_no;
               $(this).attr("data-patent", patent_no).on("click", {$context: $context, page: "search"}, on_click_map_buttons);
               if (patentLists["favorites"].indexOf(patent_no) != -1) $(this).addClass("show-result-btn");
             });
        $("div#res", $context).before($("script#search-page-unhide-results").html()); // html to unhide hidden results
        $("span.hidden-results-message", $context).data("nHidden", 0);
        $("span.hidden-results-clear-btn", $context).on("click", function(event) {on_click_show_hidden(event, $context); });

        function deleteNonPatents() {
        // check the cite element of each li.g to see if it is a patent link; if not, delete it; stop looking after
        // encountering the first patent link by return false per jQuery documentation.
          var $cite = $(this).find("cite");
          if ($cite.size() > 0) {
            var citeText = $cite.text();
            var link_match = rExp_patno_from_url.exec(citeText);
            if (link_match) {
              return false;                                           // stops jQuery each loop
            }
            else {
              $(this).remove();
            }
          }
          else {
            $(this).remove();
          }
        }
      }

      function on_click_show_hidden(event, $context) {
      // click event handler for the 'Show all' button on the search results page that unhides hidden results
        $(event.target, $context).parent().addClass("hidden-show-all");        // the containing div element for the 'Show all' button
        $("li.hide-result", $context).removeClass("hide-result");
        $("span.hidden-results-message", $context).data('nHidden', 0);
      }

      function on_click_hide_button(event, $context) {
      // click event handler for the 'hide' button on the search results page
        var pressedButton = $(event.target, $context);
        var assocResult = pressedButton.closest("li.g", $context);
        assocResult.addClass("hide-result");
        var $hiddenMessage = $("span.hidden-results-message", $context);
        var curCount = $hiddenMessage.data("nHidden") + 1;
        $hiddenMessage.data("nHidden", curCount);                           // update the count of hidden patent results
        if (curCount == 1) {
          $hiddenMessage.text(curCount.toString() + ' result hidden below.');
        }
        else {
          $hiddenMessage.text(curCount.toString() + ' results hidden below.');
        }
        $("div.hidden-results-info", $context).removeClass("hidden-show-all")
      }

      function getPatentURL_No(element, $context, page_type) {
      // get the patent url and number associated with an HTML element or jQuery object for the element on a page of type
      // page_type ("mapped-list", "favorites-list",  "map", "main" "search", "patent", or "related")
        var patent_no = '';
        var patent_url = '';
        switch (page_type) {
          case "mapped-list": case "favorites-list":
            var $listPatent = $(element, $context).closest("div.patent-list-patent");
            var patent_no = $listPatent.attr("data-patent");
            patent_url = $listPatent.find("a.pop1-patent-url").attr("href");
            break;
          case "map":
            var $bibDiv = $(element, $context).closest("div.bib");
            patent_no = $bibDiv.attr("data-patent");
            patent_url = $bibDiv.find("a.pop1-patent-url").attr("href");
            break;
          case "main":
            // the data-patent attribute of the anchor element for a patent tab
            patent_no = $(element, $context).closest("a").attr("data-patent");
            patent_url = "/patents/" + patent_no;
            break;
          case "patent":
            patent_url = $(element, $context).attr("href");
            var link_match = rExp_patno_from_url.exec(patent_url);
            patent_no = link_match ? link_match[1] : '';
            break;
          case "search":
            var li_g = $(element, $context).closest("li.g", $context);
            patent_url = $(li_g, $context).find("cite", $context).text().replace(/www.google.com/,'');
            var link_match = rExp_patno_from_url.exec(patent_url);
            patent_no = link_match ? link_match[1] : '';
            break;
          case "related":
            var div_r = $(element, $context).closest("div.r", $context);
            patent_url = $(div_r, $context).find("cite", $context).text().replace(/www.google.com/,'');
            var link_match = rExp_patno_from_url.exec(patent_url);
            patent_no = link_match ? link_match[1] : '';
            break;
          case "related-root":
            var $div_metadata = $(element, $context).closest("div.metadata", $context);
            patent_url = $div_metadata.find("a", $context).attr("href").replace(/www.google.com/,'');
            var link_match = rExp_patno_from_url.exec(patent_url);
            patent_no = link_match ? link_match[1] : '';
          default:
        }
        return {"patent_url": patent_url, "patent_no": patent_no};
      }

      function toggleBtn(patent_no, btn, action) {
      // toggle the state of the map or favorite button for patent patent_no according to the action ("add" or "remove");
      // btn is the jQuery object for the map or add button that was clicked; called from on_click_map_buttons.
        var btn_type = btn.hasClass("btn-map-add") ? "btn-map-add": (btn.hasClass("btn-favorite-add") ? "btn-favorite-add": "");
        toggleButton(patent_no, btn_type, action);
      }

      function toggleButton(patent_no, btn_type, action) {
      // called from toggleBtn when user clicks on an add to map or favorite button; called from PatentPicker and
      // and RandomPatentPicker objects when patents are mapped via the Go!, Random, and Weird buttons.
        var $forceMapBtns = $("div#Map span."+btn_type+"[data-patent='"+patent_no+"']", document);     // get the map or favorite button on the force map
        if ($forceMapBtns.length > 0) changeClass($forceMapBtns, action);                              // update whether it displays as clicked or not
        var $patTabBtns = $("ul.nav-tabs span."+btn_type+"[data-patent='"+patent_no+"']", document);   // get the map or favorite button on the patent tab for patent_no
        if ($patTabBtns.length > 0) changeClass($patTabBtns, action);                                  // update whether it displays as clicked or not
        $("div.tab-pane[id^='result'] iframe, div.tab-pane[id^='related'] iframe")                     // get all the iframes for search and related tabs
          .each(function() {                                                                           // in each one, search for buttons associated with patent_no
            $context = $(this).contents();
            var $btn_family = $("span."+btn_type+"[data-patent='"+patent_no+"']", $context);
            if ($btn_family.length > 0) changeClass($btn_family, action);                              // update how the button for patent_no is displayed
          });
        function changeClass($btns, action) {
          switch (action) {
            case "remove":
              $btns.removeClass("show-result-btn");
              break;
            case "add":
              $btns.addClass("show-result-btn");
              break;
            default:
          }
        }          
      }

      function makeGoogleDate(dateStr) {
      // use moment.js to take a string like 20100416 and return a string Apr 16, 2010 (Google format).
        return moment.utc(dateStr, "YYYYMMDD").format("MMM D, YYYY");
      };

      function makeGoogleName(nameStr) {
      // take an EPO biblio inventor or applicant name (all caps SMITH PAUL L [US]) or MONSANTO LLC [US]) and strip off
      // the [US] and return mixed upper/lower case (Google format) names.
        var s = nameStr.replace(/\s\[\w*\]/g, "");                     // remove [US] from the end of the applicant name
        return makeUpperLower(s);                                      // make mixed upper/lower case
      }

      function makeUpperLower(nameStr) {
      // return mixed upper/lower case (Google format) names; in the regex, \b matches a word boundary; \w matches any
      // alphanumeric character; \s matches any whitespace character, including tabs and special unicode space characters
      // that are sometimes present in the EPO biblio data; occasionally, even Google has names in full caps.
        return nameStr.toLowerCase().replace(/\b\w/g, function(match) {return match.toUpperCase();});
      }

      function finalizeEPOAssignee(assignee) {
      // called from parseEPOPatentData when assignee name is not also in the inventors list. EPO removes a possessive in an
      // assignee name (e.g. John's Bagels in the original assignee becomes JOHN S BAGELS in the EPO assignee); convert back
      // to a possessive if an S appears by itself; need exception for company names that end in SA.
        return assignee.replace(/S A$|Sa$/, "SA").replace(/Llc/, "LLC").replace(/A G$|Ag$/, "AG")
                         .replace(/G M B H$|Gmbh$/, "GmbH").replace(" S ", "'s ");
      }

      function makeGoogleInventor(nameStr) {
      // massage the inventor names from EPO: put lastname last instead of first
      // the makeGoogleName function must already have been run
        if (!nameStr) return "";
        var returnStr = "";
        var names = nameStr.match(/(\S+)/g);
        names.forEach(function(val, i, array) {if (val.length == 1) array[i] += ".";});
        switch (names.length) {
          case 0:
            return "";
            break;
          case 1:
            return names[1];
            break;
          case 2:
            return names[1] + " " + names[0];
            break;
          default:
            switch (names[0]) {
              case "Von" : case "Van" :
                names[0] = names[0].toLowerCase();
                switch (names[1]) {
                  case "De": case "Der":
                    names[1] = names[1].toLowerCase();
                    names.push(names[0], names[1], names[2]);          // add the first three entries in names to the end of names
                    names = names.slice(3);
                    break;
                  default:
                    names.push(names[0], names[1]);          // add the first two entries in names to the end of names
                    names = names.slice(2);
                }
                break;
              case "De": case "Del":
                names[0] = names[0].toLowerCase();
                switch (names[1]) {
                  case "La":
                    names[1] = names[1].toLowerCase();
                    names.push(names[0], names[1], names[2]);
                    names = names.slice(3);
                    break;
                  default:
                    names.push(names[0], names[1]);
                    names = names.slice(2);
                }
                break;
              default:
                names.push(names[0]);
                names = names.slice(1);
            }
        }
        switch (names[0]) {
          case "Ii": case "Iii": case "Iv":
            names[0] = names[0].toUpperCase();              // no break!
          case "Jr": case "Sr":
            names.push(names[0]);
            names = names.slice(1);
            break;
          default:
        }
        return names.join(" ");
      }

      function makeGoogleTitle(titleStr) {
      // take an EPO biblio titleStr (all caps) and return mixed upper/lower case (Google format);
      // in the regex, ^ matches the beginning of the string.
        return titleStr.toLowerCase().replace(/^\b\w/g, function(match) {return match.toUpperCase();});
      }

      function checkInventorName(gooName, assigneeList) {
        var retName = gooName;
        for (var iApp = 0; iApp < assigneeList.length; iApp++) {
          var assigneeName = assigneeList[iApp];
          // sometimes an inventor name has the assignee mixed in!
          if (assigneeName.search(/Inc|Co|Llc|Ltd|Int|Tech|Ind|Nv/) != -1) {    // if assignee looks like a company
            aList = assigneeName.match(/(\S+)/g);                               // remove the words in assignee from inventor
            if (aList) {
              aList.forEach( function(val, ind, arr) {retName = retName.replace(/\bval\b/g, " ");});    // \b is a word boundary
              retName = retName.replace(/\s+/g, " ");
            }
          }
        }
        return retName;
      }

      function makeShort(assignee) {
      // take an assignee name and make a shortened version of it for the purpose of creating the shortAssignee
      // property of biblio objects, which is used in creating legend entries; called from getTIA and parseEPOPatentData
        var coList = ["INC", "INCORP", "LLC", "LIMITE", "LTD", "CO", "COMPAN", "TECHNO",
                      "TECH", "INDUST", "IND", "NV"];
        switch (assignee.slice(0,4).toUpperCase()) {
          case "":                                          // some patents have no assignee
            return "No assignee";
          case "UNIV":
            switch (assignee.slice(0,10).toUpperCase()) {
              case "UNIVERSITY":
                return assignee.slice(0,20);
              default:
                return assignee.slice(0,12);
            }
          default:
            var wordList = assignee.split(/[,\s]+/);    // split into list of words
            if (wordList.length == 1) {
              return wordList[0].slice(0,7);          // use first seven letters of first word as basis of matching an assignee name
            }
            else {
              var word2 = wordList[1].slice(0,6).toUpperCase();
              if (coList.indexOf(word2) == -1) {        // 2nd word is not in coList
                return wordList[0].slice(0,7) + " " + wordList[1].slice(0,7);
              }
              else {
                return wordList[0].slice(0,7);        // use first seven letters of first word as basis of matching an assignee name
              }
            }
        }
      }

      function parseEPOPatentData(epoJSON) {
      // parse the epoJSON containing the data returned by the EPO API; return processedList, a list of patent_no's
      // successfully parsed; parsed data stored in global epoBiblio using Google patent_no as the key.
        if (epoJSON["ops:world-patent-data"]) {                                   // got EPO data
          var epoPatents = epoJSON["ops:world-patent-data"]["exchange-documents"]["exchange-document"];
          epoPatents = (epoPatents instanceof Array) ? epoPatents : [epoPatents];   // a single patent is not returned as a list,
          console.log("Got " + epoPatents.length + " documents back from EPO");            // so make one
          var processedList = [], unprocessedList = []; dupList = []; notFoundList = []; USApplicationCount = 0;
          epoPatents.sort(function(a, b) {                                        // process all status = 'not found' patents last
                            if (!a["@status"] && b["status"]) {                   // so can eliminate the ones that were not found
                              return -1;                                          // due to ambiguity in Google for US utility vs
                            }                                                     // plant applications. Must query EPO for both
                            if (a["@status"] && !b["status"]) {                   // but one will always be 'not found'.
                              return 1;
                            }
                            return 0;
                          });
          for (var iPat = 0; iPat < epoPatents.length; iPat++) {
            try {
              var epoPatent = epoPatents[iPat];
              var country = epoPatent["@country"];
              var doc_number = epoPatent["@doc-number"];
              // kind will not be present if a patent is not found in EPO database
              var kind =  (epoPatent["@kind"]) ? epoPatent["@kind"] : "";
              // my queries to EPO for US patent docs never have a kind code
              var epo_patent_no = country + doc_number + ((country == "US") ? "" : kind);
              // the "@doc-number" is the true EPO docdb number; the epodoc number is different for US reissue, plant,
              // and design patents, in which case we need to append the first letter of the kind code...
              epo_patent_no = epo_patent_no + ((country == "US" &&
                          (kind.slice(0,1) == "E" || kind.slice(0,1) == "P" || kind.slice(0,1) == "S")) ? kind.slice(0,1) : "");
              // convert from EPO patent doc number to Google patent doc number to use as key in epoBiblio
              var patent_no = patentNoEPOtoGoogle[epo_patent_no];
              if (!(patent_no in epoBiblio) && epoPatent["@status"] != "not found") {
                // get pubDate first so can screen some patents out, like US B1 patents prior to 1/2/2001

                var pubDate = "";                                                 // get the publication date
                var pub_reference = epoPatent["bibliographic-data"]["publication-reference"];
                if (pub_reference) {
                  var document_id = pub_reference["document-id"];
                  pubDate = (document_id instanceof Array) ? makeGoogleDate(document_id[1]["date"]["$"]) : "";
                }

                var is_USB_123 = (country == "US" && kind[0] == "B");             // if patent is US kind B1,B2,B3 before 2001
                var is_pre_2001 = (moment.utc(pubDate).valueOf() < moment.utc("Jan 2, 2001"));
                if (is_USB_123 && is_pre_2001) {                                  // skip it
                  console.log("In parseEPOPatentData: patent " + patent_no + kind + " is US_B pre-2001");
                  dupList.push(patent_no + kind);
                  continue;
                }

                var abstractText = "";                                            // get the abstract
                var abstract = epoPatent["abstract"]
                if (abstract) {
                  // if more than one abstract, [0] is in English
                  abstractP = (abstract instanceof Array) ? abstract[0]["p"] : abstract["p"];
                  if (abstractP) {
                    if (abstractP instanceof Array) {                             // if more than one "p", concatenate them
                      var absList = [];
                      for (var iP = 0; iP < abstractP.length; iP++) {
                        absList.push(abstractP[iP]["$"]);
                      }
                      abstractText = absList.join(", ");
                    }
                    else {
                      abstractText = abstractP["$"];
                    }
                  }
                }

                var inventionTitle = "";                                          // get the invention title
                var invention_title = epoPatent["bibliographic-data"]["invention-title"];
                if (invention_title) {
                  inventionTitle = (invention_title instanceof Array) ?
                                             makeGoogleTitle(invention_title[0]["$"]) : makeGoogleTitle(invention_title["$"]);
                }

                // get the assignee and the inventors
                var assigneeList = [];                                            // store the assignees and the
                var inventorList = [];                                            // inventors listed in the EPO biblio
                var parties = epoPatent["bibliographic-data"]["parties"];
                if (parties) {
                  // process the assignees
                  var applicants = parties["applicants"];
                  if (applicants) {
                    var applicant = applicants["applicant"];
                    if (applicant instanceof Array) {                             // often inventors are also listed as applicants
                      for (var iApp = 0; iApp < applicant.length; iApp++) {       // get all assignees; compare against inventors
                        if (applicant[iApp]["@data-format"] == "epodoc") {        // later; @data-format can also be "original"
                          var epoName = applicant[iApp]["applicant-name"]["name"]["$"];
                          var gooName = makeGoogleName(epoName);
                          if (assigneeList.indexOf(gooName) == -1) {              // there are duplicate assignee names sometimes
                            assigneeList.push(gooName);
                          }
                        }
                      }
                    }
                    else {
                      var epoName = applicant["applicant-name"]["name"]["$"];
                      var gooName = makeGoogleName(epoName);
                      assigneeList.push(gooName);
                    }
                  }
                  // process the inventors
                  var inventors = parties["inventors"];
                  if (inventors) {
                    var inventor = inventors["inventor"];
                    if (inventor instanceof Array) {
                      for (var iInv = 0; iInv < inventor.length; iInv++) {
                        if (inventor[iInv]["@data-format"] == "epodoc") {        // 'epodoc' format has no commas or periods
                          var epoName = inventor[iInv]["inventor-name"]["name"]["$"];
                          var gooName = makeGoogleName(epoName);
                          if (inventorList.indexOf(gooName) == -1) {
                            inventorList.push(gooName);
                          }
                        }
                      }
                    }
                    else {
                      var epoName = inventor["inventor-name"]["name"]["$"];
                      var gooName = makeGoogleName(epoName);
                      inventorList.push(gooName);
                    }
                  }
                }

                // assigneeList might have names in the inventorList mixed in; get rid of these names in the assignees and
                // store the remaining names in finalAssigneeList
                var finalAssigneeList = [];
                var shortAssigneeList = [];
                for (var iApp = 0; iApp < assigneeList.length; iApp++) {
                  var assignee = assigneeList[iApp];
                  if (inventorList.indexOf(assignee) == -1) {
                    assignee = finalizeEPOAssignee(assignee);                   // get rid of EPO quirks in assignee names
                    finalAssigneeList.push(assignee);
                    shortAssigneeList.push(makeShort(assignee));
                  }
                }

                // sometimes an inventor name has the assignee mixed in, so check each one
                for (var iInv = 0; iInv < inventorList.length; iInv++) {
                  var gooName = makeGoogleInventor(inventorList[iInv]);                // put lastname last
                  inventorList[iInv] = checkInventorName(gooName, finalAssigneeList);  // strip out assignee words
                }

                // for older patents, EPO does not always have an assignee, in which case finalAssigneeList and shortAssigneeList
                // are empty at this point; assume that the assignee(s) are the inventors in this case
                if (finalAssigneeList.length == 0) {
                  for (var iInv = 0; iInv < inventorList.length; iInv++) {
                    finalAssigneeList.push(inventorList[iInv]);
                    shortAssigneeList.push(makeShort(inventorList[iInv]));
                  }
                }

                var fileDate = "";                                                // get the filing date
                var app_reference = epoPatent["bibliographic-data"]["application-reference"];
                if (app_reference) {
                  var document_id = app_reference["document-id"];
                  if (document_id instanceof Array) {
                    if (document_id[1]["date"]) {
                      fileDate = makeGoogleDate(document_id[1]["date"]["$"]);
                    }
                  }
                }
                // very old patents only have a publication date; still want to be able to plot them
                fileDate = (fileDate == "") ? pubDate: fileDate;
              }
              else {
                if (epoBiblio[patent_no]) {
                  if (!(country == "US" && patent_no.length == 13)) {      // if duplicate because we query US patent applications twice (as utility and as plant)
                    dupList.push(patent_no);                                       // then do not count as duplicate
                    console.log("In on_get_EPO_date: patent " + ((country == "US") ? patent_no + kind : patent_no) + " is duplicate");
                  }
                  else {
                    USApplicationCount += 1;
                  }
                }
                else {
                  notFoundList.push(patent_no);
                  console.log("In on_get_EPO_date: patent " + patent_no + " not found");
                 }
                continue;
              }
            }
            catch(error) {
              unprocessedList.push(patent_no);
              console.log("In parseEPOPatentData, error thrown: " + error.name + ": " + error.message);
              console.log("      Error parsing patent " + patent_no);
              console.log(epoPatent);
              continue;
            }
            var finalAssignee = finalAssigneeList.join(", ");
            var shortAssignee = shortAssigneeList.sort().join(" ");
            var finalInventor = inventorList.join(", ");
            epoBiblio[patent_no] = {};                                          // add the patent to the epoBiblio list
            epoBiblio[patent_no]["title"] = (inventionTitle == "") ? "Title not available" : inventionTitle;
            epoBiblio[patent_no]["abstract"] = (abstractText == "") ? "Not available" : abstractText;
            epoBiblio[patent_no]["pub_date"] = (pubDate == "") ? "N/A" : pubDate;
            epoBiblio[patent_no]["assignee"] = (finalAssignee == "") ? "Assignee not available" : finalAssignee;
            epoBiblio[patent_no]["shortAssignee"] = (shortAssignee == "") ? "Not available": shortAssignee;
            epoBiblio[patent_no]["inventors"] = (finalInventor == "") ? "Inventors not available" : finalInventor;
            epoBiblio[patent_no]["file_date"] = fileDate;
            processedList.push(patent_no);                                      // add to list of patents successfully processed
            console.log("In parseEPOPatentData: parsed patent " + patent_no);
            console.log(epoPatent);
          }
          console.log("In parseEPOPatentData, " + processedList.length + " successfully parsed patents:");
          console.log(processedList);
          console.log("                    " + unprocessedList.length + " patents not parsed:");
          console.log(unprocessedList);
          console.log("                    " + dupList.length + " patents were duplicates (between cited/citing and related lists?) or US_B pre-2001:");
          console.log(dupList);
          console.log("US applications not found due to querying as both utility and plant applications: " + USApplicationCount);
          console.log("                    " + notFoundList.length + " patents not found:");
          console.log(notFoundList);
          return processedList;                             // successfully parsed data returned from EPO API
        }
        else {                                              // got error message
          console.log("In parseEPOPatentData, error getting EPO patent data:");
          console.log(epoJSON);
          return false;                                     // failed to parse data returned from EPO API
        }
      }

      function getEPOPatentData(epoPatList, on_success) {
      // get bibliographic data for the patents listed in epoPatList from the EPO API; epoPatList is a
      // string (,patent1,patent2,...); on_success is the callback function, called as on_success(data), with
      // data in JSON form.
        if (epoPatList != "") {
          console.log("In getEPOPatentData, patent query list is: ", epoPatList);
          $.ajax({ type: "POST",
                   url: "/epoapi/biblio/",
                   contentType: "application/x-www-form-urlencoded; charset=UTF-8",    // this is default
                   // Request Body is ,patent1,patent2,...; CacheKey is refs_patent+epoPatList to ask server to pull
                   // data from cache if it exists
                   data: {"Request Body": epoPatList, "CacheKey": "refs_" + CryptoJS.MD5(epoPatList)},
                   dataType: "json",
                   success: on_success,
                   error: function(req, status, error) {
                            console.log("In getEPOPatentData, error returned from POST request");
                            console.log(status);
                            console.log(error);}
                 });
        }
      }

      function checkGooglePatent(patent_url, on_head_request_complete) {
      // make a HEAD request to Google for /patents/patent_no to find out if it has data for patent_no;
      // if patent_url is valid, call callback on_head_request_complete with object containing the data and the textStatus
      // if server returns an error, callback with object containing the jqXHR object and the errorThrown message.
        $.ajax({ type: "HEAD",
                 url: patent_url,
                 contentType: "application/x-www-form-urlencoded; charset=UTF-8",    // this is default
                 success: function(data, textStatus, jqXHR) {
                            on_head_request_complete({data:data, status: textStatus});
                          },
                 error: function(jqXHR, textStatus, errorThrown) {
                          console.log("In checkGooglePatent, error returned from HEAD request" + errorThrown, jqXHR);
                          on_head_request_complete({status: textStatus, error: errorThrown});
                        }
               });
      }

      function addEPOPatentDataToForceMap(source_patent, processedList, epoQueryLists, iList) {
        // epoQueryLists is a list of objects containing keys "list" (the query list), "type" (cited, citing, related)
        // and "done" (track when the query completes); one object for each query POSTed;
        // iList is the process number that just finished; processList is a list of patents in EPO format
        // that were successfully parsed and for which biblio data exists in epoBiblio; source_patent is the
        // patent at the focus of the forcePatent diagram.
        epoQueryLists[iList]["done"] = "true";                               // the iList list has been queried and processed
        console.log("In addEPOPatentDataToForceMap, retrieved biblio data for the following patents");
        console.log(processedList);
        var type = epoQueryLists[iList]["type"];
        var $sourceContainer = $mappedList          // get appropriate jQuery element for source_patent in the Mapped patent list
                           .find("div.patent-list-entry[data-patent='" + source_patent + "'] div.patent-list-patent-container");
        for (var i = 0; i < processedList.length; i++) {                     // add to the forcePatent and forceBiblio maps
          var target_patent = processedList[i];
          addTargetPatentToForceMap(source_patent, target_patent, type, "new");
          addTargetPatentToMappedSublist($sourceContainer, source_patent, target_patent, type, false); 
        }
      }

      function addSourcePatentToForceMap(patent_no, page_type, context) {
      // create a source node for patent_no on the forcePatent and forceBiblio maps; context is the context in which
      // the function is called ('new', 'undo_delete', or 'undo_clear'); called from processSourcePatent and
      // undeletePatent.
        if (!patentsHistory[patent_no]) {                // if not already on the forcePatent and forceBiblio maps at some point
          createForceNode(true, patent_no);              // use 'true' for a source node
        }
        else {                                           // make sure we use biblio from patentBiblio (has references lists)
          updateForceNode(true, patent_no);
        }
        // if source patent not already currently plotted as either a source patent or a target patent,
        // update data lists for force map plotting; re-plot if patent has previously been deleted
        patentLists["map"].push(patent_no);
        if (!patentsPlotted[patent_no]) {
          addPatentToPlottingLists(patent_no);            // update the data lists for force map plotting
        }
        else {                                            // node already exists as a target; change the marker to the source type
          var marker = d3.select("g.force-patent-marker[data-patent=" + patent_no + "]");
          updateMarkerOnForceMap(marker, page_type);
        }
        switch (context) {
          case "new", "undo_clear":
            updateClearedLists(patent_no, "map");
            break;
        }
      }

      function updateClearedLists(patent_no, list) {
      // update patentLists cleared lists now that patent_no is plotted; list is 'map' or 'target'; note that patent_no can be
      // mapped by clicking a map button, from the buttons at the top of the force map, or as a result of being
      // undeleted; called from addSourcePatentToForceMap and addTargetPatentToForceMap.
        var cleared = patentLists["cleared"];
        // if patent_no is mapped from the buttons at the top of the force map, or if an undoClear is being executed,
        // need to check the cleared lists and delete from any in which it appears.
        var ind = cleared[list].indexOf(patent_no);
        if (ind != -1) {
          cleared[list].splice(ind, 1);
        }
        var allEmpty = true;
        for (list in cleared) {
          if (cleared[list].length > 0) {
            allEmpty = false;
          }
        }
        if (allEmpty && patentLists["clearFlag"]) {       // nothing left to un-Clear
          patentLists["clearFlag"] = false;
        }
      }

      function addTargetPatentToForceMap(source_patent, patent_no, type, context) {
      // add patent patent_no as a target patent and create a link between source_patent and patent_no if one does
      // not exist; if patent_no has not been deleted, plot the target patent if not already plotted, and plot the
      // link to source patent on the forcePatent and forceBiblio maps; link 'type' is "cited", "citing", "related",
      // or ""; 'context' is the context in which the function is called ('new', 'undo_delete', or 'undo_clear').
      // if 'source_patent' and 'type' are passed as "", a new link is not added; source_patent and all existing links are plotted;
      //
      // links are only added and possibly plotted when processing
      // target patents since every link is between a patent target and a patent source;
      // source_patent is the patent that is currently being mapped; note that the target patent can have links to more
      // than one source patent; all links to be plotted must be added to the patentLinks list of links attached to the force map
      // biblio data for patent_no must exist in patentBiblio or epoBiblio.
      // called from addEPOPatentDataToForceMap, undeletePatent, addFavoritePatent, and mapExistingTargetPatents,
        if (!patentsHistory[patent_no]) {                // if not already on the forcePatent and forceBiblio maps at some point
          createForceNode(false, patent_no);             // use 'false' for a target node
        }
        // if target patent not already currently plotted as either a source patent or a target patent, and if patent has not
        // already been deleted, update data lists for force map plotting
        switch (context) {
          case "new":
            if (!patentsPlotted[patent_no] && patentLists["deleted"].indexOf(patent_no) == -1) {
              addPatentToPlottingLists(patent_no);
            }
            break;
          case "undo_delete": case "undo_clear":
            if (!patentsPlotted[patent_no]) {
              addPatentToPlottingLists(patent_no);
            }
            break;
        }
        if (source_patent != "") {                       // if we have a specific source patent
        // note: patent_no might be in deleted list already; it will not be plotted, but we might still need to create
        // a link to a newly mapped source_patent; we would not plot the link in this case.
          var patentNode = patentsHistory[patent_no];
          var link_key = source_patent + patent_no + type;
          // check if need to create a link between patent_no and source_patent, and create if not already present
          if (!(link_key in patentNode.sourcePatentLinks)) {
            createForceLink(source_patent, patent_no, type, link_key);  // one of two places where links are created
          }
          if (patentsPlotted[patent_no]) {                       // plot link only if patent itself will be plotted
            var link = patentNode.sourcePatentLinks[link_key];
            addLinkToPlottingList(link);                         // this is one of two places where links are queued for plotting
          }
        }
        // re-plot links to all source patents that are on the force map (case called from undeletePatent and addFavoritePatent).
        else {
          var patentNode = patentsPlotted[patent_no];
          if (patentNode) {                                      // should always be true
            for (link_key in patentNode.sourcePatentLinks) {                   // check links from patentNode as target to
              var sourceLink = patentNode.sourcePatentLinks[link_key];         // each source patent; if source patent is plotted
              var sourcePat = sourceLink.source.patent_no;
              if (patentLists["map"].indexOf(sourcePat) != -1) {               // if source is mapped, add link to list to plot
                addLinkToPlottingList(sourceLink);       // this is one of two places where links are queued for plotting
              }
            } 
          }
        }
        switch (context) { 
          case "undo_clear":
            updateClearedLists(patent_no, "target");
            break;
        }
      }

      function createForceLink(source_patent, target_patent, type, link_key) {
      // creates a new force link between patent_no source_patent and patent_no target_patent with the key link_key;
      // called from addTargetPatentToForceMap and checkDataForPatents
        var targetNode = patentsHistory[target_patent];            // use patentsHistory instead of patentsPlotted
        var sourceNode = patentsHistory[source_patent];            // because need to create links to deleted patents also
        var link = new PatentLink(sourceNode, targetNode, type, link_key);  // the only place where new links are created
        // need ordered list of link_keys to preserve legend colors when deleting and undeleting patents
        sourceNode.targetPatentLinksList.push(link_key);
        sourceNode.targetPatentLinks[link_key] = link;             // link from sourceNode to a target patent
        targetNode.sourcePatentLinks[link_key] = link;             // link from patentNode to a source patent
      }

      function createForceNode(source, patent_no) {
      // create PatentNode, BiblioNode, and BiblioLink data objects and push to the respective lists for the
      // forcePatent and forceBiblio maps; source is a boolean specifying whether the node is a source node (true)
      // or target node (false); called from addSourcePatentToForceMap and addTargetPatentToForceMap
        var biblio = (source) ? patentBiblio[patent_no] : epoBiblio[patent_no];
        var patentNode = new PatentNode(patent_no, source, biblio);               // create a new patentNode
        var biblioNode = new BiblioNode(patent_no, biblio);                       // create a new biblioNode
        var biblioLink = new BiblioLink(patent_no, patentNode, biblioNode)        // create a new biblioLink
        patentNode.biblioNode = biblioNode;                                       // each object references the other
        patentNode.biblioLink = biblioLink;
        biblioNode.patentNode = patentNode;
        biblioNode.biblioLink = biblioLink;
        patentsHistory[patent_no] = patentNode;
      }

      function updateForceNode(source, patent_no) {
      // patent_no is assumed to exist in patentsHistory; update the biblio in patentNode and biblioNode associated with
      // patent_no according to whether patent_no is a source patent
        var useBiblio = (source) ? patentBiblio[patent_no] : epoBiblio[patent_no];
        var patentNode = patentsHistory[patent_no];
        if (source) {
          // do not just substitute useBiblio for the patentNode biblio because assignee names can be different between
          // Google and EPO; it will screw up the legend if patent_no is already on it and the assignee name changes.
          patentNode.biblio.cited_patents = useBiblio.cited_patents;
          patentNode.biblio.citing_patents = useBiblio.citing_patents;
          patentNode.biblio.related_patents = useBiblio.related_patents;
          patentNode.source = source;
        }
      }

      function addLinkToPlottingList(link) {
      // adds link to patentLinks so it will be plotted during the next updateForceMap() call
      // patentLinks is the list of data for the forcePatent force map; called from addPatentToPlottingLists
      // (for links that were created, deleted and now need to be replotted) and addTargetPatentToForceMap
      // (for newly created links being plotted for the first time).
        patentLinks.push(link);
        link.source.plotLinks += 1;
        link.target.plotLinks += 1;
      }

      function addPatentToPlottingLists(patent_no) {
      // called from addSourcePatentToForceMap and addTargetPatentToForceMap
        var patentNode = patentsHistory[patent_no];
        patentsPlotted[patent_no] = patentNode;                            // patent_no can only appear on one tracking list
        // delete patent_no from the other tracking lists; (does not throw an error if patent_no is not in any of them).
        delete patentsUnplotted[patent_no];
        removePatentFromDeletedList(patent_no);                            // only place where patent is removed from deleted list
        addToLegend(patentNode);                                           // add to the legend
        patentNodes.push(patentNode);                                      // add to patent node list for plotting
        biblioNodes.push(patentNode.biblioNode);                           // add to biblio node list for plotting
        biblioLinks.push(patentNode.biblioLink);                           // add to biblio link list for plotting
      }

        function createHTMLSummaryTable(scriptName, searchTerms) {
        // populates the html template defined in scriptName with a table of searchTerms
          var tableTemplateVars = TableTemplateVars();
          var dateInfo = {};
          var inputName = '', entryName = '', entryValue = '';
          var maxChar = 25;
          var tableEntry = 0;
          searchTerms.forEach( function(inputField) {
            inputName = inputField["name"];
            if (formFields[inputName]) {                                        // there are some input fields we have not defined in formFields
              entryName = formFields[inputName];
              entryValue = inputField["value"];
              switch (entryName) {
                case "All of: ": case "Exactly: ": case "At least one: ": case "None of: ": case "Patent: ": case "Title: ": case "Inventor: ": case "Assignee: ":
                case "US class: ": case "Intl class: ": case "Coop class: ":
                  if (entryValue != "") {
                    tableEntry += 1;
                    tableTemplateVars["t"+tableEntry] = entryName;
                    tableTemplateVars["v"+tableEntry] = entryValue;           // no need to truncate long strings; CSS of the class .vcell takes care of it!
                  }
                  break;
                case "Type: ": case "ChkBoxPatDateOptions": case "MinMonth": case "MinYear": case "MaxMonth": case "MaxYear": case "Restrict by":
                  dateInfo[entryName] = entryValue;                             // need to store these values and process them separately
                  break;
              }
            };
          });

          tableEntry = 4*Math.ceil(tableEntry/4);                            // round to nearest multiple of 4
          tableEntry += 1;
          tableTemplateVars["t"+tableEntry] = "Type: ";                      // put in the last column in the table
          tableTemplateVars["v"+tableEntry] = typeValues[dateInfo["Type: "]];
          if (dateInfo["ChkBoxPatDateOptions"] == 'q') {                      // no restriction on date
            tableEntry += 1;
            tableTemplateVars["t"+tableEntry] = "Date: ";
            tableTemplateVars["v"+tableEntry] = "Any";
          }
          else {                                                                // process the date restrictions
            tableEntry += 1;
            tableTemplateVars["t"+tableEntry] = "Start date: ";
            if (dateInfo["MinYear"] == "") {
              tableTemplateVars["v"+tableEntry] = "Any";
            }
            else {
              tableTemplateVars["v"+tableEntry] = monthValues[dateInfo["MinMonth"]] + dateInfo["MinYear"];
            }
            tableEntry += 1;
            tableTemplateVars["t"+tableEntry] = "End date: ";
            if (dateInfo["MaxYear"] == "") {
              tableTemplateVars["v"+tableEntry] = "Any";
            }
            else {
              tableTemplateVars["v"+tableEntry] = monthValues[dateInfo["MaxMonth"]] + dateInfo["MaxYear"];
            }
            tableEntry += 1;
            tableTemplateVars["t"+tableEntry] = "Restrict by: ";
            tableTemplateVars["v"+tableEntry] = restrictByValues[dateInfo["Restrict by"]];
          };

          return _.template( $(scriptName).html(), tableTemplateVars);
        }

        function on_tab_shown(event) {
          var $clickedTab = $(event.target);
          if ($clickedTab.data('bs.popover')) {
            $clickedTab.popover('hide');              // was already hovering before the click; make it disappear
            $clickedTab.popover('disable');           // prevent it from popping up again
          }
          if (event.relatedTarget) {
            var $previousTab = $(event.relatedTarget);
            if ($previousTab.data('bs.popover')) {
              $previousTab.popover('enable');
              var tab_id = $previousTab.attr("id");
              if (tab_id.slice(0,10) == 'relatedTab') {         // update the popover content of a related tab
                updateRelatedTabPopover($previousTab);
              }  
            }
          }
        }

      function on_click_map_buttons(event) {
      // click event handler for the 'map' and 'favorite' buttons
      // event.data stores the jQuery context of the element that generated the event in .$context, and the type of page the button in .page
      // on a patent page, $context is the main html document
      // on the search results and related patents pages, $context is the document in the iframe
        event.preventDefault();
        event.stopPropagation();
        var $context = event.data.$context;
        var page_type = event.data.page;                    // button was clicked on page type page_type
        var pressedButton = $(event.target, $context);
        var patent_info = getPatentURL_No(event.currentTarget, event.data.$context, page_type);
        var patent_no = patent_info.patent_no;
        var patList = pressedButton.hasClass("btn-map-add") ?
                                                        "map": (pressedButton.hasClass("btn-favorite-add") ? "favorites": "");
        if (pressedButton.hasClass("show-result-btn")) {    // remove patent
          switch (patList) {
            case "favorites":
              removePatentFromFavorites(patent_no, pressedButton, page_type);
              break;
            case "map":
              removePatentFromMapped(patent_no, pressedButton, page_type);
              break;
          }
console.log("Remove");
console.log(patentLists);
console.log(patentBiblio);
        }
        else {                                              // add patent
          toggleBtn(patent_no, pressedButton, "add");       // toggle appearance of button
console.log("patentLists");
console.log(patentLists);
          switch (patList) {
            case "favorites":
              addFavoritePatent(patent_no, page_type);
              break;
            case "map":
              addMapPatent(patent_no, page_type, on_mapping_complete);
              break;
          }
        }

        function on_mapping_complete() {
          // expect last action is to enable Clear button, but call with no argument so button state is determined
          // by whether patentsPlotted contains any patents
console.log("In on_mapping_complete: ", patentsPlotted);
          setUndoButtonState();
          setClearButtonState();
        }
      }

      function addFavoritePatent(patent_no, page_type) {
      // add patent_no to the favorites list; page_type provide context for page where favorites button was clicked.
      // called from on_click_map_buttons
        if (!(patent_no in favoriteBiblio)) {
console.log("Do not have " + patent_no + " in favoriteBiblio");
          getFavoriteBiblioData(patent_no, plotFavoritePatent);   // addFavoritePatent is the callback
        }
        else {
console.log("Have " + patent_no + " in favoriteBiblio");
          plotFavoritePatent();
        }

        function getFavoriteBiblioData(patent_no, on_favorite_biblio_complete) {
        // create an entry in favoriteBiblio for patent_no; check patentBiblio and epoBiblio first; then query Google
        // related patent if necessary; callback on_favorite_biblio_complete when done; called from on_click_map_buttons.
          favoriteBiblio[patent_no] = {}              // favoriteBiblio does not have citation or related patent lists
          var existingBiblio = (patentBiblio[patent_no]) ? patentBiblio[patent_no] : epoBiblio[patent_no];
          if (existingBiblio) {
            favoriteBiblio[patent_no]["title"] = existingBiblio["title"];
            favoriteBiblio[patent_no]["file_date"] = existingBiblio["file_date"];
            favoriteBiblio[patent_no]["pub_date"] = existingBiblio["pub_date"];
            favoriteBiblio[patent_no]["inventors"] = existingBiblio["inventors"];
            favoriteBiblio[patent_no]["assignee"] = existingBiblio["assignee"];
            on_favorite_biblio_complete();
          }
          else {                                      // need to run a query on Google /patents/related
            taskTracker.initialize("Fetching", undefined);
            taskTracker.startTask(1);
            getQuickBiblioData(patent_no, on_quick_favorite_biblio_data);  // on_quick_favorite_biblio_data is the callback
          }

          function on_quick_favorite_biblio_data(data) {
          // extract the biblio information from the data returned by the metadata query; for Favorites List
            favoriteBiblio[patent_no]["title"] = (data[1]) ? data[1] : "Title not available";
            // dates come back as a list of integers [year, month, day]; need to convert to "YYYYMMDD" format for makeGoogleDate
            var pub_date =                                         // only issued US patents have data for the published date
                    (data[7]) ? makeGoogleDate(data[7][0] + ("0" + data[7][1]).slice(-2) + ("0" + data[7][2]).slice(-2)) : "N/A";
            favoriteBiblio[patent_no]["pub_date"] = pub_date;
            favoriteBiblio[patent_no]["file_date"] =               // early US patents do not have a file data; use pub_date instead
                    (data[6]) ? makeGoogleDate(data[6][0] + ("0" + data[6][1]).slice(-2) + ("0" + data[6][2]).slice(-2)) : 
                    ((data[7]) ? pub_date : "");
            var inventorList = data[11].join(", ");
            var assigneeList = data[12].join(", ");
            favoriteBiblio[patent_no]["inventors"] = (inventorList == "") ? "Inventors not available" : inventorList;
            favoriteBiblio[patent_no]["assignee"] = (assigneeList == "") ? "Assignee not available" : assigneeList;
            on_favorite_data_complete();
          }

          function on_favorite_data_complete() {
          // update the favorites list on the Map tab; called from on_quick_favorite_biblio_data.
            taskTracker.finishTask(1);
            console.log("In getFavoriteBiblioData, for " + patent_no + ", got favorite biblio data: ", favoriteBiblio[patent_no]);
            on_favorite_biblio_complete();
          }
        }

        function plotFavoritePatent() {
        // execute all steps necessary to add a patent to the Favorites list on the Map page; favoritesBiblio must already
        // have an entry for patent_no; patent_no is in the scope of the containing function; called from
        // addFavoritePatent, either directly or as callback for getFavoriteBiblioData.
          patentLists["favorites"].push(patent_no);               // add to "favorite" list
          var patentNode = (patentsHistory[patent_no] && !patentsPlotted[patent_no]) ? patentsHistory[patent_no]: {};
          if (patentNode) {                                       // patent was plotted, but then unplotted or deleted
            for (link in patentNode.sourcePatentLinks) {
              var linkToSourcePatent = patentNode.sourcePatentLinks[link];
              var source_patent = linkToSourcePatent.source.patent_no;
              if (patentLists["map"].indexOf(source_patent) != -1) {     // if any source_patent is currently mapped and
                if (patentLists["deleted"].indexOf(patent_no) != -1) {   // if patent_no was deleted as some point, then replot
                  // could have been deleted as a mapped patent, but always re-plot a Favorite patent as a target patent
                  patentNode.source = false;
                  // recreate patent_no and links to plotted source patents on force map
                  addTargetPatentToForceMap("", patent_no, "", "undo_delete");
                  setUndoBUttonState();
                  break;
                }
              }
            }
            remakeDeletedCitationListEntries(patent_no, patentNode);
          }
          if (patentsPlotted[patent_no]) {              // if the patent is on the force map
            var marker = d3.select("g.force-patent-marker[data-patent=" + patent_no + "]");
            updateMarkerOnForceMap(marker, page_type);
          }
          addFavoritePatentToFavoritesList(patent_no);  // add entry in Favorites list (takes care of showing delete button)
        }

        function addFavoritePatentToFavoritesList(patent_no) {
        // create an entry for patent_no in the Favorites patents list on the Mapped page; uses global variables
        // $favoritesList and favoriteBiblio
          var patentObj = favoriteBiblio[patent_no];
          var patentEntryHTML = compiledFavoritesListEntryTemplate({"patent_no": patent_no});
          $favoritesList.find("div.patent-list-patents").prepend(patentEntryHTML);   // add to beginning of list
          var $patentContainer = $favoritesList
                                 .find("div.patent-list-entry[data-patent='" + patent_no + "'] div.patent-list-patent-container");
          var patentSectionHTML = compiledPatentListBiblioTemplate(
                                  {"patent_no": patent_no, "patent_label": makePatentLabel(patent_no),"source_patent": patent_no,
                                   "title": patentObj["title"], "file_date": patentObj["file_date"]});
          $patentContainer.append(patentSectionHTML);
          // add event handlers for Map and Fav buttons
          setupMapFavButtons($patentContainer, document, "favorites-list", patent_no);
          setupDeleteButton($patentContainer, patent_no);
          setupPatentLink($patentContainer, "favorites-list");
          setupPatentHighlight($patentContainer, patent_no, "favorites-list");
          setupPatentFullView($patentContainer, patent_no, "favorites-list");
        }
      }

      function addMapPatent(patent_no, page_type, on_mapping_complete) {
      // query biblio data for patent_no as the source patent and all the citing, citing, and related patents; page_type
      // indicates the context in which addMapPatent was called (either from the map or a patent list); add source and
      // target patents to force map; call the callback on_mapping_complete when done.
        if (patentLists["map"].indexOf(patent_no) == -1) {       // if patent not already mapped
          $("a[href='#Map']").click();                           // switch to the Map tab
          // if this is a new force map; clear out any previously Cleared patents; use underscore.js utility function
          if (_.isEmpty(patentsPlotted) && patentLists["deleted"].length == 0) {
            randomizeArray(legendColors);                        // get a new color scheme
            initializeClearedLists();
            initializeDeletedList();
          }
startTime = new Date();
console.log("Started mapping process");
          if (!(patent_no in patentBiblio)) {                    // if no bibliographic info
console.log("Do not have " + patent_no + " in patentBiblio");
            taskTracker.initialize("Fetching", undefined);
            patentBiblio[patent_no] = {};                        // create empty entry in patentBiblio for patent_no
            // to track status of the queries for patent data; used by callback on_patent_data_complete
            var status = {bibDone: false, relDone: false, expired: false};
            // get bibliographic info for the patent from the google patent page
            taskTracker.startTask(2);                            // start two queries
            var patentDocHTML = getPatentDocHTML(patent_no);
            if (patentDocHTML) {
              processPatentPage(patentDocHTML);
            }
            else {
              getGooglePatentHTML(patent_no, processPatentPage); // processPatentPage is the callback
            }
            // get the patents related to this one from a customized google related patents search
            getRelatedPatentList();                              // on_patent_data_complete is the callback
            var patentDataTimeout = setTimeout(function() {
                                                 status.expired = true;
                                                 on_patent_data_complete();
                                               }, 20000);    // 20 seconds
          }
          else {
console.log("Have " + patent_no + " in patentBiblio");
            // there is already an entry for patent_no in patentBiblio, so proceed with the mapping process
            mapSourcePatent();
          }
        }

        function getGooglePatentHTML(patent_no, on_get_google_patent) {
        // use jQuery to make GET request from Google for the patent page for patent_no; call callback on_get_google_patent
        // when done.
console.log("In getGooglePatentHTML, request data from Google for " + patent_no);
          var patent_url = "/patents/" + patent_no;
          $.get(patent_url, on_get_google_patent);
        }

        function getPatentDocHTML(patent_no) {
        // called from on_click_map_buttons; return the HTML document for patent patent_no (central patent on the
        // forcePatent map) if a tab for it already exists; otherwise return nothing.
          var $aTab = $("a[data-tabname='" + patent_no + "']");             // if patent tab for this patent already
          if ($aTab.length > 0) {                                           // exists return the HTML document
            var div_id = $aTab.attr("href");
console.log("In getPatentDocHTML, tab for patent " + patent_no + " is already open");
            return $("div" + div_id + " > iframe").contents();
          }
          return undefined;                                                 // do not have tab for this patent
        }

        function on_patent_data_complete() {
        // callback for processPatentPage and getRelatedPatentList; patentBiblio now has a complete entry for patent_no
        // (unless queries took too much time); status is in scope of containing function on_click_map_buttons; it is
        // an object containing the status of each callback.
console.log("In on_patent_data_complete: getting data for patent " + patent_no);
console.log("Status: ", status);
          if (!status["expired"]) {
            taskTracker.finishTask(1);
            if (status["bibDone"] && status["relDone"]) {
              console.log("In on_patent_data_complete, added entry for " + patent_no + " to patentBibio");
              clearTimeout(patentDataTimeout);
              window.setTimeout(mapSourcePatent, 500);  // short delay to allow status update
            }
          }
          else {
            console.log("Too much time waiting for data in on_patent_data_complete. Bib info: ", status);
          }
        }

        function mapSourcePatent() {
        // called from on_patent_data_complete and on_click_map_buttons; finish mapping the source patent (patent
        // whose 'map' button was clicked; then continue with steps to map the patents referenced to the source patent
          console.log(patentLists);
          console.log(patentBiblio);
          console.log("Starting to assemble data for mapping at " + (new Date() - startTime)/1000);
          processSourcePatent();
          mapReferencePatents();
        }

        function processSourcePatent() {
        // called from mapSourcePatent.
            addSourcePatentToForceMap(patent_no, page_type, "new");         // page_type in scope of addMapPatent
            addSourcePatentToMappedList(patent_no);
console.log("Adding the source node to the force map");
            updateForceMap();                        // add the source patent to the forcePatent and forceBiblio maps
        }

        function mapReferencePatents() {
        // called from mapSourcePatent; create lists of cited, citing, and related patents; query the EPO database to
        // get the biblio data; process the data; and map the patents
          // checkDataForPatents checks if we already have biblio data and a link in the patentNode for patent_no for
          // each reference patent in the list; if so, we are set to map the reference; if not, we add a link if needed or
          // or add to a list of patents we need to query biblio data for; returns the list of patents for querying
          var citedListToQuery = checkDataForPatents(patent_no, patentBiblio[patent_no]["cited_patents"], "cited");
          var citingListToQuery = checkDataForPatents(patent_no, patentBiblio[patent_no]["citing_patents"], "citing");
          var relatedListToQuery = checkDataForPatents(patent_no, patentBiblio[patent_no]["related_patents"], "related");
          // add target patents that we already have epoBiblio data for to the forcePatent and forceBiblio maps
          // add to appropriate list of patent references under patent_no in the Mapped List on the Map page;
          mapExistingTargetPatents(patent_no, mapNewTargetPatents);

          function mapNewTargetPatents() {
            var epoQueryLists = makeAllQueryLists(patent_no, citedListToQuery, citingListToQuery, relatedListToQuery);
console.log(epoQueryLists);
            if (epoQueryLists.length > 0) {
              taskTracker.initialize("Fetching", on_mapping_complete);
              taskTracker.startTask(epoQueryLists.length);
            }
            else {
              on_mapping_complete();
            }
            for (var iList = 0; iList < epoQueryLists.length; iList++) {
            // get and process patent bibliographic data from the EPO API; epoQueryLists is a list of objects produced by
            // makeQueryLists, containing keys "list" which is a string (,patent1,patent2,...), "type" which is the type of
            // patents (cited, citing, or related), and "done", which tracks whether the EPO query has completed.

              (function(iL) {
               // need self-executing function called for each value of iList, so iList can be passed on to subsequent
               // function calls
                 var epoPatList = epoQueryLists[iL]["list"];
                 // query the EPO API
                 getEPOPatentData(epoPatList, on_EPO_query_success); // on_EPO_query_success is the callback for getEPOPatentData

                 function on_EPO_query_success(data) {
                 // called from epoQueryLists if EPO query is successful and returns 'data' in JSON; parse the JSON for biblio info
                 // patent_no, epoQueryLists, iList are defined in the containing scope
                   var processedList = parseEPOPatentData(data);
                   if (processedList) {
                     addEPOPatentDataToForceMap(patent_no, processedList, epoQueryLists, iL);
                     console.log("Adding queried EPO data for " + processedList.length + " " + 
                                  epoQueryLists[iL]["type"] + " patents to the force map");
                     updateForceMap();
                   }
                   taskTracker.finishTask(1);
                 }
               })(iList);
            }
          }
        }
/*
$.ajax({ type: "POST",
        url: "ops.epo.org/3.1/auth/accesstoken",
        headers: {"Authorization": "Basic xxxxxxx"},
        contentType: "application/x-www-form-urlencoded; charset=UTF-8",    // this is default
        data: {"grant_type": "client_credentials"},
        dataType: "json"
      });

$.ajax({ type: "GET",              // works with epodoc or docdb
        url: "https://ops.epo.org/3.1/rest-services/published-data/publication/epodoc/EP2337452.A2",
        headers: {"Authorization": "Bearer access_token",
                  "Accept": "application/json"},
        contentType: "application/x-www-form-urlencoded; charset=UTF-8",    // this is default
        dataType: "json"
      });

$.ajax({ type: "POST",             // bulk request only seems to work with epodoc
        url: "https://ops.epo.org/3.1/rest-services/published-data/publication/epodoc/biblio",
        headers: {"Authorization": "Bearer access_token",
                  "Accept": "application/json"},
        contentType: "application/x-www-form-urlencoded; charset=UTF-8",    // this is default
        data: {"Request Body" : ,doc1,doc2,doc3 comma or newline separated list of patent documents, must begin with a comma (max 100/request)},
        dataType: "json"
      });
*/

        function getRelatedPatentList() {
        // Get a list of patents related to patent_no using the Google related art service; update relDone in status
        // patent_no is in scope of containing function on_click_map_buttons 
        // Looked at Network requests in chrome developer tools and noticed that related patent data is fetched using
        // POST requests to /patents/related/rpc; a very convenient way to get the related patent numbers!!
        // Use chrome extension 'Postman' to debug the POST query
        // Get the metadata (info in the panel on the right side of a related patents page.
          $.ajax({ type: "POST",
                   url: "/patents/related/rpc",
                   headers: {"XmlHttpRequest": "2"},
                   contentType: "application/x-www-form-urlencoded; charset=UTF-8",    // this is default
                   data: {"m": "metadata",
                          "id": patent_no},
                   success: on_complete_related_metadata_post,
                   dataType: "json"
                 });

          function on_complete_related_metadata_post(data) {
          // in scope of getRelatedPatentList
          // extract top three search terms from the data returned by the metadata query;
          // get the patents related to patent_no, and using the search terms.
          // patent_no is in scope of containing function on_click_map_buttons 
            var searchTermsList = data[10][1];                   // the list of search terms that appears on the left side of a
            searchTerms = searchTermsList.slice(0,3).join(" ");  // related art page; concatenate the first 3 (like Google does)
            $.ajax({ type: "POST",
                     url: "/patents/related/rpc",
                     headers: {"XmlHttpRequest": "2"},
                     contentType: "application/x-www-form-urlencoded; charset=UTF-8",  // this is default
                     data: {"m": "search",
                           "q": searchTerms,
                           "c": "p",
                           "start": "",
                           "end": encodeURIComponent(dateString(new Date())),
                           "page": "0",
                           "pid": patent_no},
                    success: on_complete_related_patents_post,
                    dataType: "json"
                   });
          }

          function on_complete_related_patents_post(data) {
          // patent_no and status are in scope of containing function on_click_map_buttons 
          // extract the list of the related patents from the JSON
            patentBiblio[patent_no]["related_patents"] = [];
            var relatedList = data[5];
            for (var i = 0; i < relatedList.length; i++) {
              var related_patent_no = relatedList[i][7][0][0];
              patentBiblio[patent_no]["related_patents"].push(related_patent_no);
            }
            status["relDone"] = true;
            on_patent_data_complete();
          }
        }

        function dateString(newDate) {
        // return a date string 'mm/dd/yyyy' from Date object newDate
          var dayNow = newDate.getDate().toString();
          dayNow = dayNow.length < 2 ? "0" + dayNow : dayNow;
          var monthNow = (newDate.getMonth() + 1).toString();
          monthNow = monthNow.length < 2 ? "0" + monthNow : monthNow;
          var yearNow = newDate.getFullYear().toString();
          return monthNow + "/" + dayNow + "/" + yearNow
        }

        function processPatentPage(doc) {
        // doc is the document for a Google patent page; parse it for title, inventors, assignee, cited patents, and
        // citing patents; add the data to the patentObj object for the patent;
        // patent_no, on_patent_data_complete, and status are in the scope of the containing function on_click_map_buttons;
        // update bibDone in status and callback on_patent_data_complete when done.
          var $docBody = $(doc).select("body");
          $docBody.remove("div.patent-description-section");
          var patentObj = patentBiblio[patent_no];
          var tia = getTIA($docBody);                         // title, inventors, assignee in separate function, also used in setting up a patent tab
          var file_date = $("table.patent-bibdata td.patent-bibdata-heading:contains('Filing date') + td.single-patent-bibdata", $docBody).text();
          var pub_date = $("table.patent-bibdata td.patent-bibdata-heading:contains('Publication date') + td.single-patent-bibdata", $docBody).text();
          var abstract = $("div.abstract", $docBody).text();
          patentObj["title"] = (tia.title == "") ? "Title not available": tia.title;
          patentObj["inventors"] = (tia.inventors == "") ? "Inventors not available" : tia.inventors;
          patentObj["assignee"] = (tia.assignee == "") ? "Assignee not available" : tia.assignee;
          patentObj["shortAssignee"] = (tia.shortAssignee == "") ? "Not available" : tia.shortAssignee;
          patentObj["abstract"] = (abstract == "") ? "Not available" : abstract;
          patentObj["pub_date"] = (pub_date == "") ? "N/A" : pub_date;
          patentObj["file_date"] = (file_date == "") ? ((pub_date == "N/A") ? "" : pub_date) : file_date;
          var $cited = $("a#backward-citations ~ table.patent-data-table td.citation-patent a", $docBody);
          var cited_patents = new Array($cited.length);
          $cited.each(function(index) {cited_patents[index] = this.textContent;}); // $(this).text());});
          var $citing = $("a#forward-citations ~ table.patent-data-table td.citation-patent a", $docBody)
          var citing_patents = new Array($citing.length);
          $citing.each(function(index) {citing_patents[index] = this.textContent;}); // $(this).text());});
          patentObj["cited_patents"] = cited_patents;
          patentObj["citing_patents"] = citing_patents;
          status["bibDone"] = true;
          on_patent_data_complete();
        }

        function checkDataForPatents(source_patent, inList, type) {
        // check epoBiblio to see which patents in inList we have already queried EPO for biblio data;
        // add patents with data to the lists of nodes and links for the forcePatent and forceBiblio maps
        // with source_patent as its focus; add patents without data to the outList for querying EPO; return
        // a list outList of the patents for which there is no biblio data; $sourceContainer is the jQuery
        // element in the Mapped List on the Map page that contains the entry for source_patent.
          var outList = [];
          for (var i = 0; i < inList.length; i++) {
            var target_patent = inList[i];
            if (epoBiblio[target_patent]) {                   // if we already have EPO data for this patent
              var sourceNode = patentsHistory[source_patent];
              var link_key = source_patent + target_patent + type;
              if (!(link_key in sourceNode.targetPatentLinks)) {
                // biblio data exists for target_patent, but need to create link to this sourceNode
                createForceLink(source_patent, target_patent, type, link_key);   // one of two places where links are created
              }
            }
            else {
              outList.push(target_patent);
            }
          }
          return outList;
        }

        function makeQueryLists(inList, type) {
        // inList is a list of cited, citing, or related patents; split each into groups of 15 and return a list of objects
        // containing keys "list": subList of patents to query, "type" of the subList (cited, citing, or related), and
        // "done", which tracks whether the query has completed.

          var sizeList = 15;                                          // split patents in inList into subLists of 15
          var nList = Math.floor(inList.length/sizeList);
          var queryLists = [];
          for (var iList = 0; iList < nList; iList++) {
            var subList = inList.slice(iList*sizeList, (iList+1)*sizeList);
            queryLists.push({"list": makeEPOQueryList(subList), "type": type, "done": false});
          }
          if (nList*sizeList < inList.length) {                      // the elements at the end of inList
            var subList = inList.slice(nList*sizeList);
            queryLists.push({"list": makeEPOQueryList(subList), "type": type, "done": false});
          }
          return queryLists;
        }

        function makeAllQueryLists(source_patent, q_citedList, q_citingList, q_relatedList) {
        // source_patent is the central patent of the forcePatent and forceBiblio maps;
        // given arrays citedList, citingList, and relatedList, split each into arrays of length 15 for
        // querying EPO in small groups; send to makeEPOQueryList to make comma-separated strings; process
        // each list separately since we want to display the links with different colors on the force map
        // return a list of EPO query lists and associated type of list (cited, citing, etc).
          return [].concat(makeQueryLists(q_citedList, "cited"), makeQueryLists(q_citingList, "citing"),
                           makeQueryLists(q_relatedList, "related")); 
        }
      }

      function getQuickBiblioData(patent_no, on_complete_quick_metadata_post) {
      // called from on_click_map_buttons when do not have biblio data for a patent added to Favorites list
      // and from randomPatentPicker.tryRandomPatent when looking for a random patent;
      // get bibliographic data for patent_no for use in the favorites list or as a random patent using the Google
      // related art service goal is to get the data quickly, so do not get citing patent list, which requires
      // loading and parsing the full patent; on_complete_quick_metadata_post is the callback called when the POST
      // request returns with the data as the argument.
      // POST requests to /patents/related/rpc are a very convenient way to get the bibliographic info!!
      // Use chrome extension 'Postman' to debug the POST query
      // Get the metadata (info in the panel on the right side of a related patents page.
        $.ajax({ type: "POST",
                 url: "/patents/related/rpc",
                 headers: {"XmlHttpRequest": "2"},
                 contentType: "application/x-www-form-urlencoded; charset=UTF-8",    // this is default
                 data: {"m": "metadata",
                        "id": patent_no},
                 success: on_complete_quick_metadata_post,
                 dataType: "json"
               });
      }

      function makeEPOQueryList(patentList) {
      // given patentList list of patent publications as obtained from Google, return a string suitable for a bulk
      // POST query to the EPO API; the string is a list of comma-separated patent publication numbers that also
      // starts with a comma; publication numbers are formatted using formatEPOPatentNumber(patent_no) so EPO can
      // understand the request.
        var queryList = "";
        for (var i = 0; i < patentList.length; i++) {
          var patent_no = patentList[i];                           // Google format
          var formattedPN = formatEPOPatentNumber(patent_no);         // EPO query format
          if (formattedPN != "") {
            for (var iForm = 0; iForm < formattedPN.length; iForm++) {
              queryList = queryList + "," + formattedPN[iForm];
              var epo_patent_no = formattedPN[iForm].replace(/\./g, "");
              patentNoEPOtoGoogle[epo_patent_no] = patent_no;        // add to EPO to Google patent doc number dictionary
            }
          }
        }
        return queryList;
      }

      function formatEPOPatentNumber(patent_no) {
      // patent_no is a patent number as it appears in the cited patents sections on the Google patent page.
      // It is a string with the country code, publication prefix, publication number, postfix, and kind
      // and no spaces in between.  Returns a document ID string suitable for the EPO API.
      // US patent numbers start with various letters if they are not utility patents; older JP patent numbers
      // can start with a letter like H or S; called from makeEPOQueryList.

        // use global variable rExpPat = /([A-Z]{2})([A-Z]*)(\d+)([A-C,G]?(?=([A-Z]\d?)?$))/
        var match = rExpPat.exec(patent_no);
        if (match) {
          var cc = match[1]; var pub_type = match[2]; var pub_no = match[3]; var postfix = match[4]; var kind = match[5];
          var us_application_flag = false;                   // special handling needed for US applications (see below)
          var formattedList = [];
          switch (cc) {
            case "US":
              if (pub_no.length == 11 && pub_no[4] == "0") { // EPO API removes the leading zero of a US application publication
                pub_no = pub_no.slice(0,4) + pub_no.slice(5);
                us_application_flag = true;
              }
              switch (pub_type) {
                case "D":
                  pub_no = pub_no + "S";
                  break;
                case "PP":
                  pub_no = pub_no + "P";
                  pub_type = ""
                  break;
                case "RE":
                  pub_no = pub_no + "E";
                  break;
                default:
              }
              break;
            case "WO":
              intDoc = parseInt(pub_no.slice(4,10));               // get document number (six digits in Google format)
              intYear = parseInt(pub_no.slice(0,4));
              switch (true) {                                     // fix the document number
                case intYear <= 2002:
                  if (intDoc < 100000) {
                    pub_no = pub_no.slice(0,4) + pub_no.slice(5); // five-digit document number if <10000;
                  }
                  break;
              }
              switch (true) {                                     // fix the year
                case intYear <= 2003:                             // use two-digit year for years 2003 and previous
                  pub_no = pub_no.slice(2);
                  break;
              }
              break;
          }
          formattedList.push(cc + pub_type + pub_no + postfix + (kind ? "." + kind : ""));
          // Google does not distinguish between US utility applications and plant applications, but EPO does!
          // So need to query EPO with the application number (utility patent) and the application number with
          // 'P' appended (plant patent) if us_application_flag is set.
          if (us_application_flag) {
            formattedList.push(cc + pub_type + pub_no + postfix + "P" + (kind ? "." + kind : ""));
          }
          return formattedList;
        }
        else {
          console.log("In formatEPOPatentNumber, could not match '" + patent_no + "'. Skipping...");
          return '';
        }
      }

      function on_search_result_load(iframeElement, tab_id, htmlSearchTermsTable, htmlPopoverTable) {
        var $context = $(iframeElement).contents();
        process_links($context, "search");       // make google links point to my server
        process_search_result_contents($context, htmlSearchTermsTable);  // set up the search terms summary at the top of the page
        setupSearchTab(tab_id, htmlPopoverTable);            // set up the popover for the tab for this page
        $("a#" + tab_id).tab("show");
        window.scrollTo(0,0);
      }

      function on_more_result_load(iframeElement, htmlSearchTermsTable) {
        var $context = $(iframeElement).contents();
        process_links($context, "search");
        process_search_result_contents($context, htmlSearchTermsTable);
        // htmlSearchTermsTable has been cloned from the original search page; popover has already been attached to the tab
      }

      function process_links($context, page_type) {
        $("a", $context).each(function() {                   // for each link on the page
          var orig_url = $(this).attr("href");
          if (orig_url) {
            if (external_URLs.some( function(external_URL) {return orig_url.search(external_URL) >= 0 ? true : false;})) {
              $(this).on("click", on_click_external);                // open these links in a new browser tab
            }
            else {
              var strip_url = orig_url.replace('https', 'http');
              strip_url = strip_url.replace('http://www.google.com', '');  // open these links as relative to my site
              $(this).attr("href", strip_url);
              var rExp = /\/[^\?/]*[\?/]/;
              var link_match = rExp.exec(strip_url);
              var link_type = (link_match) ? link_match[0] : '';
              switch (link_type) {
                case "/patents/":
                  $(this).removeAttr("onmousedown");
                  if (strip_url.search('/patents/related') >= 0) {
                    // when search page loads, 'related' url starts with /patents/related
                    $(this).on("click", {$context: $context, page: page_type}, on_click_new_related_url);
                  }
                  else {
                    // patent link on search or patent page, except for Grant, Application, and Also Published As which
                    // have their own click handlers because we want to display them in the same tab as the original patent
                    $(this).on("click", {$context: $context, page: page_type}, on_click_new_patent_url);
                  }
                  break;
                case "/search?":
                  if (strip_url.search('&start=') >= 0) {
                    $(this).on("click", on_click_more_search_result); // more search results from same page; do not open new tab
                  }
                  else {
                    $(this).on("click", on_click_new_search_url);     // search link on search page or patent page; open new tab
                  }
                  break;
                case "/url?":
                  if (strip_url.search('/www.google.com/patents/') >= 0) {
                    // patent link on prior art page; fetches patent as query after /url?
                    $(this).on("click", {$context: $context, page: page_type}, on_click_new_patent_url);
                  }
                  else {                            // this branch should never be called since the 'related' link on a search page
                    // is processed when the page loads; after mousedown, url changes, starts with /url?
                    $(this).on("click", {$context: $context, page: page_type}, on_click_new_related_url);
                  }
                  break;
                default:
                // there are other types of links as well which are not visible on the page
              }
            }
          };
        });
      }

      function on_click_new_related_url(event) {
        event.preventDefault();
        event.stopPropagation();
        var related_url = $(this).attr("href");
        var patent_info = getPatentURL_No(event.currentTarget, event.data.$context, event.data.page);
        var $aTab = $("a[data-tabname='Re-" + patent_info.patent_no + "']");    // check if the related tab for this patent already exists
        if ($aTab.length == 0) {
          // add '#c=p' suffix to load patents only; otherwise need to simulate a click on the Patents option at the
          // top of the page.
          make_related_tab(related_url + "#c=p");
        }
        else {
          $aTab.click();
        }
      }

      function on_click_new_patent_url(event) {
        // patent url's can be clicked on map, search, related (as a related patent or as the root patent), or patent pages
        // event.data.$context stores the jQuery context of the element that triggered the event
        // event.data.page stores the type of page the link was clicked on
        event.preventDefault();
        event.stopPropagation();
console.log("Here new patent");
        var patent_info = getPatentURL_No(event.currentTarget, event.data.$context, event.data.page);
        var patentLabel = makePatentLabel(patent_info.patent_no);  // label for patent tab is patent_no without the kind code
        patentTab(patent_info.patent_url, patentLabel, undefined);
      }

      function patentTab(patent_url, patentLabel, on_patent_tab_complete) {
      // check if a tab for patentLabel exists; if not, query Google at patent_url and create it; call optional callback
      // on_patent_tab_complete when done
        var $aTab = $("a[data-tabname='" + patentLabel + "']");    // check if patent tab for this patent already exists
        if ($aTab.length == 0) {
          make_patent_tab(patent_url, patentLabel);
        }
        else {
          $aTab.click();
          if (on_patent_tab_complete) {
            var patent_no = $aTab.attr("data-patent");
            on_patent_tab_complete(patent_no);
          }
        }

        function make_patent_tab(patent_url, patentLabel) {
        // add HTML for the new patent tab and label it with patentLabel; set up the iframe and load it with the Google
        // patent document at patent_url.
          nPatentTabs += 1;
          var tab_id = "patTab_" + nPatentTabs;
          var tab_content_id = "patent_" + nPatentTabs;
          var iframe_id = "gps_patent_" + nPatentTabs;
          var navTabHTML = _.template( $("script#bs_nav-tab").html(),
                                       {tab_id: tab_id, tab_content_id: tab_content_id, tab_name: patentLabel});
          var tabContentHTML = _.template( $("script#bs_tab-pane").html(),
            {tab_content_id: tab_content_id, iframe_id: iframe_id, iframe_width: 1050, iframe_height: 700});
          var tabButtonHTML = $("script#tab-buttons").html();
          $("div.tab-pane.active").after(tabContentHTML);
          $("ul#topTabs li.active").after(navTabHTML);
          var aTab = $("a#" + tab_id);
          aTab.append(tabButtonHTML);                          // add the map and favorite buttons
          $("iframe#" + iframe_id).on("load", function() {on_patent_load(this, tab_id);})
                                  .on("error", function(event) {on_patent_load_error(this, tab_id, event);});
          $("iframe#" + iframe_id).attr("src", patent_url);
        }

        function on_patent_load_error(iframeElement, tab_id, event) {
        // error handler if iframe does not load due to bad Google patent link
          console.log("In on_patent_load_error, error event is ", event);
        }

        function on_patent_load(iframeElement, tab_id) {
          var $context = $(iframeElement).contents();
          $("head", $context).append($("script#search-term-table-style").html());    // append style for replacement page header
          $("div#pocs", $context).remove();
          process_links($context, "patent");
          process_patent_button_bar($context);
          $("a[href='/patents']", $context).remove();        // Link to basic patent search
          $("div#footer_table", $context).remove();          // Links at the bottom of the page
          $("div#gb", $context).replaceWith($("script#page-header").html()); 
          $("div.viewport-chrome-toolbar div:contains('Application')", $context)
            .each( function(index) {$(this).on("click", {index: index}, on_click_Application);} );  // Application button(s)
          $("div.viewport-chrome-toolbar div:contains('Grant')", $context)
            .each( function(index) {$(this).on("click", {index: index}, on_click_Grant);} );        // Grant button
          $("span.notice-section > a", $context)             // Override default event handler assigned in process_links
            .off("click", on_click_new_patent_url).on("click", on_click_AlsoPublishedAs);
          $("td.patent-bibdata-heading:contains('Also published as') ~ td span.patent-bibdata-value > a", $context)
            .off("click", on_click_new_patent_url).on("click", on_click_AlsoPublishedAs);
          // set up the popover for the patent tab; parse the doc to get the full patent_no.
          var patent_no = setupPatentTab(tab_id, $context);
          $("a#" + tab_id).tab("show");
          window.scrollTo(0,0);
          if (on_patent_tab_complete) {
            on_patent_tab_complete(patent_no);                                      // callback with the full patent_no
          }
        }

        function setupPatentTab(tab_id, $context) {
        // tab has already been labeled with patentLabel (patent number without the kind code) in make_patent_tab;
        // need to get the full patent number with kind code by parsing the Google patent document and add it as an
        // attribute to the tab; the full patent_no is used internally by the program; return the full patent_no. 
          var patent_no = getPatentNo($context);      // get the full patent document number by parsing the Google patent document
          var tia = getTIA($context);                              // object containing title, inventors, assignees for the patent
          var inventors = tia.inventors.replace(/, (?!Jr|JR|II|IV)/g,'<br/>');     // x(?!y) matches x only if not followed by y
          var assignee = tia.assignee.replace(/, (?!Jr|JR|II|IV)/g,'<br/>');
          var htmlPopoverContent =
                           _.template( $("script#patent-info-popover").html(), {inventors: inventors, assignee: assignee} );
          var aTab = $("a#" + tab_id).attr("data-patent", patent_no);
          setupMapFavButtons(aTab, document, "main", patent_no);
          aTab.popover( {placement: "bottom", trigger: "hover", html: true, title: tia.title,
                         content: htmlPopoverContent} );  // or "click" to debug
          aTab.popover('disable');                                // disable initially since we are already looking at this tab
          var popoverObject = aTab.data('bs.popover');            // get reference to popover instance; the .tip() method
          // returns the top div element of the popover so can add my own css.
          $(popoverObject.tip()).addClass('jdwpatent').children("div,h3").addClass('jdwpatent');
          aTab.on('shown.bs.tab', on_tab_shown);
          return patent_no;
        }
      }

      function on_click_AlsoPublishedAs(event) {
        var $context = $(this.ownerDocument.body);
        var grant_url = $(this).attr("href");
        var link_match = rExp_patno_from_url.exec(grant_url);
        var grant_no = link_match ? link_match[1] : '';
        // if patent will not open in separate browser tab, change the caption of the current application tab
        if (!external_URLs.some( function(external_URL) {return grant_url.search(external_URL) >= 0 ? true : false;})) {  
          $("ul#topTabs li.active > a > span").text(grant_no);
        }
        window.scrollTo(0,0);
      }

      function on_click_more_search_result(event) {
        event.preventDefault();
        event.stopPropagation();
        var $currentIFrame = $("div.tab-pane.active iframe");                 // jQuery object - the containing iframe
        var more_results_url = $(this).attr("href");
        make_more_result_tab($currentIFrame, more_results_url);
      }

      function on_click_new_search_url(event) {
        event.preventDefault();
        event.stopPropagation();
        var search_url = $(this).attr("href");
        var link_text = $(this).text();
        var link_words = link_text.split(/[,\s]+/);                           // split on one or more ,whitespace
        var tab_title = 'Result';
        // mimic google patent search form input fields
        var searchTerms = [{}, {"name" : "as_drrb_is", "value": "q"}, {"name": "as_ptypeorstatus", "value": "0"}];
        if (search_url.search('ininventor') >= 0) {
          if (link_words.length > 0) {
            var last_word = link_words[link_words.length-1];
            switch (last_word.toUpperCase()) {
              case "JR": case "JR.": case "II": case "III": case "IV":
                tab_title = link_words[link_words.length-2];
                break;
              default:
                tab_title = last_word;
            }
          }
          searchTerms[0] = {"name": "as_pinvent", "value": link_text};
        }
        else if (search_url.search('inassignee') >=0) {
          if (link_words.length > 0) {
            tab_title = link_words.length > 1 ? link_words[0] + '...' : link_words[0];
            searchTerms[0] = {"name": "as_pasgnee", "value": link_text};
          }
        }
        else {
          console.log('Did not match search url in on_click_new_search_url');
        }
        make_search_result_tab(search_url, tab_title, searchTerms);
      }

      function process_patent_button_bar($context) {
        $("div.goog-inline-block.jfk-button", $context).each(function() {
          var button_text = $(this).text();
          // Remove any language translation buttons, 'Discuss this patent'
          if (button_text != 'Application' && button_text != 'Grant' && button_text != 'Find prior art'
            && button_text != 'View PDF' && button_text != 'Download PDF') $(this).remove();
        });
        $("div[role='button'] img[src*='settings.png']", $context).parent().parent().remove();  // gearbox settings button
        var origLeftToolbarButtons = $("div#left-toolbar-buttons", $context);
        var origRightToolbar = $("div#right-toolbar-buttons div.viewport-chrome-toolbar", $context);
        // replace divs with themselves as the only way to remove anonymous mousedown and mouseup event listeners;
        // clone('false') = do not clone event listeners;
        origRightToolbar.replaceWith(origRightToolbar.clone('false'));
        var newRightToolbar = $("div#right-toolbar-buttons div.viewport-chrome-toolbar", $context);
        newRightToolbar.on('mousedown', divMouseDown);
        newRightToolbar.on('click', on_click_patent_div_button);
      }


      function getPatentNo($context) {
      // get the full patent number from a Google patent document $context; used to associate a patent tab label (patent
      // number without the kind code) with the full patent document number used in Google links and EPO querying except
      // for US patents.
        var patent_no = $("span.patent-number", $context).text();
        if (patent_no) {
          patent_no = patent_no.replace(/\s/g, "");
          if (patent_no.slice(0,2) == "US") {                       // Google patent links for US patents do not have a kind code
            patent_no = patent_no.replace(/[A-Z]?\d?$/, "");        // so strip it off
          }
        }
        return patent_no;
      }

      function getTIA($context) {
        // get title, inventor(s), and assignee(s) in a patent document $context; used when setting up a patent tab and in the
        // a patent entry in the patentBiblio object list; called from processPatentPage and setupPatentTab.
        var title = $("span.patent-title", $context).text();
console.log("Got title " + (new Date() - startTime)/1000);
        var inventorList = [];
        var assigneeList = [];
        var shortAssigneeList = [];
        $("table.patent-bibdata td.patent-bibdata-heading:contains('Inventors') + td span.patent-bibdata-value a", $context)
            .each(function() {
                    var inventor = $(this).text();
                    inventor = makeUpperLower(inventor);              // correct occasional all uppercase inventor name
                    inventorList.push(inventor);
                  });
console.log("Got inventors " + (new Date() - startTime)/1000);
        $("table.patent-bibdata td.patent-bibdata-heading:contains('Assignee') + td span.patent-bibdata-value a", $context)
            .each(function() {
                    var assignee = $(this).text();
                    assignee = makeUpperLower(assignee);              // occasionally name is all uppercase(?)
                    var finalAssignee = assignee.replace(/S A$|Sa$/, "SA").replace(/Llc/, "LLC").replace(/A G$|Ag$/, "AG")
                                                .replace(/G M B H$|Gmbh$/, "GmbH");
                    assigneeList.push(finalAssignee);
                    shortAssigneeList.push(makeShort(finalAssignee))
                  });
        if (assigneeList.length == 0) {                               // Assignee or Applicant, depending on which country
          $("table.patent-bibdata td.patent-bibdata-heading:contains('Applicant') + td span.patent-bibdata-value a", $context)
            .each(function() {
                    var assignee = $(this).text();
                    var finalAssignee = assignee.replace(/S A$|Sa$/, "SA").replace(/Llc/, "LLC").replace(/A G$|Ag$/, "AG")
                                                .replace(/G M B H$|Gmbh$/, "GmbH");
                    assigneeList.push(finalAssignee);
                    shortAssigneeList.push(makeShort(finalAssignee))
                  });
        }
        var inventors = inventorList.join(", ");
        var assignees = assigneeList.join(", ");
        var shortAssignees = shortAssigneeList.sort().join(" ");
console.log("Got assignee " + (new Date() - startTime)/1000);
        return {title: title, inventors: inventors, assignee: assignees, shortAssignee: shortAssignees};
      }

      function on_click_patent_div_button(event) {
        switch ($(event.target).text()) {
          case "Find prior art":
            var related_url = $("a#appbar-patents-prior-art-finder-link", $(event.target.ownerDocument)).attr("href");
            make_related_tab(related_url);
            break;
          case "View PDF":
            var external_url = $("a#appbar-read-patent-link", $(event.target.ownerDocument)).attr("href");
            window.open(external_url);
            break;
          case "Download PDF":
            var external_url = $("a#appbar-download-pdf-link", $(event.target.ownerDocument)).attr("href");
            window.open(external_url);
            break;
          default:
        }
      }

      function on_click_Application(event) {
        var $context = $(this.ownerDocument);
        var thisIndex = event.data.index;                       // index of element the triggered the event
        var application_url = $("a[data-label='Application']", $context).eq(thisIndex).attr("href");
        var link_match = rExp_patno_from_url.exec(application_url);
        var application_no = link_match ? link_match[1] : '';
        $("ul#topTabs li.active > a > span").text(application_no);     // note we are not changing the id of the tab
        window.scrollTo(0,0);
      }

      function on_click_Grant(event) {
        var $context = $(this.ownerDocument);
        var thisIndex = event.data.index;
        var grant_url = $("a[data-label='Grant']", $context).eq(thisIndex).attr("href");
        var link_match = rExp_patno_from_url.exec(grant_url);
        var grant_no = link_match ? link_match[1] : '';
        $("ul#topTabs li.active > a > span").text(grant_no);     // note we are not changing the id of the tab
        window.scrollTo(0,0);
      }

      function on_click_external(event) {
        event.preventDefault();
        event.stopPropagation();
        var external_url = $(this).attr("href");
        window.open(external_url);
      }

    </script>

    <script id="customize-bootstrap-styles" type="text/template">    <!-- will load in main window -->
      <!-- import style for popovers on search, patent, and prior art pages -->
      <style type="text/css">
        @import url("/css/jdwpopovers.css");
        @import url("/css/jdwbuttons.css");
      </style>
    </script>

    <!-- html for adding the '+' and 'heart' (add and favorite) buttons to the Google related art page
         piggy back off of the Google css class 'hide-result-btn' for the 'x' that hides a patent;
         edit the /patents/related/static/icons.png file and add +' and 'heart' icons; (this file has many icons);
         save as iconsJDW and serve from the /css directory on my server; we select which icon to use by setting
         the position, height, and width of the background css parameter. -->
    <script id="related-art-page-button-content" type="text/template">
      <span class="hide-result-btn btn-favorite-add" title="Add to favorites"></span>
      <span class="hide-result-btn btn-map-add" title="Add to patent map"></span>
    </script>

    <script id="search-page-button-content" type="text/template">
      <span class="hide-result-btn btn-hide-add" title="Hide"></span>
      <span class="hide-result-btn btn-favorite-add" title="Add to favorites"></span>
      <span class="hide-result-btn btn-map-add" title="Add to patent map"></span>
    </script>

    <script id="search-page-unhide-results" type="text/template">
      <div class="hidden-results-info hidden-show-all">
        <span class="hidden-results-message">0 result hidden below.</span>
        <span class="hidden-results-clear-btn">Show all</span>
      </div>
    </script>

    <script id="prior-art-popover-title" type="text/template">
      Prior art for <%= patent_no %>:<br><span class="popover-subtitle jdwprior"><%- patent_title %></span>
    </script>

    <script id="prior-art-popover-content" type="text/template">
      <table id="jdw20">
        <tbody id="jdw21">
          <tr>
            <td class="jdw22">Search terms:</td>
            <td class="jdw23" id="jdw-pop-search-terms"><%- searchTerms %></td>
          </tr>
          <tr>
            <td class="jdw22">Start date:</td>
            <td class="jdw23" id="jdw-pop-start-date"><%= startDate %></td>
          </tr>
          <tr>
            <td class="jdw22">End date:</td>
            <td class="jdw23" id="jdw-pop-end-date"><%= endDate %></td>
          </tr>
        </tbody>
      </table>
    </script>

    <script id="patent-info-popover" type="text/template">
      <table id="jdw20">
        <tbody id="jdw21">
          <tr>
            <td class="jdw22">Inventors:</td>
            <td class="jdw23"><%= inventors %></td>
          </tr>
          <tr>
            <td class="jdw22">Assignee:</td>
            <td class="jdw23"><%= assignee %></td>
          </tr>
        </tbody>
      </table>
    </script>
    
    <script id="search-term-popover" type="text/template">            <!-- will load in main window -->
      <table id="jdw14">
        <tbody>
          <tr>
            <td class="tcell"><%- t1 %></td>
            <td class="vcell"><%- v1 %></td>
            <td class="tcell"><%- t5 %></td>
            <td class="vcell"><%- v5 %></td>
            <td class="tcell"><%- t9 %></td>
            <td class="vcell"><%- v9 %></td>
            <td class="tcell"><%- t13 %></td>
            <td class="vcell"><%- v13 %></td>
          </tr>
          <tr>
            <td class="tcell"><%- t2 %></td>
            <td class="vcell"><%- v2 %></td>
            <td class="tcell"><%- t6 %></td>
            <td class="vcell"><%- v6 %></td>
            <td class="tcell"><%- t10 %></td>
            <td class="vcell"><%- v10 %></td>
            <td class="tcell"><%- t14 %></td>
            <td class="vcell"><%- v14 %></td>
          </tr>
          <tr>
            <td class="tcell"><%- t3 %></td>
            <td class="vcell"><%- v3 %></td>
            <td class="tcell"><%- t7 %></td>
            <td class="vcell"><%- v7 %></td>
            <td class="tcell"><%- t11 %></td>
            <td class="vcell"><%- v11 %></td>
            <td class="tcell"><%- t15 %></td>
            <td class="vcell"><%- v15 %></td>
          </tr>
          <tr>
            <td class="tcell"><%- t4 %></td>
            <td class="vcell"><%- v4 %></td>
            <td class="tcell"><%- t8 %></td>
            <td class="vcell"><%- v8 %></td>
            <td class="tcell"><%- t12 %></td>
            <td class="vcell"><%- v12 %></td>
            <td class="tcell"><%- t16 %></td>
            <td class="vcell"><%- v16 %></td>
          </tr>
        </tbody>
      </table>
    </script>

    <!-- tweek formating of Gooooogle span so it disappears.  Will load in iframe of search pages -->
    <script id="search-page-more-results-style" type="text/template">
      <style type="text/css">
        @import url("/css/jdwsearchresultpage.css");
      </style>
    </script>

    <script id="search-term-table-style" type="text/template">    <!-- loads in iframe of search, patent, related, and hidden related pages -->

      <!-- import styles for:
             inserted Map and Favorites buttons
             customized page header
             animation trick to get the prior art div.r's to load properly -->
      <style type="text/css">
        @import url("/css/jdwbuttons.css");
        @import url("/css/jdwpageheader.css");
        @import url("/css/jdwpriorartpage.css");
      </style>
    </script>

    <!-- replacement header for google search and patent pages -->
    <script id="page-header" type="text/template">
      <div id="jdwTop">
        <div class="jdw-google">
          <div class="jdw-google-logo">
            <!-- replace the <a> tag in the Google page with a span having the same classes -->
            <!-- get google logo with this span -->
            <span class="jdw-google-logo1">
              <span class="jdw-google-logo2"></span>
            </span>
          </div>
        </div>
      </div>
    </script>

    <!-- header for prior art page -->
    <script id="prior-art-table" type="text/template">                  <!-- will load in prior art iframe -->
      <div id="jdw30" class="gbt">
        <h2 id="jdw31">Prior art for <%= patent_no %></h2>
      </div>
    </script>

    <!-- search term table -->
    <script id="search-term-table" type="text/template">                <!-- will load in iframe -->
      <div id="jdw1">
        <div id="jdw2">
          <table>
            <tbody>
              <tr>
                <td><b>Search terms:</b></td>
              </tr>
            </tbody>
          </table>
        </div>
        <div id="jdw3" class="gbt">
          <table id="jdw4">
            <tbody>
              <tr>
                <td class="tcell"><%- t1 %></td>
                <td class="vcell"><%- v1 %></td>
                <td class="tcell"><%- t5 %></td>
                <td class="vcell"><%- v5 %></td>
                <td class="tcell"><%- t9 %></td>
                <td class="vcell"><%- v9 %></td>
                <td class="tcell"><%- t13 %></td>
                <td class="vcell"><%- v13 %></td>
              </tr>
              <tr>
                <td class="tcell"><%- t2 %></td>
                <td class="vcell"><%- v2 %></td>
                <td class="tcell"><%- t6 %></td>
                <td class="vcell"><%- v6 %></td>
                <td class="tcell"><%- t10 %></td>
                <td class="vcell"><%- v10 %></td>
                <td class="tcell"><%- t14 %></td>
                <td class="vcell"><%- v14 %></td>
              </tr>
              <tr>
                <td class="tcell"><%- t3 %></td>
                <td class="vcell"><%- v3 %></td>
                <td class="tcell"><%- t7 %></td>
                <td class="vcell"><%- v7 %></td>
                <td class="tcell"><%- t11 %></td>
                <td class="vcell"><%- v11 %></td>
                <td class="tcell"><%- t15 %></td>
                <td class="vcell"><%- v15 %></td>
              </tr>
              <tr>
                <td class="tcell"><%- t4 %></td>
                <td class="vcell"><%- v4 %></td>
                <td class="tcell"><%- t8 %></td>
                <td class="vcell"><%- v8 %></td>
                <td class="tcell"><%- t12 %></td>
                <td class="vcell"><%- v12 %></td>
                <td class="tcell"><%- t16 %></td>
                <td class="vcell"><%- v16 %></td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </script>

    <!-- scripts for inserting a Bootstrap tab and tab content-->
    <script id="bs_tab-pane" type="text/template">
      <div class="tab-pane" id="<%= tab_content_id %>">
        <iframe class="gps_result" id="<%= iframe_id %>" width="<%= iframe_width %>" height="<%= iframe_height %>" allowfullscreen="true" sandbox="allow-same-origin allow-top-navigation allow-forms allow-scripts">
        </iframe>
      </div>
    </script>

    <script id="bs_nav-tab" type="text/template">
      <li>
        <a id="<%= tab_id %>" href="#<%= tab_content_id %>" data-toggle="tab" data-tabname="<%= tab_name %>">
          <span><%= tab_name %></span>
          <div class="tb">
            <button class="close close-tab" type="button" onclick="deleteTab(event)">&times;</button>
          </div>
        </a>
      </li>
    </script>

    <!-- script for adding the Map and Favorites buttons to patent tabs -->
    <script id="tab-buttons" type="text/template">
       <div class="tb tb-left">
          <span class="hide-result-btn btn-map-add" title="Add to patent map"></span>
          <span class="hide-result-btn btn-favorite-add" title="Add to favorites"></span>
       </div>
    </script>

    <!-- script for templating a patent entry in the Mapped patent list -->
    <!-- variables are patent_no -->
    <script id="mapped-list-entry-section" type="text/template">
      <div class="patent-list-entry" data-patent="<%= patent_no %>">
        <div class="patent-list-patent-nav-area">
          <div class="patent-list-dropdown-arrow"></div>
        </div>
        <div class="patent-list-patent-container">
          <!-- HTML from script id 'patent-list-patent-section' for the patent goes here -->
          <!-- HTML from script id 'patent-list-reference-section' for its cited patents goes here -->
          <!-- HTML from script id 'patent-list-reference-section' for its citing patents goes here -->
          <!-- HTML from script id 'patent-list-reference-section' for its related patents goes here -->
        </div>
      </div>
    </script>

    <!-- script for templating a patent entry in the Favorites patent list -->
    <!-- variables are patent_no -->
    <script id="favorites-list-entry-section" type="text/template">
      <div class="patent-list-entry" data-patent="<%= patent_no %>">
        <div class="patent-list-patent-container">
          <!-- HTML from script id 'patent-list-patent-section' for the patent goes here -->
        </div>
      </div>
    </script>

    <!-- script for templating a patent biblio in a patent list -->
    <!-- variables are patent_no, patent_label, source_patent, title, file_date; set source_patent = patent_no
    <!-- if patent_no is a Mapped patent or a Favorite patent -->
    <script id="patent-list-patent-section" type="text/template">
      <div class="patent-list-patent" data-patent="<%= patent_no %>" data-source-patent="<%= source_patent %>">
        <div class="patent-list-patent-main">
          <div class="patent-list-patent-biblio">
            <div class="patent-list-patent-row">
              <div class="patent-list-patent-number">
                <a class="pop1-patent-url" href="/patents/<%= patent_no %>"><%= patent_label %></a>
              </div>
              <div class="patent-list-patent-buttons">
                <span class="hide-result-btn btn-map-add" title="Add to patent map" data-patent="<%= patent_no %>"></span>
                <span class="hide-result-btn btn-favorite-add" title="Add to favorites" data-patent="<%= patent_no %>"></span>
                <span class="hide-result-btn btn-hide-add" title="Delete from map" data-patent="<%= patent_no %>"></span>
              </div>
              <div class="patent-list-patent-date">
                <div>Appl: <%= file_date %></div>
              </div>
            </div>
            <div class="patent-list-patent-title"><%= title %></div>
          </div>
        </div>
        <div class="patent-list-fullview-button" title="Full view" data-patent="<%= patent_no %>" data-querying="false">
          <div class="patent-list-fullview-container"></div>
          <div class="patent-list-full-rect"></div>
        </div>
      </div>
    </script

    <!-- script for templating a citations section under a patent in a patent list -->
    <!-- variables are patent_no, citation_type ('cited', 'citing', or 'related'), citation_no (number of citations)
    <!-- and citation_heading -->
    <script id="patent-list-reference-section" type="text/template">
      <div class="patent-list-references patent-list-<%= citation_type %>-patents" data-patent="<%= patent_no %>" data-citation-type="<%= citation_type %>">
        <div class="patent-list-patent-nav-area patent-list-<%= citation_type %>-nav-area">
          <%= (citation_no > 0) ? dropdownArrowHTML(patent_no) : "" %>
        </div>
        <div class="patent-list-citation-container">
          <div class="patent-list-citation-heading patent-list-<%= citation_type %>-heading"><%= citation_heading %> 
            (<span class="patent-list-citation-mapped">0</span>&nbsp;mapped;&nbsp;
             <span class="patent-list-citation-deleted">0</span>&nbsp;deleted)
          </div>
          <div class="patent-list-subpatent-container">
            <!-- HTML from script id 'patent-list-patent-section' for each citation_type patent goes here -->
          </div>
        </div>
      </div>
      <% function dropdownArrowHTML(patent_no) {
        // add HTML for the dropdown arrow if a citations list has entries
        return '<div class="citation-list-dropdown-arrow" data-patent="' + patent_no + '"></div>';
      } %>
    </script>

    <!-- script for templating the biblio popup on the force maps -->
    <!-- variables are patent_no, patent_label, file_date, pub_date, title, inventors, assignee, and abstract -->
    <script id="force-pop1" type="text/template">
      <div class="pop1-container" data-patent="<%= patent_no %>">
        <div class="pop1-top-capture"></div>
        <div class="pop1-patent-row">
          <div class="pop1-patent"><a class="pop1-patent-url" href="/patents/<%= patent_no %>"><%= patent_label %></a></div>
          <div class="pop1-buttons">
            <span class="hide-result-btn btn-map-add" title="Add to patent map"></span>
            <span class="hide-result-btn btn-favorite-add" title="Add to favorites"></span>
            <span class="hide-result-btn btn-pin-add" title="Pin to map"></span>
            <span class="hide-result-btn btn-hide-add" title="Delete from map"></span>
          </div>
          <div class="pop1-dates">
            <div>Appl: <%= file_date %></div>
            <div>Pub: <%= pub_date %></div>
          </div>
        </div>
        <div class="pop1-title"><%- title %></div>
        <div class="pop1-inventors"><%= (inventors !="Inventors not available") ? makeLinksHTML(inventors, "ininventor") : inventors %></div>
        <div class="pop1-assignee"><%= (assignee != "Assignee not available") ? makeLinksHTML(assignee, "inassignee") : assignee %></div>
        <div class="pop1-abstract"><strong>Abstract</strong><br><%- abstract %></div>
        <div class="pop1-top-btns" data-patent="<%= patent_no %>"></div>
      </div>
      <% function makeLinksHTML(parseStr, queryTerm) {
        // parseStr is a comma separated string of names; from each name construct an <a> tag whose href is a google patent
        // search URL containing the query term queryTerm.
        var aPre = '<a class="pop1-search-url" href="/search?tbo=p&amp;tbm=pts&amp;hl=en&amp;q=' + queryTerm + ':%22';
        var aPost = '%22">';
        var aClose = '</a>';
        var itemArray = parseStr.split(/\s*,\s*/);
        itemArray = itemArray.map( function(name) {return aPre + name.replace(/\s+/g, "+") + aPost + name;});
        return itemArray.join(aClose + ", ") + aClose;
      } %>
    </script>

    <script type="text/javascript" charset="utf-8">

      // attach event handlers to buttons above the force map on the Map page
      $("input.input-patent").on("keydown", on_keydown_input_patent)
                             .on("keyup", on_keyup_input_patent);
      $("span.btn-go").on("click", on_click_go_btn);
      $("button.btn-random").on("click", on_click_random_btn)
                            .on("mousedown", divMouseDown);  // prevent buttons from getting focus with blue outline when clicked
      $("button.btn-weird").on("click", on_click_weird_btn)
                           .on("mousedown", divMouseDown);
      $("button.btn-undo").on("click", on_click_undo_delete_btn)
                          .on("mousedown", divMouseDown);
      $("button.btn-clear").on("click", on_click_clear_btn)
                           .on("mousedown", divMouseDown);

      var pop1P = {
        "minWidth": 300,                                   // styling parameters for div.pop1-container
        "maxWidth": 350
      };

      createNodeLegend();

      // legend parameters
      nLegendEntry = 8;                      // maximum number of legend entries
      nLegendColors = 12;                    // maximum number of legend colors, including dedicated color for 'AllOtehrs' entry

      var d3_format_EPO_date = d3.time.format("%b %e, %Y");     // e.g., Nov 1, 1978

      function PatentNode(patent_no, source, biblio) {
      // constructor for the data object bound to a forcePatent map node 
        this.patent_no = patent_no;
        this.source = source;                              // true if the patent is the focus of the map
        this.biblio = biblio;                              // an object containing all the bibliographic data
        this.label = makePatentLabel(patent_no);           // node labels on the force map omit the kind code
        this.key = patent_no;                              // data key for d3
        this.plotLinks = 0;                                 // number of plotted links incident on this node
        this.date = d3_format_EPO_date.parse(this.biblio.file_date);   // a javascript date
        // x_fix initialized according to the initial x-axis; x_fix never changes even if x-axis is changed
        this.x_fix = xForceScale(this.date);
        this.plotX = 0;
        this.plotY = 0;
        // note the x_fix, x,y values used in the forcePatent map are never affected by zooming; plotX,plotY is the data
        // that is actually used in the transform operations on the actual SVG elements; this.x,.y will be created and
        // defined when forcePatent map is created
        this.updatePlotCoord = function() {                // need to call when the forcePatent map is zoomed
          this.plotX = xForceToPlotScale(this.x);
          this.plotY = yForceToPlotScale(this.y);          // translate in the y direction but do not zoom
        }
        this.drag = false;                                 // mark a node when it is being dragged
        this.sourcePatentLinks = {};             // contains link_key : patentLink key/value pairs for links to source patentNodes
        this.targetPatentLinks = {};             // contains link_key : patentLink key/value pairs for links to target patentNodes
        this.targetPatentLinksList = [];         // need to track the order that target links are added for undeleting patents
        this.biblioNode = {};                              // reference to associated BiblioNode object
        this.biblioLink = {};                              // reference to associated BiblioLink object
        this.markerRadius = 7;                             // keep track of the radius of the svg circle that is plotted
        this.sortOrder = 3;                                // sort order in DOM so pLinks, bLinks, and pNodes overlay correctly
      }

      function BiblioNode(patent_no, biblio) {
      // constructor for the data object bound to a forceBiblio map node 
        this.patent_no = patent_no;
        this.label = makePatentLabel(patent_no);           // used for text of patent hyperlinks
        this.biblio = biblio;                              // an object containing all the bibliographic data
        this.key = patent_no;                              // data key for d3
        this.date = d3_format_EPO_date.parse(this.biblio.file_date);   // nn a javascript date
        this.plotX = 0;
        this.plotY = 0;
        // note the x,y values used in the forceBiblio map are never affected by zooming;
        // plotX,plotY is the data that is actually used in the 'transform's on the actual SVG elements;
        // this.x,.y will be created and defined when forceBiblio map is created
        this.updatePlotCoord = function() {                // need to call when the forceBiblio map is zoomed
          this.plotX = xForceToPlotScale(this.x);
          this.plotY = yForceToPlotScale(this.y);          // translate in the y direction but do not zoom
        }
        this.drag = false;                                 // mark a node when it is being dragged
        this.displayed = false;                            // used in updating forceBiblio map
        this.pinned = false;                               // is the biblio pinned
        this.mouseleave = false;              // needed for styling the css transition of unpinned biblio back to forcePatent node
        this.transition = false;              // needed for timing css styling changes when unpinned biblio transitions
        this.detached = false;                             // is the biblio detached from the associated node
        this.z_index = 0;                                  // css z-index
        this.patentNode = {};                              // reference to associated patentNode
        this.biblioLink = {};                              // reference to associated BiblioLink object
      }

      function BiblioLink(patent_no, patentNode, biblioNode) {  // the data object that is bound to bLinks between forcePatent
        this.patent_no = patent_no;                             // pNnodes and forceBiblio biblios g.pop1-markers
        this.key = patent_no;
        this.patentNode = patentNode;
        this.biblioNode = biblioNode;
        this.sortOrder = 2;                                // sort order in DOM so pLinks, bLinks, and pNodes overlay correctly
      }

      function PatentLink(source, target, type, key) {     // the data object that is bound as the forcePatent map pLink
        this.source = source;
        this.target = target;
        this.type = type;                                  // a string "cited", "citing", "related"
        this.key = key;                                    // data key for d3
        this.sortOrder = 1;                                // sort order in DOM so pLinks, bLinks, and pNodes overlay correctly
      }

      function LegendEntry(assignee, legendColor, patentCount) {  // constructor for a LegendEntry instance
        this.assignee = assignee;
        this.legendColor = legendColor;
        this.patentCount = patentCount;
      }

      var patentNodes = [];                                // forcePatent map patent nodes
      var biblioNodes = [];                                // forceBiblio map biblio nodes (no force map links for biblioNodes)
      var patentLinks = [];                                // rendered as forcePatent map pLink link lines
      var biblioLinks = [];          // rendered as bLink link lines between patentNodes and biblioNodes (are NOT force map links)
      // dictionary of patents currently plotted on forcePatent and forceBiblio maps; keys are patent nos.; values are patentNodes
      var patentsPlotted = {};
      // dictionary of patents that were plotted but then removed due to user unmapping an associated source patent
      // (not deleted by the user)
      var patentsUnplotted = {};
      // dictionary of patents that have been deleted from map by the user clicking the delete button; used for undo
      // dictionary of all patents that have ever been plotted on the map; keys are patent nos.; values are patentNodes
      var patentsHistory = {};
      var legendEntries = [];                        // array of LegendEntry legend entry objects that can be sorted by patentCount
      var plottedLegendEntries = [];                 // the array of LegendEntry objects that are shown in the legend
      var legendObjects = {};                              // need a key-value collection of LegendEntry objects
      var legendColors = ['rgb(141,211,199)','rgb(255,255,179)','rgb(190,186,218)','rgb(251,128,114)','rgb(128,177,211)',
                          'rgb(253,180,98)', 'rgb(179,222,105)','rgb(252,205,229)','rgb(217,217,217)','rgb(188,128,189)',
                          'rgb(204,235,197)','rgb(255,237,111)']

      // topBiblio will contain an object with the div.bib, div.pop1-container, and g.pop1-marker that became visible
      // due to mouseover on a forcePatent node.
      var topBiblio = undefined;
      var labelDistance = 2;

      d3.select(document).on("keydown.biblio", on_keydown_document, true)      // get event in the capture phse
                         .on("keyup.biblio", on_keyup_document, true);

      bib.on("click.biblio", on_click_change_mouse_mode, true)                 // div.bib-container; handle events in capture phase
         .on("mousedown.biblio", on_mousedown_change_mouse_mode, true)
         .on("mouseup.biblio", on_mouseup_change_mouse_mode, true);

      svg_main.on("mouseover.biblio", on_mouse_main_svg)
              .on("mousemove.biblio", on_mouse_main_svg)
              .on("mouseoout.biblio", on_mouse_main_svg)
              .on("mouseover.shift", on_mouseover_focus_main_svg);

      // create a zoom function implementing zooming and panning; will zoom the x-axis
      var zoom = d3.behavior.zoom().on("zoom", on_zoom)
                                   .on("zoomstart", on_zoomstart)
                                   .on("zoomend", on_zoomend)
                                   .x(xPlotScale);                     // zoom and translate the x axis; just translate the y axis

      zoom_rect.on("click.biblio", on_click_change_mouse_mode, true)                     // handle events in capture phase
               .on("mousedown.biblio", on_mousedown_change_mouse_mode, true)
               .on("mouseup.biblio", on_mouseup_change_mouse_mode, true)
               .call(zoom);

      plot.on("click.biblio", on_click_change_mouse_mode, true)                          // handle events in capture phase
          .on("mousedown.biblio", on_mousedown_change_mouse_mode, true)
          .on("mouseup.biblio", on_mouseup_change_mouse_mode, true);

      var allPatentNodes = [];                              // global variables for the forcePatent tick event handler
      var allPatentLinks = [];                              // and the zoom event handler
      var allBiblioNodes = [];
      var allBiblioLinks = [];                              // rendered as bLinks from pinned biblios to associated nodes
      var visBibs = [];                                     // global variables for the forceBiblio tick event handler
      var visBibLinks = [];                                 // only update plotting info for visible biblios to save time

      var compiledPop1Template = _.template( $("script#force-pop1").html());

      // define the force map for the patent nodes, specifying the pNodes, pLinks, and linkStrengths
      var forcePatent = d3.layout.force().size([fMap.w, fMap.h]).nodes(patentNodes).links(patentLinks)
                    .gravity(0.05).linkDistance(function(link, i) {return Math.abs(link.source.x_fix - link.target.x_fix);})
                    .charge(-100).linkStrength(0.1)     // gravity 0.05; linkDistance = 50; linkStrength = 1; charge -10000
                    .on("start", on_force_patent_start)
                    .on("tick", on_force_patent_tick);

      // define the force map for the biblio nodes, specifying the nodes, links (empty list), and no forces between nodes
      // forceBiblio map is used for its dragging capability and to be able to plot easily with forcePatent
      var forceBiblio = d3.layout.force().size([fMap.w, fMap.h]).nodes(biblioNodes).links([])
                          .gravity(0).linkDistance(0).charge(0).linkStrength(0)
//                          .on("start", on_force_biblio_start)
                            .on("tick", on_force_biblio_tick);

//      var force_patent_drag = function() {}
      var force_patent_drag = forcePatent.drag()
                       .on("dragstart.biblio", on_dragstart_force_patent)
                       .on("drag.biblio", on_drag_force_patent)
                       .on("dragend.biblio", on_dragend_force_patent);

      var force_biblio_drag = forceBiblio.drag()
                       .on("dragstart.biblio", on_dragstart_force_biblio)
                       .on("drag.biblio", on_drag_force_biblio)
                       .on("dragend.biblio", on_dragend_force_biblio);

      var updatePLink = function() {                                    // move a pLink to its new position
            this.attr("x1", function(d) {return d.source.plotX;})
                .attr("y1", function(d) {return d.source.plotY;})
                .attr("x2", function(d) {return d.target.plotX;})
                .attr("y2", function(d) {return d.target.plotY;});
            if (this.size() > 0) {
              this.each(pLinkErr);
            }
                                        
      }

      function pLinkErr(d) {
        if (d3.select(this).attr("x2") == "NaN") {
          console.log("In updatePLink, link is: ", d3.select(this), d, d.target.plotX, d.target.plotY);
        }
      }

      function bLinkErr(d) {
        if (d3.select(this).attr("x2") == "NaN") {
          console.log("In updateBLink, link is: ", d3.select(this), d, d.patentNode.plotX, d.patentNode.plotY);
        }
      }

      var updateBLink = function() {                                    // move a pLink to its new position
            this.attr("x1", function(d) {return d.patentNode.plotX;})
                .attr("y1", function(d) {return d.patentNode.plotY;})
                .attr("x2", function(d) {return d.biblioNode.plotX;})
                .attr("y2", function(d) {return d.biblioNode.plotY + 7;});  // connect to biblio itself, not the marker center
            if (this.size() > 0) {
              this.each(bLinkErr);
            }
      }

      var updatePatentNode = function() {                                    // move a node to its new position
            this.attr("transform", function(d) {return "translate(" + d.plotX + "," + d.plotY + ")";});
      }

      var updateBib = function() {
      // 'this' is the d3 selection of all div.bibs that have div.pop1-container.make-displayed
        // move the div.bibs to their new positions
        this.style({"-webkit-transform": function(d) {return "translate(" + d.plotX + "px," + d.plotY + "px)"},   // Chrome
                    "transform": function(d) {return "translate(" + d.plotX + "px," + d.plotY + "px)"}});         // Firefox
        this.classed({"out-of-bounds": function(d, i) {     // detect if node is out of the plotting region; if so, do not display
                 return (d.plotY < 0 || d.plotY > plotHeight || d.plotX > plotWidth || d.plotX < 0);
               }});
      }

      updateForceMap();

      function on_force_patent_start() {
      // event handler for forcePatent.start event; also called by updateForceMap
      // update the nodes, links, biblios that will be updated on the forcePatent map as the forcePatent layout runs
      // tick event handler must update all the visible items on the map
        // need to be sure to select all nodes currently on the map before re-starting
        allPatentNodes = svg.selectAll("g.node")
                      .sort(function(a, b) {                 // sort so the source nodes are drawn last so can see labels
                              return (a.source < b.source) ? -1 : ((a.source > b.source) ? 1 : 0);
                            })
                      .order();
        allBiblioNodes = d3.selectAll("div.bib");
        visBibs = allBiblioNodes.filter(hasPop1Displayed);         // update only div.bibs whose biblios are visible
        allPatentLinks = svg.selectAll("line.patent-link");
        allBiblioLinks = svg.selectAll("line.biblio-link");
        // update only line.biblio-links whose biblios are visible; make sure to update visBibs first
        visBibLinks = allBiblioLinks.filter(function(d, i) {return d.biblioNode.displayed});
        forceBiblio.stop();                                  // forceBiblio is a slave to forcePatent
      }

      function hasPop1Displayed(d, i) {
      // 'this' is a div.bib element; returns true if the element has a child div.pop1-container.make-displayed
        d.displayed = (d3.select(this).select("div.pop1-container.make-displayed").size() > 0);
        return d.displayed;
      }

      function on_force_biblio_tick(e) {
      // tick event handler for the forceBiblio map; if a biblio is not pinned, update its coordinates; if it is
      // pinned, do not update coordinates
//console.log("Hello from on_force_biblio_tick");
        allBiblioNodes.filter(function(d, i) {return (!d.pinned && !(d.patentNode.drag && pParam.mouse == "normal"));}).
          each(function(d, i) {
            d.x = d.patentNode.x;
            d.y = d.patentNode.y;
            d.updatePlotCoord();
          });
        visBibs.call(updateBib);
        visBibLinks.call(updateBLink);
      }

      function on_drag_force_biblio_tick(e) {
      // tick event handler for the forceBiblio map when a node is being dragged
        var draggedBiblio = allBiblioNodes.filter(function(d, i) {return d.drag;});  // get the dragged biblio node
        // update the forceBiblio map coordinates .x and .y
        draggedBiblio.each(function(d, i) { 
//console.log("Hello from on_drag_biblio_patent_tick");
//console.log("cur tick d: ", d.x, d.y);
              d.plotX = d.orig_plotX + (d.x - d.orig_x);       // follow drag in x direction
              d.x = xForceToPlotScale.invert(d.plotX);
//              d.x = d.orig_x;                                // use this to not follow drag in x-direction; do not change d.plotX
              d.plotY = d.orig_plotY + (d.y - d.orig_y);       // drag in y direction
              d.y = yForceToPlotScale.invert(d.plotY);
//console.log("new tick d: ", d.x, d.y);
            });

        // forcePatent is stopped while dragging biblios, so no need to update the forcePatent map
        visBibs.call(updateBib);
        visBibLinks.call(updateBLink);
      }

      function on_force_patent_tick(e) {
      // tick event handler for the forcePatent map when a node is not being dragged
        allPatentNodes.each(function(d, i) {                                 // update the forcePatent map coordinates .x and .y
//            d.x = d.px + 0.1*(d.x - d.px);
//            d.y = d.py + 0.1*(d.y - d.py);
            d.x = d.x + ((Math.log(10*0.099) - Math.log(10*e.alpha))/(Math.log(10*0.099) - Math.log(10*0.005)))*(d.x_fix - d.x);
                                                      // default value of alpha starts at 0.1 and decays exponentially to 0.005
            d.updatePlotCoord();                                       // update the SVG plotting coordinates .plotX and .plotY
          });
        allPatentNodes.call(updatePatentNode);
        allPatentLinks.call(updatePLink);
        on_force_biblio_tick(e);                               // allow forceBiblio to follow forcePatent
      }

      function on_drag_force_patent_tick(e) {
      // tick event handler for the forcePatent map when a node is being dragged
        allPatentNodes.each(function(d, i) {                   // update the forcePatent map coordinates .x and .y
            if (d.drag) {                                      // this patent node is being dragged
//console.log("Hello from on_drag_force_patent_tick");
//console.log("cur tick d: ", d.x, d.y);
//                d.plotX = d.orig_plotX + (d.x - d.orig_x);   // use this and next line if want to follow drag in x direction
//                d.x = xForceToPlotScale.invert(d.plotX);
              d.x = d.orig_x;                                  // do not drag in x direction; do not change d.plotX
              d.plotY = d.orig_plotY + (d.y - d.orig_y);       // drag in y direction
              d.y = yForceToPlotScale.invert(d.plotY);
//console.log("new tick d: ", d.x, d.y);
            }
            else {
              d.x = d.x + 0.2*(d.x_fix - d.x);
              d.updatePlotCoord();                             // update the SVG plotting coordinates .plotX and .plotY
            }
          });

        allPatentNodes.call(updatePatentNode);
        allPatentLinks.call(updatePLink);
        on_force_biblio_tick(e);                               // allow forceBiblio to follow forcePatent
      }

      function on_dragstart_force_biblio(d, i) {
console.log("Hello from on_dragstart_force_biblio for patent " + d.patent_no);
        d.drag = true;                              // save the current x position so can restrict the drag to the y direction
        d.orig_x = d.x;
        d.orig_y = d.y;
        d.orig_plotX = d.plotX;
        d.orig_plotY = d.plotY;
        allPatentNodes.filter(function(dd, ii) {return (dd.patent_no != d.patent_no);})
                      .selectAll("circle").classed({"pointer-events-none": true});
        svg_main.on("mouseover.biblio", null)
                .on("mousemove.biblio", null)
                .on("mouseoout.biblio", null);
        // pParam.mouse is always 'normal' when dragging a biblio
        var otherBibs = allBiblioNodes.filter(function(dd, i) {return (dd.patent_no != d.patent_no);});
        otherBibs.select("div.pop1-container").classed({"pointer-events-none": true});      // disable mouse events on other
        otherBibs.select("g.pop1-marker").classed({"pointer-events-none": true});           // div.pop1-containers
        // disable mouseenter and mouseleave handlers to avoid biblio disappearing and reappearing during drag
        var divBib = d3.select(this);
        $(divBib.node()).off("mouseenter.biblio");  // remove jQuery event handlers
        $(divBib.node()).off("mouseleave.biblio");  // to protect against slow dragging
        
        forceBiblio.on("tick", on_drag_force_biblio_tick);  // attach special tick event handler when dragging
        fMap.alpha = forcePatent.alpha();
        forcePatent.stop();                         // so will not have competing force maps during drag
      }

      function on_drag_force_biblio(d, i) {
      // When the drag handler is called, event.x, event.y is the position computed as the d.x, d.y when the drag was started
      // + pixels traveled by dragging; thus the starting point is in force map coordinates, but the distance traveled is
      // in pixels (i.e., plotting coordinates).
      // event.dx, event.dy are the changes in pixels from the previous mouse position;
      // d.x, d.y are the old force coordinates; they have not yet been updated with the current mouse event coordinates
      // by the time the tick handler is called, d.x, d.y values are the same as the drag event.x, event.y;
      // changing: event.x, event.y; event.dx, event.dy; or d.x., d.y in the drag handler has no effect on d in tick event handler
      // if d.x, d.y are changed in the tick handler, those values are still present when the drag handler is called.

        // check if biblio location relative to its associated patentNode should trigger a change in the pinned status
        // 'dist' is the node-biblio distance that triggers changes
        var dist = 1.7*d.patentNode.markerRadius;
        checkPinTrigger(d3.select(this), d, d.patentNode, dist);
      }

      function checkPinTrigger(divBib, bibNode, patNode, dist) {
      // divBib is the d3 object for the biblio div.bib
      // bibNode and patNode are datum objects; one of them is being dragged and the other is stationary 
      // d3 element associated with the 'dragged' element; 'dist' is the node-biblio distance that triggers changes

        // if biblio node near the associated patent node
        if (patNode.plotX - bibNode.plotX < dist && bibNode.plotX - patNode.plotX < dist
                     && patNode.plotY - bibNode.plotY < dist && bibNode.plotY - patNode.plotY < dist) {
          makeBiblioDetached(divBib);                                    // change from pinned to detached
        }

        // if biblio not pinned and getting too far away the associated patent node
        else if (!bibNode.pinned && !(patNode.plotX - bibNode.plotX < dist && bibNode.plotX - patNode.plotX <  dist
                     && patNode.plotY - bibNode.plotY < dist && bibNode.plotY - patNode.plotY < dist)) {
          makeBiblioPinned(divBib);                                       // change from detached to pinned
        }
      }

      function on_dragend_force_biblio(d, i) {
console.log("Hello from on_dragend_force_biblio for patent " + d.patent_no);
        d.drag = false;
          // need to change d.px, d.py because at end of drag they are set to coordinates based on the current mouse position,
          // not the current node position, causing nodes to bounce back into position in weird ways
        d.px = xForceToPlotScale.invert(d.plotX);
        d.py = yForceToPlotScale.invert(d.plotY);
        var divBib = d3.select(this);
        if (d.detached) {
          makeBiblioUnpinned(divBib);
        }
        // do not render marker or top-capture if biblio is pinned; wait for dragend since might be dragging on the marker
        if (d.pinned) {
          makeBiblioPinnedTop(divBib);
        }
        allPatentNodes.selectAll("circle").classed({"pointer-events-none": false});    // disable mouse events on nodes
        svg_main.on("mouseover.biblio", on_mouse_main_svg)
                .on("mousemove.biblio", on_mouse_main_svg)
                .on("mouseoout.biblio", on_mouse_main_svg);
        // pParam.mouse is always 'normal' when dragging a biblio
        var otherBibs = allBiblioNodes.filter(function(dd, i) {return (dd.patent_no != d.patent_no);});
        otherBibs.select("div.pop1-container").classed({"pointer-events-none": false});      // disable mouse events on other
        otherBibs.select("g.pop1-marker").classed({"pointer-events-none": false}); // visible div.pop1-containers
        var divBib = d3.select(this);
        $(divBib.node()).on("mouseenter.biblio", on_mouseenter_force_biblio);  // reattach jQuery event handlers
        $(divBib.node()).on("mouseleave.biblio", on_mouseleave_force_biblio);

        forceBiblio.on("tick", on_force_biblio_tick);
        forceBiblio.stop();
        forcePatent.alpha(Math.max(fMap.alpha, 0.06));                         // restart forcePatent so everything updates
      }

      function on_dragstart_force_patent(d, i) {
console.log("Hello from on_dragstart_force_patent for patent " + d.patent_no);
console.log(d3.event);
        d.drag = true;                              // save the current x position so can restrict the drag to the y direction
        d.orig_x = d.x;
        d.orig_y = d.y;
        d.orig_plotX = d.plotX;
        d.orig_plotY = d.plotY;
        allPatentNodes.filter(function(dd, ii) {return (dd.patent_no != d.patent_no);})
                      .selectAll("circle").classed({"pointer-events-none": true}); // .on("mouseover.biblio", null);      // remove event handlers during drag
        svg_main.on("mouseover.biblio", null)
                .on("mousemove.biblio", null)
                .on("mouseoout.biblio", null);
        if (pParam.mouse == "normal") {
          var otherBibs = allBiblioNodes.filter(function(dd, ii) {return (dd.patent_no != d.patent_no);});
          otherBibs.select("div.pop1-container").classed({"pointer-events-none": true});      // disable mouse events on other
          otherBibs.select("g.pop1-marker").classed({"pointer-events-none": true});      // visible div.pop1-containers
          // disable mouseenter and mouseleave handlers to avoid biblio disappearing and reappearing during drag
          var divBib = d3.select("div.bib[data-patent=" + d.patent_no + "]");
          $(divBib.node()).off("mouseenter.biblio");  // remove jQuery event handlers
          $(divBib.node()).off("mouseleave.biblio");  // to protect against slow dragging
        }
        forcePatent.on("tick", on_drag_force_patent_tick);   // attach special tick event handler when dragging
        fMap.alpha = forcePatent.alpha();
        forcePatent.stop();                         // so will not have competing force maps during drag
        d.fixed = true;                             // so node does not move after dragging
      }

      function on_drag_force_patent(d, i) {
      // When the drag handler is called, event.x, event.y is the position computed as the d.x, d.y when the drag was started
      // + pixels traveled by dragging; thus the starting point is in force map coordinates, but the distance traveled is
      // in pixels (i.e., plotting coordinates).
      // event.dx, event.dy are the changes in pixels from the previous mouse position;
      // d.x, d.y are the old force coordinates; they have not yet been updated with the current mouse event coordinates
      // by the time the tick handler is called, d.x, d.y values are the same as the drag event.x, event.y;
      // changing: event.x, event.y; event.dx, event.dy; or d.x., d.y in the drag handler has no effect on d in tick event handler
      // if d.x, d.y are changed in the tick handler, those values are still present when the drag handler is called.

        // check if patentNode location relative to its associated biblioNode should trigger a change in the pinned status
        if (pParam.mouse == "normal") {
          var divBib = visBibs.filter(function(dd, ii) {return (dd.patent_no == d.patent_no);});
          var dist = 1.7*d.markerRadius;
          if (divBib.size() > 0) {
            checkPinTrigger(divBib, d.biblioNode, d, dist);
          }
        }
      }

      function on_dragend_force_patent(d, i) {
console.log("Hello from on_dragend_force_patent for patent " + d.patent_no);
        d.drag = false;
          // need to change d.px, d.py because at end of drag they are set to coordinates based on the current mouse position,
          // not the current node position, causing nodes to bounce back into position in weird ways
        d.px = xForceToPlotScale.invert(d.plotX);
        d.py = yForceToPlotScale.invert(d.plotY);
        var divBib = visBibs.filter(function(dd, ii) {return (dd.patent_no == d.patent_no);});
        if (d.biblioNode.detached) {
          makeBiblioUnpinned(divBib);
        }
        // do not render marker or top-capture if biblio is pinned
        if (d.biblioNode.pinned) {
          makeBiblioPinnedTop(divBib);
        }
        allPatentNodes.selectAll("circle").classed({"pointer-events-none": false});    // re-enable mouse events on nodes
        svg_main.on("mouseover.biblio", on_mouse_main_svg)
                .on("mousemove.biblio", on_mouse_main_svg)
                .on("mouseoout.biblio", on_mouse_main_svg);
        if (pParam.mouse == "normal") {
          var otherBibs = allBiblioNodes.filter(function(dd, i) {return (dd.patent_no != d.patent_no);});
          otherBibs.select("div.pop1-container").classed({"pointer-events-none": false});      // disable mouse events on other
          otherBibs.select("g.pop1-marker").classed({"pointer-events-none": false}); // visible div.pop1-containers
          var divBib = d3.select("div.bib[data-patent=" + d.patent_no + "]");
          $(divBib.node()).on("mouseenter.biblio", on_mouseenter_force_biblio);  // reattach jQuery event handlers
          $(divBib.node()).on("mouseleave.biblio", on_mouseleave_force_biblio);
        }
        forcePatent.on("tick", on_force_patent_tick);
        forcePatent.alpha(Math.max(fMap.alpha, 0.06));                           // restart forcePatent so everything updates
      }

      function updateForceMap() {
      // add new nodes to the forcePatent and forceBiblio maps as the patent data is received from EPO
console.log("updateForceMap");
console.log("patentNodes: ", patentNodes);
console.log("patentLinks: ", patentLinks);

        // add the new pLinks to the SVG (just new pLinks using .enter.append)
        var pLink = plot.selectAll("line.patent-link").data(forcePatent.links(), function(d) {return d.key;});
        pLink.enter().append("svg:line")
                     .classed({"patent-link": true})
                     .attr({"data-link-key": function(d, i) {return d.key;}})
                     .style({"stroke": function(d, i) {
                                        switch(d.type) {
                                          case "cited":
                                            return "tomato";
                                          case "citing":
                                            return "darkgreen";
                                          case "related":
                                            return "darkblue";
                                        }
                                      },
                           "stroke-width": "1px"});
        pLink.exit().remove();

        // add lines connecting nodes to biblios
        var bLink = plot.selectAll("line.biblio-link").data(biblioLinks, function(d) {return d.key;});
        bLink.enter().append("svg:line").classed({"biblio-link": true})
                     .attr({"data-patent": function(d, i) {return d.patent_no;}});   // add the new biblio-node bLinks
        bLink.exit().remove();

        // add the new nodes to the SVG (just new nodes using .enter.append); attach event handler to g.node, but enable
        // pointer events only on the node circles.
        var curNode = plot.selectAll("g.node").data(forcePatent.nodes(), function(d) {return d.key;});
        var newNode = curNode.enter().append("svg:g")
                             .classed({"node": true})
                             .attr({"data-patent": function(d, i) {return d.patent_no;}})
                             .on("mouseover.biblio", on_mouseover_force_patent)
                             .on("mousemove.biblio", on_mousemove_force_patent);
        curNode.exit().remove();

        // add new div.bibs to the main bib-container div; newBibDiv is just the new divs (.enter.append); must set z-index on
        // the div.bibs because they are siblings in the DOM; setting z-index directly on the div.pop1-containers does not
        // work since they are not siblings.
        var curBibDiv = bib.selectAll("div.bib").data(forceBiblio.nodes(), function(d) {return d.key;});
        var newBibDiv = curBibDiv.enter().append("div")
                                 .classed({"bib": true})
                                 .attr({"data-patent": function(d, i) {return d.patent_no;}})
                                 .style({"z-index": function(d, i) {return d.z_index;}});

        curBibDiv.exit().remove();

        // jQuery mouseleave event is much more useful here than javascript mouseout event (see comments in the event
        // handler for more details); attach to div.bib so can handle events on both div.pop1-container and g.pop1-marker
        newBibDiv.each(function(d, i) {$(this).on("mouseleave.biblio", on_mouseleave_force_biblio)
                                              .on("mouseenter.biblio", on_mouseenter_force_biblio);});

        plot.selectAll("g.node, line.patent-link, line.biblio-link")
            .sort(function(a, b) {                            // order needs to be line.patent-links, then line.biblio-links,
                 if (a.sortOrder < b.sortOrder) return -1;    // then g.nodes, so graphics overlay each other correctly
                 if (a.sortOrder > b.sortOrder) return 1;
                 return 0;
                }).order();

        on_force_patent_start();                        // refresh lists of nodes, links, and visible biblios on forcePatent map

        updateXAxisLimits();                            // update the x-axis plot limits in pParam
        updateXAxisContent();                           // update the tick locations and labels for xAxisLabel and xAxisGrid
        updatePlotScaling();                            // update the xPlotAxis according to the new plot limits

        // insert the html for the biblio popup that appears when the mouse is over a patent node, and then attach event handlers
        newBibDiv.html(function(d, i) {return compiledPop1Template(
                                        {patent_no: d.patent_no, patent_label: d.label, file_date: d.biblio.file_date,
                                         pub_date: d.biblio.pub_date, title: d.biblio.title, inventors: d.biblio.inventors,
                                         assignee: d.biblio.assignee, abstract: d.biblio.abstract});});
        // select the top-level biblio popup containers div.pop1-container in the html added under the div.bib
        var divPop = newBibDiv.select("div.pop1-container")           // select copies d3 data from div.bib to div.pop1-container
                              .style({"min-width": pop1P.minWidth + "px", "max-width": pop1P.maxWidth + "px"});
        divPop.selectAll("a.pop1-patent-url")                                                     // set patent links
                       .on("click.biblio", on_click_new_patent_url_map)
                       .on("mousedown.biblio", on_mousedown_no_drag);                          // prevent triggering dragstart
        divPop.selectAll("a.pop1-search-url")
                       .on("click.biblio", on_click_new_search_url_map)
                       .on("mousedown.biblio", on_mousedown_no_drag);                          // prevent triggering dragstart
        divPop.select("div.pop1-top-btns")
                       .on("click.biblio", on_click_top_buttons_biblio)
                       .on("mouseover.biblio", on_mouseover_top_buttons_biblio)
                       .on("mouseout.biblio", on_mouseout_top_buttons_biblio);
        divPop.each(function(d,i) {setupMapFavButtons(this, document, "map", d.patent_no);});  // set up map and favorite buttons
        divPop.select("div.pop1-buttons").selectAll("span")                                    // select all buttons (map, fav etc)
                       .on("mousedown.biblio", on_mousedown_no_drag);                          // prevent triggering dragstart
        divPop.select("span.btn-hide-add")                                                     // set up the delete button
                       .attr({"data-patent": function(d, i) {return d.patent_no;}})
                       .on("click.biblio", on_click_delete_btn);
        divPop.select("span.btn-pin-add")                                                      // set up the pin/unpin buttons
                       .attr({"data-patent": function(d, i) {return d.patent_no;}})
                       .on("click.biblio", on_click_pin_btn);

        addPopArrowCircleSVG(newBibDiv);             // add svg for arrow and node circle at top of biblio
        addPopTopBtns(newBibDiv);                    // add svg for buttons at top right of biblio

        forcePatent.start();
        // finish appending svg elements 
        newNode.each(setupMarkers);                                         // add the node markers
        newNode.append("svg:text").text(function(d, i) {return d.label})    // add the node labels to the SVG
               .classed("node-label", true)
               .attr({"text-anchor": "middle", "dominant-baseline": "middle",
                     "transform": "translate(0, " + (-labelDistance) + ")",
                     "data-patent": function(d, i) {return d.patent_no;}});

        updateLegend();

        // update the node colors
        allPatentNodes.each(updateForceMapSymbolColor);

        newNode.call(force_patent_drag);                                           // allows nodes to be dragged with the mouse
        newBibDiv.call(force_biblio_drag);
      }

      function updateForceMapSymbolColor(d, i) {
        var legendKey = d.biblio.shortAssignee;
        var legendObject = legendObjects[legendKey];
        var legendIndex = plottedLegendEntries.indexOf(legendObject);
        var legendColor = (legendIndex != -1) ? legendObject.legendColor : legendObjects["AllOthers"].legendColor;
        d3.select(this).selectAll("circle.force-patent-circle, circle.force-mapped-circle, circle.force-favorite-circle")
              .style({"fill": legendColor});        
      }

      function updateLegend() {
      // called from updateForceMap, deletePatentFromMap, removePatentFromMapped
        // determine if we need to have an 'AllOthers' entry in the legend; add a LegendEntry object if needed; always use
        // legendColors[0] for the color of 'AllOthers' if needed
        if (legendEntries.length > nLegendEntry) {            // need to create the 'AllOthers' entry
          if (!legendObjects["AllOthers"]) {
            legendObjects["AllOthers"] = new LegendEntry("Others", legendColors[0], 0);      // always use legendColors[0]
          }
          legendObjects["AllOthers"].patentCount = 0;
          for (var iL = nLegendEntry - 1; iL < legendEntries.length - 1; iL++) {   // the last entry is 'Others' at this point
            var notShownEntry = legendEntries[iL]
            legendObjects["AllOthers"].patentCount += notShownEntry.patentCount;
          }
          plottedLegendEntries = legendEntries.slice(0, nLegendEntry - 1).concat([legendObjects["AllOthers"]]);
        }
        else {
          plottedLegendEntries = legendEntries.slice(0, nLegendEntry);
        }

        // now update the SVG for the legend
        legend.select("rect.legend-frame").remove();
        // show only the first nLegendEntry entries
        var curLegendItem = legend.selectAll("g.legend-entry").data(plottedLegendEntries);
        curLegendItem.select("circle.legend-symbol");                             // propagate the new data to the child elements!
        curLegendItem.select("text.legend-text");
        var newLegendItem = curLegendItem.enter().append("svg:g").classed({"legend-entry": true});     // add new legend entries
        newLegendItem.append("svg:circle").classed({"legend-symbol": true}).attr({"r": 5});
        newLegendItem.append("svg:text").classed({"legend-text": true});
        curLegendItem.exit().remove();
        curLegendItem = legend.selectAll("g.legend-entry");                                 // refresh the data for the legend SVG
        curLegendItem.attr({"transform": function(d, i) {return "translate(0," + i*14 + ")";}});       // list the entries
        curLegendItem.selectAll("circle.legend-symbol")
                            .style({"fill": function(d, i) {return d.legendColor;}});
        curLegendItem.selectAll("text.legend-text").attr({"transform": "translate(15,0)", "dominant-baseline": "middle"})
                            .text(function(d, i) {return d.assignee + " (" + d.patentCount + ")";});
        if (legendEntries.length > 0) {
          var bBox = legend.node().getBBox();                          // get bounding box of an SVG element
          legend.insert("svg:rect", ":first-child").classed({"legend-frame": true})             // first element in g
                       .attr({"x": "-12", "y": "-12", "width": bBox.width + 13, "height": bBox.height + 9});
        }
      }

      function recycleLegendColor(legendEntry) {
      // puts legendEntry.legendColor back in the list of available colors; called from deletePNode and updateLegend.
        legendColors.push(legendEntry.legendColor);                  // add to end of color list
        legendEntry.legendColor = "";
      }

      function getNewLegendColor(legendEntry) {
      // assigns an unused legend color to legendEntry.legendColor
        legendEntry.legendColor = legendColors.pop();                          // pop from end of color list
      }

      function addToLegend(patentNode) {
      // add the patent represented by patentNode to the legend; called from addPatentToPlottingLists
        var assignee = patentNode.biblio.assignee;
        var shortAssignee = patentNode.biblio.shortAssignee;
        var legendEntry = legendObjects[shortAssignee];
        if (!legendEntry)  {                 // add object for this assignee to legendObjects and add to the legendEntries array
          legendEntry = new LegendEntry(assignee, "", 0);
          legendObjects[shortAssignee] = legendEntry;
          legendEntries.push(legendEntry);
        }
        legendEntry.patentCount +=1;
        legendEntries.sort(legendSort);
        var curEntryIndex = legendEntries.indexOf(legendEntry);
        if (curEntryIndex <= nLegendColors - 1 && legendEntry.legendColor == "") {   // we need to assign a legend color
          if (legendColors.length > 1) {
            getNewLegendColor(legendEntry);
          }
          // take color of the nLegendColor'th entry; (one legendColor is always reserved for the 'AllOthers' entry)
          else {
            var lastColoredEntry = legendEntries[nLegendColors-1];
            legendEntry.legendColor = lastColoredEntry.legendColor;
            lastColoredEntry.legendColor = "";
          }
        }
      }

      function deleteFromLegend(patentNode) {
      // delete the patent represented by patentNode from the legend; called from deletePNode.
        var shortAssignee = patentNode.biblio.shortAssignee;
        var legendEntry = legendObjects[shortAssignee];
        legendEntry.patentCount -= 1;
        legendEntries.sort(legendSort);
        var curEntryIndex = legendEntries.indexOf(legendEntry);
        if (curEntryIndex > nLegendColors - 2 && legendEntry.legendColor != "") {   // we need to give the color to another entry
          var lastLegendEntry = legendEntries[nLegendColors - 2]
          lastLegendEntry.legendColor = legendEntry.legendColor;
          legendEntry.legendColor = "";
        }
        if (legendEntry.patentCount == 0) {                             // if no other patents from this company
          legendEntries.splice(curEntryIndex, 1);                       // delete assignee from the legendEntries
          if (legendEntry.legendColor != "") {
            recycleLegendColor(legendEntry);          
          }
          delete legendObjects[shortAssignee];                            // and from the legendObjects collection
        }
      }

      function legendSort(a, b) {
      // sorting function for legendEntries
        if (a.patentCount < b.patentCount) return 1;      // sort in descending order of count
        if (a.patentCount > b.patentCount) return -1;
        // if patentCount is the same:
        // put 'Assignee not available' last
        if (a.assignee == "Assignee not available") return 1;
        if (b.assignee == "Assignee not available") return -1;
        if (a.assignee > b.assignee) return 1;            // sort in ascending alphabetic order
        if (a.assignee < b.assignee) return -1;
        return 0;
      }

      function updateMarkerOnForceMap(marker, page_type) {
      // called from setupMarkers, addSourcePatentToForceMap, addMapPatent, on_mouseover_patent_list_patent,
      // and on_mouseout_patent_list_patent
      // change the marker to type markerType ("normal", "mapped", or "favorite") on the force map,
      // depending on prioritized testing of which list(s) the patent is in;
      // marker is the d3 g.force-patent-marker element containing the circle svg; page_type is page type
      // that the 'map' or 'favorite' button was clicked on or being setup from.

        var patent_no = marker.datum().patent_no;
        // priority of markers is "mapped", "favorite", "normal".
        var onMappedList = (patentLists["map"].indexOf(patent_no) != -1);           // -1 if not in list
        var onFavoritesList = (patentLists["favorites"].indexOf(patent_no) != -1);  // -1 if not in list
        var markerType = (onMappedList) ? "mapped" : ((onFavoritesList) ? "favorite" : "normal");
        switch (markerType) {
          case "normal":
            var markerRadius = 7;
            var circleClass = "force-patent-circle";
            break; 
          case "mapped":
            var markerRadius = 10;
            var circleClass = "force-mapped-circle";
            var iconDef = "#force-mapped-cross-def";
            break;
          case "favorite":
            var markerRadius = 10;
            var circleClass = "force-favorite-circle";
            var iconDef = "#force-favorite-heart-def";
            break;
        }
        marker.attr({"data-marker": markerType});                // update the type of marker it is
        marker.datum().markerRadius = markerRadius;
        marker.select("use").remove();
        var markerCircle = marker.select("circle")
                                 .attr({"class": circleClass, "r": markerRadius});
        switch (page_type) {
          case "mapped-list": case "favorites-list":
            markerCircle.style({"stroke-width": "3px"});
            break;
          default:
            markerCircle.style({"stroke-width": null});
        }        
        if (markerType == "mapped" || markerType == "favorite") {
          marker.append("svg:use").attr({"xlink:href": iconDef});
        }
        d3.select("div.bib[data-patent=" + patent_no + "]").select("circle.pop1-marker").attr({"r": markerRadius});
      }

      function setupMarkers(d, i) {
      // called from updateForceMap to set up node markers on the force map
      // checks if patent_no is in the 'map' or 'favorites' list and changes the node marker if so
      // SVG elements do not have innerHTML properies that allows us to add SVG on the fly using d3 .html() or jQuery .after();
      // one way to get around this is to follow suggestion in d3 documentation, and add innersvg.js polyfill at
      // https://code.google.com/p/innersvg via a script tag in the document header; (need to apply patch to use the <use> tag;
      // the alternative, which I ended up going with is to add all the svg using d3 
        var patentNode = d3.select(this);
        var patent_no = d.patent_no;
        var marker = patentNode.append("svg:g").classed({"force-patent-marker": true})
                               .attr({"data-patent": patent_no});
        marker.append("svg:circle");
        updateMarkerOnForceMap(marker, "map");
      }

      function updatePlotScaling() {
      // update the scales to transform forcePatent and forceBiblio map coordinates to plotting coordinates.
        xForceToPlotScale.range([xPlotScale(fMap.minDate), xPlotScale(fMap.maxDate)]);
        yForceToPlotScale.range([yPlotScale(0), yPlotScale(fMap.h)]);
      }

      function replotForceMap() {
      // called from on_zoom event handler
        allPatentNodes.each(function(d, i) {
                        d.updatePlotCoord();});     // update the SVG plotting coordinates .plotX and .plotY for forcePatent map
        allBiblioNodes.each(function(d, i) {
                        d.updatePlotCoord();});     // update the SVG plotting coordinates .plotX and .plotY for forceBiblio map
        allPatentNodes.call(updatePatentNode);      // move forcePatent map nodes to their new positions
        visBibs.call(updateBib);                    // move forceBiblio map biblio popups
        allPatentLinks.call(updatePLink);           // move forcePatent map pLinks
        visBibLinks.call(updateBLink);              // move forceBiblio map bLinks
      }

      function on_zoomstart() {
      // remove event handlers on patents, biblios, and main svg to avoid things popping up if pan fast with mouse
        console.log("Hello from on_zoom_start");
        allPatentNodes.selectAll("circle").classed({"pointer-events-none": true});
        if (pParam.mouse == "normal") {
          allBiblioNodes.select("div.pop1-container").classed({"pointer-events-none": true});    // disable mouse events on
          allBiblioNodes.select("g.pop1-marker").classed({"pointer-events-none": true});        // visible div.pop1-containers
          allBiblioNodes.each(function(d, i) {$(this).off("mouseleave.biblio")
                                                     .off("mouseenter.biblio");});
        }
        svg_main.on("mouseover.biblio", null)
                .on("mousemove.biblio", null)
                .on("mouseoout.biblio", null);
      }

      function on_zoomend() {
      // reattach event handlers on patents, biblios, and main svg
        console.log("Hello from on_zoom_end");
        allPatentNodes.selectAll("circle").classed({"pointer-events-none": false});
        if (pParam.mouse == "normal") {
          allBiblioNodes.select("div.pop1-container").classed({"pointer-events-none": false});   // disable mouse events on
          allBiblioNodes.select("g.pop1-marker").classed({"pointer-events-none": false});        // visible div.pop1-containers
          allBiblioNodes.each(function(d, i) {$(this).on("mouseleave.biblio", on_mouseleave_force_biblio)
                                                     .on("mouseenter.biblio", on_mouseenter_force_biblio);});
        }
        svg_main.on("mouseover.biblio", on_mouse_main_svg)
                .on("mousemove.biblio", on_mouse_main_svg)
                .on("mouseoout.biblio", on_mouse_main_svg);
      }

      function on_zoom() {
        if (!d3.event.shiftKey) {                           // if shift key is not pressed (not trying to go to "transparent" mode
          console.log("In on_zoom, event is: ", d3.event);
          pParam.minX = xPlotScale.invert(0);
          pParam.maxX = xPlotScale.invert(plotWidth);
          var totalTransY = zoom.translate()[1];
          if (zoom.scale() == pParam.scale) {                 // pan: only apply the y translation if the zoom event was panning
            pParam.panTransY = totalTransY - pParam.zoomTransY
            yPlotScale.domain([pParam.minY - pParam.panTransY, pParam.maxY - pParam.panTransY]);  // apply pan portion of translation to the y axis
          }
          else {                                              // zoom: update the zoom-induced component of the translation
            pParam.scale = zoom.scale();
            pParam.zoomTransY = totalTransY - pParam.panTransY;   // zooming to a new scale induces a translation which we need to remove
          }
          updateXAxisContent();        
          updatePlotScaling();
          replotForceMap();
        }
      }

      function updateXAxisLimits() {
      // calculate the new x-axis plot limits and store in pParam; update the xPlotScale
        if (allPatentNodes.size() > 0) {
          var d3_format = d3.time.format("%Y");
          var dateNow = new Date();
          var maxDate = d3.max(allPatentNodes.data(), function(d) {return d.date;});
          var minDate = d3.min(allPatentNodes.data(), function(d) {return d.date;});
          var padDate = 0.125*(maxDate.getTime() - minDate.getTime());
          pParam.minDate = d3.time.year.floor(new Date(minDate.getTime() - padDate));
          pParam.maxDate = d3.time.year.ceil(new Date(Math.min(maxDate.getTime() + padDate, dateNow.getTime())));
          var minYear = pParam.minDate.getFullYear();
          var maxYear = pParam.maxDate.getFullYear();
          var nYears = maxYear - minYear;
          if (isNaN(nYears) || nYears < 5) {
            var addYears = 5 - nYears;                                     // minimum interval for x axis is 5 years
            var padHigh = Math.floor(addYears/2);
            maxYear = Math.min(maxYear + padHigh, d3.time.year.ceil(dateNow).getFullYear());
            pParam.maxDate = d3_format.parse((maxYear).toString());
            pParam.minDate = d3_format.parse((maxYear - 5).toString());
          }

          // update the domain of xPlotScale based on filing date of patents on the forcePatent map;
          pParam.minX = (pParam.minX < pParam.minDate) ? pParam.minX : pParam.minDate;
          pParam.maxX = (pParam.maxX > pParam.maxDate) ? pParam.maxX : pParam.maxDate;
          xPlotScale.domain([pParam.minX, pParam.maxX]);
          zoom.x(xPlotScale);                                              // need to call zoom.x when xPlotScale is updated
          var xRange = (pParam.maxX.getTime() - pParam.minX.getTime())/(365.25*24*60*60*1000)  // x-axis range in years
          zoom.scaleExtent([xRange/300, xRange/1.2]);
        }
      }

      function updateXAxisContent() {
      // calculate new x-axis labels and gridlines; update the xAxisLabel and xAxisGrid axes

        if (allPatentNodes.size() > 0) {
          var nYears = pParam.maxX.getFullYear() - pParam.minX.getFullYear();
          var tickInt = d3.time.year;                         // default tick interval unit
          var gridInt = d3.time.year;                         // default grid interval unit
          if (nYears < 1) {
            var tickNo = 1;
            var gridInt = d3.time.month;                      // override default grid interval
            var gridNo = 1;
          }
          else if (1 <= nYears && nYears <= 2) {
            var tickNo = 1;
            var gridInt = d3.time.month;                      // override default grid interval
            var gridNo = 1;
          }
          else if (3 <= nYears && nYears <= 4) {
            var tickNo = 1;
            var gridInt = d3.time.month;                      // override default grid interval
            var gridNo = 3;
          }
          else if (5 <= nYears && nYears <= 12) {
            var tickNo = 1;
            var gridInt = d3.time.month;                      // override default grid interval
            var gridNo = 6;
          }
          else if (13 <= nYears && nYears <= 24) {
            var tickNo = 2;
            var gridNo = 1;
          }
          else if (25 <= nYears && nYears <= 36) {
            var tickNo = 4;
            var gridNo = 1;
          }
          else if (37 <= nYears && nYears <= 60) {
            var tickNo = 5;
            var gridNo = 1;
          }
          else if (61 <= nYears && nYears <= 120) {
            var tickNo = 10;
            var gridNo = 2;
          }
          else if (121 <= nYears && nYears <= 240) {
            var tickNo = 20;
            var gridNo = 4;
          }
          else if (241 <= nYears && nYears <= 360) {
            var tickNo = 40;
            var gridNo = 10;
          }
          else if (361 <= nYears && nYears <= 500) {
            var tickNo = 50;
            var gridNo = 10;
          }
          else {
            console.log("Unexpected xAxis range in updateXAxisContent")
          }
          xAxisLabel.ticks(tickInt, tickNo).scale(xPlotScale);              // create the tick label HTML generating function
          xAxisGrid.ticks(gridInt, gridNo).scale(xPlotScale);               // create the gridline HTML generating function
          xAxisLabelSVG.call(xAxisLabel);                                   // add tick labels to the plot
          xAxisGridSVG.call(xAxisGrid);                                     // add gridlines to the plot
          d3.selectAll("g.x-axis-label > g.tick > line").remove();          // remove tick mark from label
          d3.selectAll("g.x-axis-grid > g.tick > text").remove();           // remove text from gridlines
        }
      }

      function deletePLink(patentLink) {
      // delete patentLink (of type PatentLink) from the forcePatent map; but do not delete the patentLink itself;
        var linkKey = patentLink.key;
        var index = patentLinks.indexOf(patentLink);
        if (index != -1) {
          patentLinks.splice(index, 1);                                     // remove 1 patentLink from patentLinks at the index
          // note we do not delete the linkKey entry in the targetPatentLinksList, targetPatentLinks, or sourcePatentLinks
          // objects of the source and target patentNodes because we need to keep a record of the patents that are linked
          // together in case a patent is un-deleted and we want to replot all the associated links;  need to call updateForceMap
          // to actually remove the SVG elements associated with patentLink
          patentLink.source.plotLinks -= 1;                                 // update link counts for the sourceNode and targetNode
          patentLink.target.plotLinks -= 1;
//          d3.select("line.patent-link[data-link-key=" + linkKey + "]").remove();   // remove the line.patent-link SVG element
        }
        else {
          console.log("In deletePLink, tried to delete patentLink that was not on the force map: ", patentLink);
        }
      }

      function deleteBNode(biblioNode) {
      // delete biblioNode from the forceBiblio map by deleting it from the biblioNodes list, but do not delete
      // biblioNode itself; need to call updateForceMap to actually remove the SVG elements associated with biblioNode
        var patent_no = biblioNode.patent_no;
        var index = biblioNodes.indexOf(biblioNode);
        if (index != -1) {
          biblioNodes.splice(index, 1);                                       // remove 1 biblioNode from biblioNodes at the index
//          d3.select("div.bib[data-patent=" + patent_no + "]").remove();     // remove div.bib from the DOM
        }
        else {
          console.log("In deleteBNode, tried to delete biblioNode that was not on the force map: ", biblioNode);
        }
      }

      function deleteBLink(biblioLink) {
      // delete biblioLink from the map by deleting it from the biblioLinks list, but do not delete
      // biblioLink itself; need to call updateForceMap to actually remove the SVG elements associated with biblioLink
        var patent_no = biblioLink.patent_no;
        var index = biblioLinks.indexOf(biblioLink);
        if (index != -1) {
          biblioLinks.splice(index, 1);                                       // remove the entry for the link from biblioLinks
//          d3.select("line.biblio-link[data-patent=" + patent_no + "]").remove();
        }
        else {
          console.log("In deleteBLink, tried to delete biblioLink that was not on the force map: ", biblioLink);
        }
      }

      function deletePNode(patentNode, deletionType) {
      // remove patentNode (of type PatentNode) from the forcePatent map by deleting it from the patentNodes
      // list, but do not delete the patentNode itself; if deleted patent is a source patent, delete it from the
      // patentLists["map"] list and unclick all the associated map buttons; update the patentsUnplotted or deleted
      // lists according to deletionType: if "unplot", the patentNode is being removed as part of unmapping a source patent;
      // or if "delete", the user clicked the delete button for a patent on the force map; need to call updateForceMap
      // to actually delete the SVG elements associated with the patentNode; called from deletePatentFromMap
      // and deleteLinksToTargetPatentsFromMap
	var patent_no = patentNode.patent_no;
        var index = patentNodes.indexOf(patentNode);
        if (index != -1) {
          patentNodes.splice(index, 1);                                     // remove 1 patentNode from patentNodes at the index
          delete patentsPlotted[patent_no];                                 // remove the entry for the patent from patentsPlotted
          switch (deletionType) {
            case "unplot":
              patentsUnplotted[patent_no] = patentNode;
              break;
            case "delete":
              addPatentToDeletedList(patent_no);                            // only place where patent_no is added to deleted list
              break;
          }
          if (patentNode.source) {                                          // if a sourceNode
            // get jQuery map button associated with this patent on forcePatent map to pass to toggleBtn
            var $mapBtn = $("div.bib[data-patent='" + patent_no + "']").find("span.btn-map-add");
            updatePatentListTrackers("map", $mappedList, patent_no, $mapBtn);
          }
          deleteFromLegend(patentNode);
        }
        else {
          console.log("In deletePNode, tried to delete patentNode that was not on the force map: ", patentNode);
        }
      }

      function on_click_delete_btn(d, i) {
      // delete the patent and associated pLinks and bLinks from the forcePatent and forceBiblio maps;
      // keep the biblio data available in case the node is replotted;
      // delete from patentNodes and patentLinks arrays which provide data for d3;
      // delete from patentsPlotted which track which patents and pLinks are plotted;
      // delete nodes whose only pLink is to the node being deleted;
      // if deleted patent is a source patent, delete it from the patentLists["map"] list and unclick all the
      // associated map buttons;
        var deleteBtn = d3.select(this).classed({"make-not-displayed": true});  // hide so cannot click twice quickly
        var patent_no = deleteBtn.attr("data-patent");
        deletePatentFromMap(patent_no, "single", on_delete_complete);

        function on_delete_complete() {
          setUndoButtonState();     // will set Undo button state based on whether deleted list has any patents in  it
          setClearButtonState();    // will set Clear button state based on whether patentsPlotted still has any patents in it
        }
      }

      function deletePatentFromMap(patent_no, deletionType, on_delete_patent) {
      // called from on_click_delete_btn and on_click_clear_btn; remove patent patent_no from the forcePatent
      // and forceBiblio maps; deletionType is 'single' or 'group' (for the Clear button); on_delete_patent is
      // an optional callback called after the deletion is complete
        fMap.alpha = forcePatent.alpha();
        var patentNode = d3.select("g.node[data-patent=" + patent_no + "]").datum();
        d3.select("div.bib[data-patent=" + patent_no + "] div.pop1-container")
          .classed({"make-displayed": false});

        // if patent_no is a source patent, delete target nodes first to help preserve legend colors if patent is undeleted
        if (patentNode.source) {
          // delete pLinks with patent_no as source; nextDeletions is the callback
          deleteLinksToTargetPatentsFromMap(patentNode, nextDeletions);     // nextDeletions is the callback
        }
        else {
          nextDeletions();
        }

        function nextDeletions() {
        // continue the deletion process; called from deletePatentFromMap when deleted patent is a target patent
        // and deleteTargetGroup after all target patents for a deleted source patent have been deleted
          deleteLinksToSourcePatentsFromMap(patentNode);                    // delete pLinks with patent_no as target
          deletePNode(patentNode, "delete");                                // delete patentNode from forcePatent map
          deleteBNode(patentNode.biblioNode);                               // delete associated biblioNode from forceBiblio map
          deleteBLink(patentNode.biblioNode.biblioLink);                    // delete associated biblioLink from forceBiblio map

          deletePatentFromMappedSublists(patent_no);                        // delete from any citation sublists
          removeDeleteButtonInFavoritesEntry(patent_no);                    // remove delete button option if patent in Favorites
          // keep .source property unchanged undeleting a patent will undelete it as a source patent or a reference patent
          switch (deletionType) {
            case "single":
              updateForceMap();
              if (patentNode.source) {
                forcePatent.start();                                        // let map rearrange itself significantly
              }
              else {
                forcePatent.start();
                forcePatent.alpha(Math.max(fMap.alpha, 0.06));              // let map relax somewhat
              }
              break;
            case "group":                                                   // calling function responsible for calling
              break;                                                        // updateForceMap when appropriate
          }
          if (on_delete_patent) {
            on_delete_patent();                                             // call the callback if defined
          }
        }
      }

      function deletePatentFromMappedSublists(patent_no) {
      // utility function called from deletePatentFromMap; idelete the patent from all reference sublists in the Mapped
      // list; patent has already been deleted from the Mapped list as a mapped patent in deletePNode.
        // find all entries in the Mapped list for patent_no appears as a reference; will only be in sublists at this point
        var $citationEntry = $mappedList.find("div.patent-list-patent[data-patent='" + patent_no + "']");
        var $citationContainer = $citationEntry.closest("div.patent-list-citation-container");   // select container
        var $citationListHeading = $citationContainer.find("div.patent-list-citation-heading");  // select heading in the container
        $citationListHeading.each(function() {                                                   // update patent counts
                                    incrementCitationCount( $(this), "deleted", 1);
                                    incrementCitationCount( $(this), "mapped", -1);});
        $citationEntry.remove();
      }

      function removeDeleteButtonInFavoritesEntry(patent_no) {
      // utility function called from deletePatentFromMap; remove delete button from entry for patent_no in the
      // Favorites list on the Map page
        $favoritesList.find("span.btn-hide-add[data-patent='" + patent_no + "']").addClass("make-not-displayed");
      }

      function updateSymbols() {
        allPatentNodes = svg.selectAll("g.node");
        allPatentNodes.each(updateForceMapSymbolColor);
      }

      function deleteLinksToSourcePatentsFromMap(targetNode) {
      // targetNode is a PatentNode instance (not a d3 selection); removes all pLinks where targetNode
      // is the target; does not remove the sourceNode even if targetNode is the only link to it
        for (linkKey in targetNode.sourcePatentLinks) {
          var sourceLink = targetNode.sourcePatentLinks[linkKey];  // sourceLink is the link from patentNode as target
          var sourceNode = sourceLink.source;                      // to sourceNode as source
          if (patentLists["map"].indexOf(sourceNode.patent_no) != -1) {  // if source patent is plotted
            deletePLink(sourceLink);
            if (sourceNode.plotLinks == 0) {            // if sourceNode is now disconnected, let the source node stay on the map
//              deletePNode(sourceNode);                             // delete patentNode from forcePatent map
//              deleteBNode(sourceNode.biblioNode);                  // delete associated biblioNode from forceBiblio map
//              deleteBLink(sourceNode.biblioLink);                  // delete associated biblioLink from forceBiblio map
            }
          }
        }
      }

      function deleteLinksToTargetPatentsFromMap(sourceNode, nextDeletions) {
      // sourceNode is a PatentNode instance (not a d3 selection); removes all pLinks where sourceNode
      // is the source patent; removes the targetNode patent if sourceNode is the only link to it and it is
      // not also a source patent; if called from deletePatentFromMap (user clicks delete button), nextDeletions
      // is a callback to continue the deleting process after timeout to allow the force map to relax; if called
      // from removePatentFromMapped (user clicks unmap button), nextDeletions is null.
        var linksList = sourceNode.targetPatentLinksList;
        if (linksList.length == 0) return;
        var nL = 40;                                         // delete nL links and associated patents at a time
        var groupList = createGroupList(linksList, nL);      // break into list of subgroups of indices in linksList
        // delete target patents one group at a time, so map updates during Delete and Clear of large groups of patents
        // delete linked patents in reverse order to help preserve legend colors if a source patent is undeleted
        var iL = groupList.length - 1;
        if (iL >= 0) {
          taskTracker.initialize("Deleting", undefined);
          taskTracker.startTask(groupList.length);
          deleteTargetGroup();
        }
        else {
          if (nextDeletions) {                               // if deleting a patent, not just unmapping it
            nextDeletions();
          }
        }

        function deleteTargetGroup() {
        // delete the iL'th group of links and asociated patents in linksList
          if (arguments.length > 0) {                       // was called recursively after timeout in this function
            taskTracker.finishTask(arguments[0]);
          }
          var index = groupList[iL];
          // delete in reverse order to help preserve legend colors if use undoes the delete
          for (var jL = index.end - 1; jL >= index.start; jL--) {
            var linkKey = linksList[jL];
            deleteTargetPatentFromMap(sourceNode, linkKey);
          }
          updateForceMap();
          if (iL > 0) {
            iL--;
            // call deleteTargetGroup again after allowing 1 task to finish
            window.setTimeout(deleteTargetGroup.bind(undefined, 1), 500);
          }
          else {
            window.setTimeout(afterFinalGroup, 500);
          }
        }

        function afterFinalGroup() {
          taskTracker.finishTask(1);
          if (nextDeletions) {
            nextDeletions();
          }
        }
      }

      function createGroupList(list, nL) {
      // takes a list and returns a list of groupList objects {start: startIndex, end: endIndex} so that list can
      // processed in groups approximately nL in size
        var groupList = [];
        if (list.length > 0) {
          var kL = Math.ceil(list.length/nL)              // number of subgroups
          nnL = Math.floor(list.length/kL);               // make the groups about the same size
          for (var iL = 0; iL < kL - 1; iL++) {
            groupList.push({start: iL*nnL, end: (iL + 1)*nnL});
          }
          groupList.push({start: (kL - 1)*nnL, end: list.length});
        }
        return groupList;
      }

      function deleteTargetPatentFromMap(sourceNode, linkKey) {
      // delete the target patent associated with linkKey; sourceNode is a PatentNode instance (not a d3 selection);
      // called from deleteLinksToTargetPatentsFromMap
        var targetLink = sourceNode.targetPatentLinks[linkKey];  // targetLink is the link from patentNode as source
        var targetNode = targetLink.target;                      // to targetNode as target
        if (targetNode.patent_no in patentsPlotted) {
          deletePLink(targetLink);
          if (targetNode.plotLinks == 0 && !targetNode.source) {   // if targetNode is now disconnected, unplot the targetNode
            deletePNode(targetNode, "unplot");                     // delete patentNode from forcePatent map
            deleteBNode(targetNode.biblioNode);                    // delete associated biblioNode from forceBiblio map
            deleteBLink(targetNode.biblioLink);                    // delete associated biblioLink from forceBiblio map
          }
        }
      }

      function removePatentFromFavorites(patent_no, $favBtn, page_type) {
        updatePatentListTrackers("favorites", $favoritesList, patent_no, $favBtn);
        if (patentsPlotted[patent_no]) {                            // if the patent is mapped
          if (page_type == "favorites-list") {                      // special case when favorite patent is removed via Favorites
            mouseout_patent_list_patent(patent_no);                 // List; mimic mouseout event: FavList entry has been deleted
          }
          else {
            var marker = d3.select("g.force-patent-marker[data-patent=" + patent_no + "]");
            updateMarkerOnForceMap(marker, page_type);              // update the marker appearance
          }
        }
      }

      function removePatentFromMapped(patent_no, $mapBtn, page_type) {
      // remove the patents linked to patent_no (unless they are source patents); remove the patent from the mapped list,
      // but do not remove it from the map (it may be a targetNode for another source patent)
        var patentNode = patentsPlotted[patent_no];
        deleteLinksToTargetPatentsFromMap(patentNode, null);        // no callback when removing a patent from the mapped list
        patentNode.source = false;
        updateLegend();
        updateSymbols();
        forcePatent.start();                                              // let the map rearrange itself significantly
        updatePatentListTrackers("map", $mappedList, patent_no, $mapBtn);
        if (page_type == "mapped-list") {                       // special case when mapped patent is removed via Mapped
          mouseout_patent_list_patent(patent_no);               // List; mimic mouseout event: Mapped List entry has been deleted
        }
        else {
          var marker = d3.select("g.force-patent-marker[data-patent=" + patent_no + "]");
          updateMarkerOnForceMap(marker, page_type);                        // update the marker appearance
        }
      }
      
      function updatePatentListTrackers(patList, $patList, patent_no, $pressedBtn) {
      // utility function called from removePatentFromMapped, deletePNode (when the node is a source node),
      // and removePatentFromFavorites; patList is "map" or "favorites", $patList is the jQuery object for the
      // $mappedList or $favoritesList patent lists on the Map page, $pressedBtn is the jQuery object for the
      // button that was clicked.
        toggleBtn(patent_no, $pressedBtn, "remove");
        $patList.find("div.patent-list-entry[data-patent='" + patent_no + "']").remove();
        patentLists[patList].splice(patentLists[patList].indexOf(patent_no), 1);
      }

      function on_click_new_patent_url_map(d, i) {
      // need to call the on_click_new_patent_url event handler set up by jQuery, which is expecting the event object
      // as the only argument and event data in event.data
        d3.event.data = {$context: document, page: "map"};
        on_click_new_patent_url.call(this, d3.event);
      }

      function on_click_new_search_url_map(d, i) {
      // need to call the on_click_new_search_url event handler set up by jQuery, which is expecting the event object
      // as the only argument
        on_click_new_search_url.call(this, d3.event);
      }

      function on_mouse_main_svg() {
      // when in "transparent" mode (no mouse events on div.pop1-containers), detect whether the mouse is over the
      // top visible biblio (div.pop1-container); if not, call mouse_leave_force_biblio to make the biblio disappear
      // the .elementFromPoint method only returns an element if pointer events are enabled on it
      // <a> elements do not pass mousemove events through them
//console.log("Hello from on_mouse_main_svg: ", d3.event);
        var evtTgt = d3.event.target
        // if a biblio is visible and event is from force plot (zoom_rect) or main svg area (svg_main)
        if (topBiblio && (evtTgt == zoom_rect.node() || evtTgt == svg_main.node())) {
          var divBib = topBiblio.divBib;
          switch (pParam.mouse) {
            // if div.pop1-containers are transparent to mouse events and there has been a div.pop1-container
            // under the mouse check if it is still under the mouse (there must never be more than one topBiblio)
            case "transparent":
              $(divBib.node()).off("mouseleave.biblio");              // remove jQuery mouseleave and mouseenter event handlers
              $(divBib.node()).off("mouseenter.biblio");              // they will be triggered otherwise
              topBiblio.divPop.classed({"pointer-events-none": false});              // activate mouse events
              topBiblio.gMarker.classed({"pointer-events-none": false});
              var topElement = document.elementFromPoint(d3.event.x, d3.event.y);    // see if the biblio is the topmost element
              topBiblio.divPop.classed({"pointer-events-none": true});
              topBiblio.gMarker.classed({"pointer-events-none": true});
              $(divBib.node()).on("mouseleave.biblio", on_mouseleave_force_biblio);  // reattach mouseleave and mouseenter
              $(divBib.node()).on("mouseenter.biblio", on_mouseenter_force_biblio);  // event handlers
              // note that topElement can be divPop, gMarker or any of its children that also capture mouse
              // events, so cannot simply test for topElement != divPop or gMarker.
              if (topElement == zoom_rect.node() || topElement == svg_main.node()) {
                mouseleave_force_biblio(divBib);
              }
              break;
            case "normal":                                     // sometimes (rarely) happens if mouse is moving very quickly
              mouseleave_force_biblio(divBib);                 // and the normal mouseleave event is somehow not triggered
              break;
          }
          if (pParam.transition  == 0) {
            forcePatent.alpha(Math.max(fMap.alpha, 0.06));
          }
          return;
        }
        if (d3.event.relatedTarget && (evtTgt == zoom_rect.node() || evtTgt == svg_main.node())
                 && pParam.mouse == "normal"  && pParam.transition == 0) {  // if mouse enters from a div.pop1-container or a
          forcePatent.alpha(Math.max(fMap.alpha, 0.06));                    // g.pop1-marker, .relatedTarget is not null
        }
      }

      function on_mousemove_force_patent(d, i) {
        if (!d.drag) {                             // stop event from bubbling up to svg_main handler
          d3.event.stopPropagation();              // unless the node is being dragged (exception prevents jerky dragging)
        }
      }

      function on_mouseover_force_patent(d, i) {
        if (!d.drag) {                             // stop event from bubbling up to svg_main handler
          d3.event.stopPropagation();              // unless the node is being dragged (exception prevents jerky dragging)
        }
        fMap.alpha = forcePatent.alpha();
        forcePatent.stop();
        var patent_no = d3.select(this).attr("data-patent");
console.log("Hello from mouseover_force_patent for patent " + patent_no);
        // there must never be more than one topBiblio at a time; the following block prevents buggy behavior caused
        // by moving the mouse very quickly over a forcePatent node, can sometimes fail to trigger a mouseenter/mouseleave
        // sequence on the associated biblio; if then move mouse quickly over a different forcePatent node without triggering
        // an event on the zoom_rect background, the original biblio does not disappear.
        if (topBiblio) {                                     // always make any old topBiblios disappear
          mouseleave_force_biblio(topBiblio.divBib);         // sets topBiblio = undefined
        }
        d3.select("text.node-label[data-patent=" + patent_no + "]").classed({"visited-label": true});
        var divBib = d3.select("div.bib[data-patent=" + patent_no + "]");
        var divPop = divBib.select("div.pop1-container");
        var gMarker = divBib.select("g.pop1-marker");
        if (!divBib.datum().pinned) {                        // if the biblio is not pinned (i.e., not already visible)
          var bibLink = plot.select("line.biblio-link[data-patent=" + patent_no + "]");
          divBib.call(updateBib);                            // update current forceBiblio map coordinates of the parent div.bib
          bibLink.call(updateBLink);                         // update bLink position before displaying
          divPop.classed({"make-displayed": true});
          bibLink.classed({"make-displayed": true});
          divBib.select("svg.pop1-arrow-circle").classed({"make-displayed": true});
          visBibs = allBiblioNodes.filter(hasPop1Displayed);       // re-select div.bibs whose biblios are visible
          // reselect line.biblio-links whose biblios are visible; make sure to update visBibs first
          visBibLinks = allBiblioLinks.filter(function(d, i) {return d.biblioNode.displayed});
        }
        topBiblio = {"divBib": divBib, "divPop": divPop, "gMarker": gMarker};
        mouseenter_force_biblio(divBib);
      }

      function mouseenter_force_biblio(divBib) {
      // divBib is a d3 div.bib; function is called from on_mouseover_force_patent (g.node)
      // and on_mouseenter_force_biblio (div.pop1-container) event handlers
        var patent_no = divBib.attr("data-patent");
console.log("Hello from mouseenter_force_biblio function for patent " + patent_no, topBiblio);
        // there must never be more than one topBiblio at a time
        divBib.style({"z-index": pParam.zMax + 1});          // bring to front temporarily
        if (pParam.mouse == "normal") {                      // only show map, favorites, pin, and delete buttons in "normal" mode
          divBib.select("div.pop1-buttons").classed({"make-visible": true});
        }
        // highlight pLinks and bLinks to the node
        highlightLinks(patent_no);
      }

      function highlightLinks(patent_no) {
      // highlight the link lines to patent_no on the force map
        allPatentLinks.filter(function(d, i) {return (d.source.patent_no == patent_no || d.target.patent_no == patent_no);})
                      .style({"stroke-width": function(d, i) {return (d.source.patent_no == patent_no) ? "3px" : "4px";}});
        allBiblioLinks.filter(function(d, i) {return (d.patentNode.patent_no == patent_no);})
                      .style({"stroke-width": "3px"});
      }

      function unhighlightLinks(patent_no) {
      // unhighlight the link lines to patent_no on the force map
        allPatentLinks.filter(function(d, i) {return (d.source.patent_no == patent_no || d.target.patent_no == patent_no);})
                      .style({"stroke-width": "1px"});
        allBiblioLinks.filter(function(d, i) {return (d.patentNode.patent_no == patent_no);})
                      .style({"stroke-width": "1px"});
      }

      function on_mouseout_force_patent(d, i) {
      // placeholder at this point
//console.log("Hello from mouseout_force_patent");
      }

      function on_mouseenter_force_biblio(event) {
      // jQuery event handler for div.bib when it is capturing mouse events
//        event.stopPropagation();
        var divBib = d3.select(this);                        // note 'this' is passed by jQuery
        // there must never be more than one topBiblio at a time; the following block prevents buggy behavior caused
        // by moving the mouse very quickly over a forcePatent node, can sometimes fail to trigger a mouseenter/mouseleave
        // sequence on the associated biblio; if then move mouse quickly over a different pinned biblio without triggering
        // an event on the zoom_rect background, the original one does not disappear.
        // always make any old topBiblios disappear:
        if (topBiblio && (topBiblio.divBib.datum().patent_no != divBib.datum().patent_no)) {
          mouseleave_force_biblio(topBiblio.divBib);         // sets topBiblio = undefined
        }

        // if divBib is not already the active biblio because we did not enter the biblio via
        // on_mouseover_force_patent, but entered a pinned biblio directly 
        if (divBib.style("z-index") != pParam.zMax + 1) {
          mouseenter_force_biblio(divBib);
        }
      }

      function on_mouseleave_force_biblio(event) {
      // jQuery event handler for div.pop1-container when it is capturing mouse events ("normal" mouse mode); use the jQuery
      // mouseleave event, which fires when the mouse leaves the element to which the event handler is attached.  In the
      // present case, the div.pop1-container is the parent of child elements that trigger mouseover and mouseout
      // events when the mouse enters and leaves each one; mouseleave is only triggered when the mouse leaves the parent
      // div.pop1-container.
        var divBib = d3.select(this);                    // note 'this' is passed by jQuery
        // condition needed because mouseleave event always triggers when entering "transparent" mode and need to prevent
        // the biblio from disappearing when it is not pinned
        if (pParam.mouse == "normal" || divBib.datum().pinned) {
//console.log("Hello from mouseleave_force_biblio event handler");
          mouseleave_force_biblio(divBib);
        }
        else {                    // special case when mouseleave is triggered during transition from "normal" to "transparent"
          divBib.select("div.pop1-buttons").classed({"make-visible": false});
        }
      }

      function mouseleave_force_biblio(divBib) {
      // divBib is a d3 div.bib; function is called from the div.bib
      // mouseleave event handler and from on_mouseover_force_patent and on_mouse_main_svg
      // as part of simulating a mouseout event on a div.pop1-container when it is transparent to mouse events
        var patent_no = divBib.attr("data-patent");
console.log("Hello from mouseleave_force_biblio function for patent " + patent_no);
        if (!divBib.datum().pinned) {                         // if the biblio is not pinned (i.e., already visible)
          if (!divBib.datum().transition) {                   // if the biblio is not transitioning back to its patent node
            divBib.select("div.pop1-container").classed({"make-displayed": false});
            plot.select("line.biblio-link[data-patent=" + patent_no + "]").classed({"make-displayed": false});
            divBib.select("svg.pop1-arrow-circle").classed({"make-displayed": false});
          }
          visBibs = allBiblioNodes.filter(hasPop1Displayed);       // re-select div.bibs whose biblios are visible
          // reselect line.biblio-links whose biblios are visible; make sure to update visBibs first
          visBibLinks = allBiblioLinks.filter(function(d, i) {return d.biblioNode.displayed});
        }
        topBiblio = undefined;
        divBib.style({"z-index": function(d, i) {return d.z_index;}});     // set z_index back to original position
        divBib.select("div.pop1-buttons").classed({"make-visible": false});  // return map, favorite, etc buttons to default state
        // normal width pLinks and bLinks to the node
        unhighlightLinks(patent_no);
      }

      function on_click_pin_btn(d, i) {
      // event handler for clicking the pin/unpin button, in which case 'this' is the span element for the pin button
console.log("Hello from on_click_pin_btn");
        var divBib = d3.select("div.bib[data-patent=" + d.patent_no + "]");
        var coord = {};
        $.extend(coord, {"x": d3.event.x, "y": d3.event.y});   // clone the d3.event properties as they will disappear later
        // when biblio is unpinned, the mousedown/mouseup sequence triggers the biblio dragstart/dragend handlers;
        // the biblio returns to the forcePatent node due to setting the forcePatent alpha value at the end of
        // dragend, which causes all positions to update; the biblio will also disappear if the mouseleave event is
        // triggered by the biblio moving out from under the mouse
        if (d.pinned) {                                            // unpin the biblio
          fMap.alpha = forcePatent.alpha();
          // stop the forcePatent force map to prevent biblio returning immediately to the patentNode; 
          // forceBiblio is automatically started during any biblio drag operation, but is stopped in the
          // dragend handler for the biblio.
          forcePatent.stop();
          $(divBib.node()).on("mousemove.transition", on_mousemove_unpinned_biblio);       // jQuery event
          makeBiblioUnpinned(divBib);
          // set up the new biblio position back at the node
          d.x = d.patentNode.x; d.y = d.patentNode.y;
          d.updatePlotCoord();                                     // biblio .datum() now has the new plot coordinates
          // use d3 to make a CSS transition in the transform property (doing up the transition using the CSS 'transition'
          // does not seem to mix well with doing the next transition on the biblioLink using d3; the biblio transition
          // gets canceled) 
          d.transition = true;
          pParam.transition += 1;                                  // number of biblios transitioning
          divBib.transition().ease("linear").duration(1000*pParam.transformTime)
                             .style({"-webkit-transform": "matrix(1,0,0,1," + d.plotX + "," + d.plotY + ")",
                                     "transform ": "matrix(1,0,0,1," + d.plotX + "," + d.plotY + ")"})
                             .each("end", on_transitionend_unpinned_biblio);
          d3.select("line.biblio-link[data-patent=" + d.patent_no + "]").transition() // trigger the animation on the biblio-link
                     .ease("linear").duration(1000*pParam.transformTime)
                     .attr({"x2": d.plotX, "y2": d.plotY});
          var transTimeout = window.setTimeout(checkMouseOverBiblio, 50);
        }
        else {                                                                       // pin the biblio
          makeBiblioPinned(divBib);
          makeBiblioPinnedTop(divBib);
        }

        function checkMouseOverBiblio() {
        // timeout function to check if mouse is still over divBib; set d.mouseleave accordingly
          d.mouseleave = !isMouseOverBiblio(divBib, coord);
//console.log("Hello from checkMouseOverBiblio");
          if (!d.mouseleave && d.transition) {                                       // if mouse still over biblio during
            transTimeout = window.setTimeout(checkMouseOverBiblio, 50);              // transition check again in 50 msec
          }
        }

        function on_transitionend_unpinned_biblio(dd, ii) {
        // note that the d3.event object is not available for d3 transition 'end' events
        // called when the biblio is finished moving back to its patentNode in on_click_pin_btn
console.log("Hello from on_transitionend_unpinned_biblio");
          window.clearTimeout(transTimeout);
          var divBib = d3.select(this);
          // fires when the transition of the unpinned biblio back to its forcePatent node is complete
          if (d.mouseleave) {                                                    // if mouse is no longer over the biblio
            d.mouseleave = false;                                                // animate its disappearance at the node
            divBib.transition().duration(1000*pParam.opacityTime)
                               .style({"opacity": 0})                            // animate disappearance of biblio at the node
                               .each("end", on_transitionend_opacity_biblio);
          }
          else {
            d.transition = false;                                                // transition ended with mouse still over biblio
            pParam.transition -= 1;
            if (pParam.transition  == 0) {
              forcePatent.alpha(Math.max(fMap.alpha, 0.06));
            }
          }
          $(divBib.node()).off("mousemove.transition");                          // remove transition mousemove handler
        }

        function on_transitionend_opacity_biblio(dd, ii) {
        // fires when the transition of the biblio to transparent is complete (if biblio is no longer under mouse)
        // note that the d3.event object is not available for d3 transition 'end' events
console.log("Hello from on_transitionend_opacity_biblio");
          d.transition = false;                                               // transition ended with mouse no longer over biblio
          pParam.transition -= 1;
          var divBib = d3.select(this);
          if (divBib.style("z-index") != d.z_index) {                          // mouseleave was never called; biblio still on top
            mouseleave_force_biblio(divBib);                                   // call the normal mouseleave function
          }
          else {                                                               // mouseleave was called with d.transition = true
            divBib.select("div.pop1-container").classed({"make-displayed": false});   // make the remaining changes that were
            plot.select("line.biblio-link[data-patent=" + d.patent_no + "]").classed({"make-displayed": false});
            divBib.select("svg.pop1-arrow-circle").classed({"make-displayed": false}); // postponed in mouseleave_force_biblio
          }
          divBib.style({"opacity": 1});                                        // reset to normal value
          if (pParam.transition  == 0) {
            forcePatent.alpha(Math.max(fMap.alpha, 0.06));
          }
        }

        function on_mousemove_unpinned_biblio(event) {                         // handling jQuery event
console.log("Hello from on_mousemove_unpinned_biblio; coord:");
        // update coord if user moves the mouse while the biblio is transitioning; also triggered by disappearance of
        // the pin/unpin button and its replacement under the mouse by the delete button; then as the biblio moves, it
        // is triggered as new biblio HTML elements move under the mouse pointer.
          $.extend(coord, {"x": event.clientX, "y": event.clientY});   // clone the event properties as they will disappear later
        }
      }

      function isMouseOverBiblio(divBib, coord) {
      // part of routine used in transitioning an unpinned biblio back to its patentNode; use elementFromPoint and
      // jQuery .find() to detemine if mouse at coordinates coord is over the divBib biblio
        var curElement = document.elementFromPoint(coord.x, coord.y);
        var $findElement = $(divBib.node()).find(curElement);          // jQuery here
        return ($findElement.size() > 0);
      }

      function makeBiblioPinned(divBib) {
      // make the style changes associated with pinning a biblio; called from checkPinTrigger during dragging and
      // from on_click_pin_btn event handler on the pin/unpin button
        divBib.datum().pinned = true;
        divBib.datum().detached = false;
        divBib.select("span.btn-pin-add")
              .classed({"btn-pin-add-display": true, "show-result-btn": true}); // show button; give it the pressed look
        divBib.select("path.pop1-arrow").classed({"make-hidden": true});      // hide the arrow pointing to the patent node
        divBib.select("circle.pop1-marker").classed({"ghost-marker": false}); // no dashed outline for node circle
      }

      function makeBiblioPinnedTop(divBib) {
      // style changes that need to happen after dragging is finished; called from checkPinTrigger during dragging and
      // from on_click_pin_btn event handler on the pin/unpin button
        divBib.select("div.pop1-top-capture").classed({"make-not-displayed": true});
        divBib.select("svg.pop1-arrow-circle").classed({"make-displayed": false});   // default is marker not displayed
      }

      function makeBiblioUnpinned(divBib) {
      // make the style changes associated with unpinning a biblio; called from checkPinTrigger during dragging and
      // from on_click_pin_btn event handler on the pin/unpin button
        divBib.datum().pinned = false;
        divBib.datum().detached = false;
        divBib.select("span.btn-pin-add")
              .classed({"btn-pin-add-display": false, "show-result-btn": false});// do not show button; give it unpressed look
        divBib.select("svg.pop1-arrow-circle").classed({"make-displayed": true});   // default is marker not displayed
        divBib.select("div.pop1-top-capture").classed({"make-not-displayed": false});  // back to default
        divBib.select("path.pop1-arrow").classed({"make-hidden": false});     // hide the arrow pointing to the patent node
        divBib.select("circle.pop1-marker").classed({"ghost-marker": false}); // no dashed outline for node circle
      }

      function makeBiblioDetached(divBib) {
      // make the style changes associated with putting biblio in the detached state; called from checkPinTrigger
      // when dragging a biblio or a patent node
        divBib.datum().pinned = false;
        divBib.datum().detached = true;
        divBib.select("span.btn-pin-add")
              .classed({"btn-pin-add-display": false, "show-result-btn": false});// do not show button; give it unpressed look
        divBib.select("svg.pop1-arrow-circle").classed({"make-displayed": true});   // default is marker not displayed
        divBib.select("div.pop1-top-capture").classed({"make-not-displayed": false});  // back to default
        divBib.select("path.pop1-arrow").classed({"make-hidden": false});     // hide the arrow pointing to the patent node
        divBib.select("circle.pop1-marker").classed({"ghost-marker": true});  // dashed outline for node circle
      }

      function on_mouseover_top_buttons_biblio(d, i) {
      // event handler attached to div.pop1-top-buttons, handling mouseover event on front, back, full/short buttons;
      // had a lot a trouble getting svg buttons to pop up all the time; found the solution at:
      // http://stackoverflow.com/questions/3485365/how-can-i-force-webkit-to-redraw-repaint-to-propagate-style-changes
      // when style changes, and re-draw is needed, apparently Chrome has some issues; need to force a redraw; can do
      // a couple ways - one shown below and the other is to simply access the .offsetHeight or other property which
      // forces the browser to check the visual layout and apparently update it in the process; problem occurs in event
      // handlers only
        d3.event.stopPropagation;
        var divTop = d3.select(this);
        var patent_no = divTop.attr("data-patent");
        var divBib = d3.select("div.bib[data-patent=" + patent_no + "]");
        divBib.on("mousedown.drag", null);                      // remove drag handler from the div.bib
        divTop.classed({"make-visible": true});
        divTop.classed({"make-not-displayed": true});           // force redraw - step 1 set display to none
        document.elementFromPoint(d3.event.x, d3.event.y);      // step 2 - force browser to check which element is on top
        divTop.classed({"make-not-displayed": false});          // step 3 - set display back to block
      }

      function on_mouseout_top_buttons_biblio(d, i) {
      // event handler attached to div.pop1-top-buttons, handling mouseover event on front, back, full/short buttons
        var divTop = d3.select(this);
        var patent_no = divTop.attr("data-patent");
        var divBib = d3.select("div.bib[data-patent=" + patent_no + "]");
        divBib.call(force_biblio_drag);                         // reattach drag handler to div.bib
        divTop.classed({"make-visible": false});
      }

      function on_click_top_buttons_biblio(d, i) {
      // event handler is attached to the div.pop1-top-btns element; event target elements are
      // rect.pop1-full-btn, rect.pop1-close-btn, rect.pop1-front-btn, and rect.pop1-back-btn.
        d3.event.stopPropagation();
        d3.event.preventDefault();
        var patent_no = d3.select(this).attr("data-patent");
        var clickedBtn = d3.select(d3.event.target);
        switch (true) {
          case clickedBtn.classed("pop1-full-btn"):                        // go to the full biblio
//            d3.select("div.bib-container").classed({"bib-container-front": true}); // block mouse events from reaching the force map
            var divPop = d3.select("div.pop1-container[data-patent=" + patent_no+"]");
            divPop.selectAll("div.pop1-inventors, div.pop1-abstract").classed({"make-displayed": true});
//            d3.select("div.bib[data-patent=" + patent_no + "]")
//              .style({"-webkit-transform": "translate(" + plotWidth/2 + "px," + Math.max((plotHeight - $(divPop.node()).outerHeight())/2, 20) + "px)",      // Chrome; use jQuery outerHeight() method to get dimensions of the div.pop1-container
//                      "transform": "translate(" + plotWidth/2 + "px," + Math.max((plotHeight - $(divPop.node()).outerHeight())/2, 20) + "px)"});            // FireFox
            d3.select(this).select("g.pop1-close").classed({"make-not-displayed": false});
            d3.select(this).select("g.pop1-full").classed({"make-not-displayed": true});
            break;
          case clickedBtn.classed("pop1-close-btn"):                       // go to the short biblio - undo changes above
            d3.select(this).select("g.pop1-full").classed({"make-not-displayed": false});
            d3.select(this).select("g.pop1-close").classed({"make-not-displayed": true});
//            d3.select("div.bib[data-patent=" + patent_no+"]")
//              .style({"-webkit-transform": function(d, i) {return "translate(" + d.plotX + "px," + d.plotY + "px)";},            // Chrome
//                      "transform": function(d, i) {return "translate(" + d.plotX + "px," + d.plotY + "px)";}});                  // FireFox
            var divPop = d3.select("div.pop1-container[data-patent=" + patent_no+"]");
            divPop.selectAll("div.pop1-inventors, div.pop1-abstract").classed({"make-displayed": false});
//            d3.select("div.bib-container").classed({"bib-container-front": false});
            break;
          case clickedBtn.classed("pop1-front-btn"):
            pParam.zMax += 1;
            d3.select(this).datum().z_index = pParam.zMax;
//            d3.select("div.bib[data-patent=" + patent_no+"]").style({"z-index": pParam.zMax});  // must set z-index on siblings
            break;
          case clickedBtn.classed("pop1-back-btn"):
            pParam.zMin -= 1;
            d3.select(this).datum().z_index = pParam.zMin;
//            d3.select("div.bib[data-patent=" + patent_no+"]").style({"z-index": pParam.zMin});
            break;
        }
      }

      function on_click_change_mouse_mode(d, i) {
      // called from the zoom rectangle (zoom_rect), biblio containers (div.pop1-container), and force plot container
      // (g.force-plot)
//        console.log("In on_click_change_mouse_mode, event and target are: ", d3.event, d3.event.target);
        // event.defaultPrevented is set true if the click event was from a drag (see d3js force.drag() documentation)
        if (d3.event.shiftKey && !d3.event.defaultPrevented) {
          d3.event.preventDefault();     // prevents Shift-click from opening new browser window from links in biblio!
          d3.event.stopPropagation();
          switch (pParam.mouse) {
            case "normal":
console.log("Mouse mode changed from normal to transparent");
              // changing pointer-events on div.pop1-container propagates to children div.pop1-buttons, a.pop1-patent-url,
              // and a.pop1-search-url
              pParam.mouse = "transparent";
              // setting pointer-events to none on div.pop1-container will always trigger the mouseleave event
              // when the mouse is over it; cannot prevent it by removing the mouseleave event handler in the
              // present event handler; note that if the mouse is on a pinned biblio, we do want to trigger the mouseleave
              // event so the link highlighting and the z-index get reset to their defaults
              d3.selectAll("g.pop1-marker").classed({"pointer-events-none": true});      // markers for bilibos
              d3.selectAll("div.pop1-container").classed({"pointer-events-none": true}); // triggers mouseleave over pinned biblio
              d3.selectAll("rect.pop1-top-btn").classed({"pointer-events-none": true});  // all pop1-top-btns
              $("span.mouse-mode-state").text("Transparent");
              break;
            case "transparent":
console.log("Mouse mode changed from tranparent to normal");
              // changing pointer-events on div.pop1-container propagates to children div.pop1-buttons, a.pop1-patent-url,
              // and a.pop1-search-url
              pParam.mouse = "normal";
              d3.selectAll("div.pop1-container").classed({"pointer-events-none": false});  // will fire mouseenter event
              d3.selectAll("g.pop1-marker").classed({"pointer-events-none": false});       // markers for biblios
              d3.selectAll("rect.pop1-top-btn").classed({"pointer-events-none": false});   // all pop1-top-btns
              $("span.mouse-mode-state").text("Normal");
              break;
          }
        }
      }

      function on_mouseover_focus_main_svg(d, i) {
      // give document the focus when mouse moves over svg_main so the Shift-click behavior works the first time
console.log("Hello from on_mouseover_focus_main_svg");
        window.focus();
        $(document).click();
      }

      function on_keydown_document(d, i) {
      // detect if shift key is pressed
        if (!pParam.shiftKey && d3.event.shiftKey) {                       // if this is the first keydown event
console.log("Hello from on_keydown_document");
          pParam.shiftKey = true;
          allBiblioNodes.select("div.pop1-container").classed({"default-cursor": true});  // disable the 'move' cursor
          allBiblioNodes.selectAll("span.hide-result-btn").classed({"default-cursor": true});  // disable the 'pointer' cursor
          allBiblioNodes.selectAll("a.pop1-patent-url, a.pop1-search-url").classed({"default-cursor": true});
          allBiblioNodes.select("g.pop1-marker").classed({"default-cursor": true});
          allPatentNodes.select("circle").classed({"default-cursor": true});
        }
      }

      function on_keyup_document(d, i) {
      // detect if shift key is released
        if (d3.event.keyCode == 16) {                                      // the shift key
console.log("Hello from on_keyup_document");
          pParam.shiftKey = false;
          allBiblioNodes.select("div.pop1-container").classed({"default-cursor": false});  // disable the 'move' cursor
          allBiblioNodes.selectAll("span.hide-result-btn").classed({"default-cursor": false});
          allBiblioNodes.selectAll("a.pop1-patent-url, a.pop1-search-url").classed({"default-cursor": false});
          allBiblioNodes.select("g.pop1-marker").classed({"default-cursor": false});
          allPatentNodes.select("circle").classed({"default-cursor": false});
        }
      }

      function on_mousedown_change_mouse_mode(d, i) {
      // needed for Shift-click behavior
        console.log("Hello from on_mousedown_change_mouse_mode");
        if (d3.event.shiftKey && !d3.event.defaultPrevented) {
          d3.event.preventDefault();     // prevents Shift-click from opening new browser window from links in biblio!
          d3.event.stopImmediatePropagation();
        }
      }

      function on_mouseup_change_mouse_mode(d, i) {
      // needed for Shift-click behavior
        console.log("Hello from on_mouseup_change_mouse_mode");
        if (d3.event.shiftKey && !d3.event.defaultPrevented) {
          d3.event.preventDefault();     // prevents Shift-click from opening new browser window from links in biblio!
          d3.event.stopImmediatePropagation();
        }
      }

      function on_mousedown_no_drag(d, i) {
      // event handler attached to all links and buttons (map, fav, etc) within a biblio; do not let mousedown
      // initiate a drag event.
        d3.event.stopPropagation();
      }

      function addPopArrowCircleSVG(bibDiv) {
      // add svg for arrow and node circle at top of biblio
        var bibArrowCircle = bibDiv.append("svg:svg").classed({"pop1-arrow-circle": true})
                       .attr({"data-patent": function(d, i) {return d.patent_no;}});
        bibArrowCircle.append("svg:path").classed({"pop1-arrow": true})
                      .attr({"d": "M 0,0 L 0,8 8,0 z", "transform": "translate(12, 12) rotate(45)"});
        var bibMarker = bibArrowCircle.append("svg:g").classed({"pop1-marker": true})
                      .attr({"transform": "translate(12, 12)"});
        bibMarker.append("svg:rect").attr({"x": "-7px", "y": "0px", "width": "14px", "height": "9px"});
        bibMarker.append("svg:circle").classed({"pop1-marker": true})
                      .attr({"r": function(d, i) {return d.patentNode.markerRadius;},
                             "cx": "0px", "cy": "0px"});
      }

      function addPopTopBtns(bibDiv) {
      // add svg for the buttons at the top right of the bible
        var svgTopBtn = bibDiv.select("div.pop1-top-btns").append("svg:svg").classed({"pop1-top-btns-svg": true});
        svgTopBtn.append("svg:clipPath").attr({"id": "leftBtn"})
                 .append("svg:rect").attr({"x": "-11px", "y": "-11px", "width": "21px", "height": "22px"});
        svgTopBtn.append("svg:clipPath").attr({"id": "midBtn"})
                 .append("svg:rect").attr({"x": "-10px", "y": "-11px", "width": "20px", "height": "22px"});
        svgTopBtn.append("svg:clipPath").attr({"id": "rightBtn"})
                 .append("svg:rect").attr({"x": "-10px", "y": "-11px", "width": "21px", "height": "22px"});
        var gPop1Front = svgTopBtn.append("svg:g").classed({"pop1-front": true}).attr({"clip-path": "url(#leftBtn)"});
        gPop1Front.append("svg:title").text("Bring to front");
        gPop1Front.append("svg:rect").classed({"pop1-top-btn": true, "pop1-front-btn": true})
                  .attr({"x": "-10px", "y": "-10px", "rx": "7px", "ry": "7px", "width": "20px", "height": "20px"});
        gPop1Front.append("svg:rect").classed({"pop1-front-back-unfilled": true})
                  .attr({"x": "-5px", "y": "-5px", "width": "7px", "height": "7px"});
        gPop1Front.append("svg:rect").classed({"pop1-front-back-filled": true})
                  .attr({"x": "-2px", "y": "-2px", "width": "7px", "height": "7px"});
        var gPop1Back = svgTopBtn.append("svg:g").classed({"pop1-back": true}).attr({"clip-path": "url(#midBtn)"});
        gPop1Back.append("svg:title").text("Send to back");
        gPop1Back.append("svg:rect").classed({"pop1-top-btn": true, "pop1-back-btn": true})
                  .attr({"x": "-10px", "y": "-10px", "rx": "7px", "ry": "7px", "width": "20px", "height": "20px"});
        gPop1Back.append("svg:rect").classed({"pop1-front-back-filled": true})
                  .attr({"x": "-5px", "y": "-5px", "width": "7px", "height": "7px"});
        gPop1Back.append("svg:rect").classed({"pop1-front-back-unfilled": true})
                  .attr({"x": "-3px", "y": "-3px", "width": "8px", "height": "8px"});
        var gPop1Full = svgTopBtn.append("svg:g").classed({"pop1-full": true}).attr({"clip-path": "url(#rightBtn)"});
        gPop1Full.append("svg:title").text("Full view");
        gPop1Full.append("svg:rect").classed({"pop1-top-btn": true, "pop1-full-btn": true})
                  .attr({"x": "-10px", "y": "-10px", "rx": "7px", "ry": "7px", "width": "20px", "height": "20px"});
        gPop1Full.append("svg:rect").classed({"pop1-full-rect": true})
                  .attr({"x": "-5px", "y": "-4px", "width": "10px", "height": "8px"});
        var gPop1Short = svgTopBtn.append("svg:g").classed({"pop1-close": true, "make-not-displayed": true})
                                  .attr({"clip-path": "url(#rightBtn)"});
        gPop1Short.append("svg:title").text("Popup view");
        gPop1Short.append("svg:rect").classed({"pop1-top-btn": true, "pop1-close-btn": true})
                  .attr({"x": "-10px", "y": "-10px", "rx": "7px", "ry": "7px", "width": "20px", "height": "20px"});
        gPop1Short.append("svg:line").classed({"pop1-close-x1": true})
                  .attr({"x1": "-8px", "y1": "0px", "x2": "8px", "y2": "0px"});
        gPop1Short.append("svg:line").classed({"pop1-close-x2": true})
                  .attr({"x1": "-8px", "y1": "0px", "x2": "8px", "y2": "0px"});
      }

      function createNodeLegend() {
      // use d3js to create the svg for the node legend at the bottom left of the force map; nodeLegend is the
      // d3js containing 'g' element
        var gNodeLegend = nodeLegend.append("svg:g").classed({"node-legend": true})
                                    .attr({"transform": "translate(71,54)"});
        gNodeLegend.append("svg:line").classed({"node-legend-cited": true})
                   .attr({"x1": "0", "y1": "0", "x2": "-40", "y2": "0"});
        gNodeLegend.append("svg:line").classed({"node-legend-citing": true})
                   .attr({"x1": "0", "y1": "0", "x2": "20", "y2": "-35"});
        gNodeLegend.append("svg:line").classed({"node-legend-related": true})
                   .attr({"x1": "0", "y1": "0", "x2": "20", "y2": "35"});
        var gNodeLegendMap = gNodeLegend.append("svg:g").attr({"transform": "translate(0,0)"});
        gNodeLegendMap.append("svg:circle").classed({"node-legend-node": true})
                      .attr({"r": "10", "cx": "0", "cy": "0"});
        gNodeLegendMap.append("svg:use").attr({"xlink:href": "#force-mapped-cross-def"});
        var gNodeLegendMapText = gNodeLegendMap.append("svg:text").classed({"node-label": true})
                      .attr({"text-anchor": "middle", "x": "30", "y": "-8"})
                      .text("Mapped");
        gNodeLegendMapText.append("svg:tspan")
                          .attr({"text-anchor": "middle", "x": "30", "y": "4"})
                          .text("patent");
        var gNodeLegendCited = gNodeLegend.append("svg:g").attr({"transform": "translate(-40,0)"});
        gNodeLegendCited.append("svg:circle").classed({"node-legend-node": true})
                        .attr({"r": "7", "cx": "0", "cy": "0"});
        var gNodeLegendCitedText = gNodeLegendCited.append("svg:text").classed({"node-label": true})
                      .attr({"text-anchor": "middle", "x": "0", "y": "-20"})
                      .text("Cited patent");
        gNodeLegendCitedText.append("svg:tspan")
                          .attr({"text-anchor": "middle", "x": "0", "y": "-8"})
                          .text("(USPTO)");
        var gNodeLegendCiting = gNodeLegend.append("svg:g").attr({"transform": "translate(20,-35)"});
        gNodeLegendCiting.append("svg:circle").classed({"node-legend-node": true})
                        .attr({"r": "7", "cx": "0", "cy": "0"});
        var gNodeLegendCitingText = gNodeLegendCiting.append("svg:text").classed({"node-label": true})
                      .attr({"text-anchor": "middle", "x": "-31", "y": "-11"})
                      .text("Citing patent");
        gNodeLegendCitingText.append("svg:tspan")
                          .attr({"text-anchor": "middle", "x": "-31", "y": "1"})
                          .text("(USPTO)");
        var gNodeLegendRelated = gNodeLegend.append("svg:g").attr({"transform": "translate(20,35)"});
        gNodeLegendRelated.append("svg:circle").classed({"node-legend-node": true})
                        .attr({"r": "7", "cx": "0", "cy": "0"});
        var gNodeLegendRelatedText = gNodeLegendRelated.append("svg:text").classed({"node-label": true})
                      .attr({"text-anchor": "middle", "x": "-32", "y": "-10"})
                      .text("Related patent");
        gNodeLegendRelatedText.append("svg:tspan")
                          .attr({"text-anchor": "middle", "x": "-32", "y": "2"})
                          .text("(Google)");
        var bBox = nodeLegend.node().getBBox();                        // get bounding box of an SVG element
        nodeLegend.insert("svg:rect", ":first-child").classed({"legend-frame": true})
                       .attr({"x": "-4", "y": "-4", "width": bBox.width + 11, "height": bBox.height + 8});
      }

      var compiledMappedListEntryTemplate = _.template( $("script#mapped-list-entry-section").html());
      var compiledFavoritesListEntryTemplate = _.template( $("script#favorites-list-entry-section").html());
      var compiledPatentListBiblioTemplate = _.template( $("script#patent-list-patent-section").html());
      var compiledPatentListCitationsTemplate = _.template( $("script#patent-list-reference-section").html());
      var $mappedList = $("div.patent-list[data-listname='mapped']");         // global variables for the jQuery elements for the
      var $favoritesList = $("div.patent-list[data-listname='favorites']");   // Mapped and Favorites lists on the Mapped page

      function addTargetPatentToMappedSublist($sourceContainer, source_patent, target_patent, citation_type, undeleted) {
      // add the biblio info for target_patent to the list of referenced patents of type 'type' for source_patent in the
      // Mapped patent list; 'type' is 'cited', 'citing', or 'related'; $sourceContainer is the div.patent-list-patent-container
      // for the source patent in the Mapped patent list; 'undelete' is a boolean indicating whether target_patent was
      // deleted and then undeleted; called from addEPOPatentDataToForceMap and mapExistingTargetPatents
        // addTargetPatentToForceMap has already been called, so patent will only be in patentsPlotted if it was not
        // deleted previously
        var $citationSectionHeading = $sourceContainer.find("div.patent-list-" + citation_type + "-heading");
        if (target_patent in patentsPlotted) {
          incrementCitationCount($citationSectionHeading, "mapped", 1);
          if (undeleted) {
            incrementCitationCount($citationSectionHeading, "deleted", -1);
          }
          var $refsContainer = $sourceContainer.find("div.patent-list-" + citation_type +
                                                     "-patents div.patent-list-subpatent-container");
          var refBiblio = epoBiblio[target_patent];
          var refPatentHTML = compiledPatentListBiblioTemplate(
                              {"patent_no": target_patent, "patent_label": makePatentLabel(target_patent),
                               "source_patent": source_patent, "title": refBiblio["title"], "file_date": refBiblio["file_date"]});
          $refsContainer.append(refPatentHTML);
          var $refPatent = $refsContainer.find("div.patent-list-patent[data-patent='" + target_patent + "']");
          setupMapFavButtons($refPatent, document, "mapped-list", target_patent);
          setupDeleteButton($refPatent, target_patent);
          setupPatentLink($refPatent, "mapped-list");
          setupPatentHighlight($refPatent, target_patent, "mapped-list");
          setupPatentFullView($refPatent, target_patent, "mapped-list");
        }
        else {
          incrementCitationCount($citationSectionHeading, "deleted", 1);
        }
      }

      function addSourcePatentToMappedList(patent_no) {
      // create an entry for patent_no in the Mapped patents list on the Mapped page; uses global variables
      // $mappedList and patentBiblio; called from processSourcePatent.
        var patentObj = patentBiblio[patent_no];
        var patentEntryHTML = compiledMappedListEntryTemplate({"patent_no": patent_no});
        $mappedList.find("div.patent-list-patents").prepend(patentEntryHTML);                         // add at beginning of list
        var $patentEntry = $mappedList.find("div.patent-list-entry[data-patent='" + patent_no + "']");
        var $patentContainer = $patentEntry.find("div.patent-list-patent-container");
        var patentSectionHTML = compiledPatentListBiblioTemplate(
                                {"patent_no": patent_no, "patent_label": makePatentLabel(patent_no), "source_patent": patent_no,
                                 "title": patentObj["title"], "file_date": patentObj["file_date"]});
        $patentContainer.append(patentSectionHTML);
        nCited = patentObj["cited_patents"].length;
        nCiting = patentObj["citing_patents"].length;
        nRelated = patentObj["related_patents"].length;
        var citedSectionHTML = compiledPatentListCitationsTemplate(
               {"patent_no": patent_no, "citation_type": "cited", "citation_no": nCited, "citation_heading": "Cited patents"});
        var citingSectionHTML = compiledPatentListCitationsTemplate(
               {"patent_no": patent_no, "citation_type": "citing", "citation_no": nCiting, "citation_heading": "Citing patents"});
        var relatedSectionHTML = compiledPatentListCitationsTemplate(
               {"patent_no": patent_no, "citation_type": "related", "citation_no": nRelated,
                "citation_heading": "Related patents - Google"});
        $patentContainer.append(citedSectionHTML);
        $patentContainer.append(citingSectionHTML);
        $patentContainer.append(relatedSectionHTML);
        // add click handlers for dropdown/dropup arrows
        $patentEntry.find("div.patent-list-dropdown-arrow").on("click", on_click_patent_dropdown);
        $patentContainer.find("div.citation-list-dropdown-arrow").on("click", on_click_citation_dropdown);
        setupMapFavButtons($patentContainer, document, "mapped-list", patent_no);
        setupDeleteButton($patentContainer, patent_no);
        setupPatentLink($patentContainer, "mapped-list");
        setupPatentHighlight($patentContainer, patent_no, "mapped-list");
        setupPatentFullView($patentContainer, patent_no, "mapped-list");
      }

      function incrementCitationCount($citationSectionHeading, count_type, increment) {
      // change the count of count_type 'mapped' or 'deleted' citations by increment for citations of type
      // citation_type under the $citationSectionHeading jQuery element (div.patent-list-'citation_type'-heading).
      // called from addTargetPatentToMappedSublist and deletePatentFromMappedSublists
        switch (count_type) {
          case "mapped":
            var $spanCount = $citationSectionHeading.find("span.patent-list-citation-mapped");
            break;
          case "deleted":
            var $spanCount = $citationSectionHeading.find("span.patent-list-citation-deleted");
            break;
        }
        var newCount = parseInt($spanCount.text()) + increment;
        $spanCount.text(newCount.toString());
      }

      function setupPatentFullView($patContext, patent_no, page_type) {
        $patContext.find("div.patent-list-fullview-button")
                   .on("mouseover", {patent_no: patent_no, page_type: page_type}, on_mouseover_fullview_button)
                   .on("mouseout", {patent_no: patent_no, page_type: page_type}, on_mouseout_fullview_button);
      }

      function on_mouseover_fullview_button(event) {
      // handler for mouseover event on the fullview button for a patent in the Mapped or Favorites List on the Map page      
        var $fullBtn = $(this);
        // to avoid multiple queries when multiple events are triggered in quick succession
        if ($fullBtn.attr("data-querying") == "true") return;
        var patent_no = event.data.patent_no;
        var patentObj = (patentBiblio[patent_no]) ?
                         patentBiblio[patent_no] : ((epoBiblio[patent_no]) ? epoBiblio[patent_no] : undefined);
        if (!patentObj) {                                         // occurs when patent is in the Favorites list
          var epoPatList = makeEPOQueryList([patent_no]);         // Google format to EPO format
          $fullBtn.attr("data-querying", "true");
          taskTracker.initialize("Fetching", undefined);
          taskTracker.startTask(1);
          getEPOPatentData(epoPatList, on_EPO_query_success);
        }
        else {
          setupFullView(patent_no, patentObj);
        }

        function on_EPO_query_success(data) {
          var processedList = parseEPOPatentData(data);
          taskTracker.finishTask(1);
          $fullBtn.attr("data-querying", "false");
          if (processedList) {
            var patentObj = epoBiblio[patent_no];
            if (patentObj) {
              console.log("In on_mouseover_fullview_button, got EPO API for patent " + patent_no);
              setupFullView(patent_no, patentObj);
            }
            else {
              console.log("In on_mouseover_fullview_button, no data in epoBiblio for patent " + patent_no);
            }
          }
          else {
            console.log("In on_mouseover_fullview_button, failed to get EPO data for patent " + patent_no);
          }
        }

        function setupFullView(patent_no, patentObj) {
          var pop1HTML = compiledPop1Template({patent_no: patent_no, patent_label: makePatentLabel(patent_no),
                                 file_date: patentObj.file_date, pub_date: patentObj.pub_date, title: patentObj.title,
                                 inventors: patentObj.inventors, assignee: patentObj.assignee, abstract: patentObj.abstract});
          var divFullView = $fullBtn.find("div.patent-list-fullview-container").html(pop1HTML);
          var divFVPos = divFullView.offset();
          var divPop = divFullView.find("div.pop1-container").addClass("pop1-in-patent-list");
          divPop.css("top", (divFVPos.top - 3) + "px").css("left", (divFVPos.left - pList.w - 12) + "px");
          divPop.find("div.pop1-top-capture").remove();
          divPop.find("div.pop1-buttons").remove();
          divPop.find("div.pop1-top-btns").remove();
          divPop.find("div.pop1-inventors").addClass("make-displayed");
          divPop.find("div.pop1-abstract").addClass("make-displayed");
        }
      }

      function on_mouseout_fullview_button(event) {
        var patent_no = event.data.patent_no;
        $(this).find("div.pop1-container").remove();
      }

      function setupPatentHighlight($patentContainer, patent_no, page_type) {
      // setup mouseover and mouseout event handlers for patent biblio in the Mapped or Favorites Lists on the Map page
        if ($patentContainer.hasClass("patent-list-patent")) {        // called from addTargetPatentToMappedSublist
          $patentContainer.on("mouseover", {patent_no: patent_no, page_type: page_type}, on_mouseover_patent_list_patent)
                          .on("mouseout", {patent_no: patent_no, page_type: page_type}, on_mouseout_patent_list_patent);
        }
        else {                             // called from addSourcePatentToMappedList and addFavoritePatentToFavoritesList
          $patentContainer.find("div.patent-list-patent")
                          .on("mouseover", {patent_no: patent_no, page_type: page_type}, on_mouseover_patent_list_patent)
                          .on("mouseout", {patent_no: patent_no, page_type: page_type}, on_mouseout_patent_list_patent);
        }
      }

      function on_mouseover_patent_list_patent(event) {
      // handler for mouseover on a biblio in the Mapped or Favorites Lists on the Map page; highlight the patent and links on the
      // force map that the mouse is over in the list
        var patent_no = event.data.patent_no;
        var page_type = event.data.page_type;                         // 'mapped-list' or 'favorites-list'
        if (patentsPlotted[patent_no]) {                              // if patent is mapped (might not be if on Favorites list)
          highlightLinks(patent_no);
          var marker = d3.select("g.force-patent-marker[data-patent=" + patent_no + "]");
          updateMarkerOnForceMap(marker, page_type);        
        }
      }

      function on_mouseout_patent_list_patent(event) {
      // handler for mouseout on a biblio in the Mapped or Favorites Lists on the Map page;
      // unhighlight the patent and links on the force map that the mouse was over in the list
        var patent_no = event.data.patent_no;
        mouseout_patent_list_patent(patent_no);
      }

      function mouseout_patent_list_patent(patent_no) {
      // called from on_mouseout_patent_list_patent event handler and special cases in removePatentFromFavorites
      // and removePatentFromMapped
        if (patentsPlotted[patent_no]) {                              // if patent is mapped (might not be if on Favorites list)
          unhighlightLinks(patent_no);
          var marker = d3.select("g.force-patent-marker[data-patent=" + patent_no + "]");
          updateMarkerOnForceMap(marker, "map");
        }
      }

      function on_click_patent_dropdown(event) {
      // when user clicks on the dropdown/dropup arrow for a patent entry in the Mapped list
        var $dropArrow = $(this);
        var $patentEntry = $dropArrow.closest("div.patent-list-entry");
        var $patentEntryContainer = $patentEntry.closest("div.patent-list-patents");
        var $refSections = $patentEntry.find("div.patent-list-references");
        if ($dropArrow.hasClass("patent-list-dropup-arrow")) {                // hide the dropdown content
          $dropArrow.removeClass("patent-list-dropup-arrow");
          $refSections.removeClass("make-displayed-flex");
          $patentEntryContainer.css("min-height", "0px");
        }
        else {                                                                // display the dropdown content
          $dropArrow.addClass("patent-list-dropup-arrow");
          $refSections.addClass("make-displayed-flex");
          $patentEntryContainer.css("min-height", "118px");
        }
      }

      function on_click_citation_dropdown(event) {
      // when user clicks on the dropdown/dropup arrow for a cited, citing, or related patent section of a patent
      // entry in the Mapped list
        var $dropArrow = $(this);
        var $refSection = $dropArrow.closest("div.patent-list-references");
        var $mainContainer = $refSection.closest("div.patent-list-patents");
        var mainContainerHeight = $mainContainer.css("height");       // e.g., "50px"
        var curMainHeight = parseInt(mainContainerHeight.slice(0, mainContainerHeight.length - 2));
        var patent_no = $refSection.attr("data-patent");
        var citation_type = $refSection.attr("data-citation-type");
        var $refsContainer = $refSection.find("div.patent-list-subpatent-container");
        if ($dropArrow.hasClass("citation-list-dropup-arrow")) {             // hide the dropdown content
          $dropArrow.removeClass("citation-list-dropup-arrow");
          $refsContainer.removeClass("make-displayed-flex");
          $refSection.css("height", "25px");
          $mainContainer.css("height", (curMainHeight - 47) + "px");
        }
        else {                                                                // display the dropdown content
          $dropArrow.addClass("citation-list-dropup-arrow");
          $refsContainer.addClass("make-displayed-flex");
          $refSection.css("height", "72px");
          $mainContainer.css("height", (curMainHeight + 47) + "px");
        }
      }

      function setupPatentLink($linkContext, page_type) {
      // called from addSourcePatentToMappedList, addTargetPatentToMappedList, and addFavoritePatentToFavoritesList
      // set up event handler for click on a patent link in the list; $linkcontext is the jQuery element that
      // contains the link for patent_no.
        $("a.pop1-patent-url", $linkContext).on("click", {$context: $linkContext, page: page_type}, on_click_new_patent_url);
      }

      function setupDeleteButton($btnContext, patent_no) {
      // called from addSourcePatentToMappedList, addTargetPatentToMappedList, and addFavoritePatentToFavoritesList;
      // set up event handler for click on the 'Delete' button for patent patent_no in the list; $btnContext is the
      // jQuery element that contains the 'Delete' button span element for patent patent_no.
        var $deleteBtn = $btnContext.find("span.btn-hide-add");
        if ((patent_no in patentsPlotted)) {                // if patent_no is mapped (as either a source or target patent)
          $deleteBtn.on("click", {patent_no: patent_no}, on_click_delete_btn$);  // add click event handler to 'Delete' button
        }
        else {                                              // do not display the 'Delete' button if patent no is not on the map
          $deleteBtn.addClass("make-not-displayed");
        }
      }

      function on_click_delete_btn$(event) {
      // for click event handler attached to Mapped or Favorites list 'Delete' buttons using jQuery;
      // like on_click_delete_btn attached to force map biblios using d3.
        $(this).addClass("make-not-displayed");
        deletePatentFromMap(event.data.patent_no, "single", on_delete_complete);

        function on_delete_complete() {
          setUndoButtonState();     // set Undo button state based on whether deleted list has any patents in it
          setClearButtonState();    // will set Clear button state based on whether patentsPlotted still has any patents in it
        }
      }

      function on_keydown_input_patent(event) {
      // handler for keydown event in the text input box above the force map on the Map page
        event.stopImmediatePropagation();                  // needed to stop keydown event from often firing twice!!
        patentPicker.clearError();
        if (event.keyCode == 13) {                         // Enter key
          $(this).off("keydown");                          // do not respond if use holds the key down
          on_click_go_btn(event);
        }
      }

      function on_keyup_input_patent(event) {
      // handler for keyup event in the text input box above the force map on the Map page
        event.stopImmediatePropagation();
        if (event.keyCode == 13) {                         // Enter key
          $(this).on("keydown", on_keydown_input_patent);  // re-attach event handler
        }
      }

      function on_click_go_btn(event) {
      // handler for click event on the Go button above the force map on the Map page; also called from on_keydown_input_patent
      // (handler when user presses the Enter key in the patent number input box)
        $("input.input-patent").on("keydown", on_keydown_input_patent);  // re-attach event handler
        var enteredText = $("input.input-patent").val();
        console.log("In on-click_go_btn, input text is " + enteredText);
        patentPicker.validatePatent(enteredText, on_patent_validated);

        function on_patent_validated(validResp) {
        // callback for patentPicker.validatePatent; if enteredText is a valid patent, validResp is an object containing
        // a valid Google url for the patent (with kind code) and the label (without the kind code) for labeling
        // the patent tab; if enteredText has an invalid format or is not in Google's database, validResp contains an
        // error message.
          if (validResp.url) {
            patentPicker.getPatent(validResp.url, validResp.label, undefined);
          }
          else {
            patentPicker.showError(validResp.error);
          }
        }
      }

      function on_click_random_btn(event) {
        setRandomButtonState(true);                                    // disable button while random patent is mapped
        randomPatentPicker.mapRandomPatent(on_random_patent_complete); // on_random_patent_complete is the callback

        function on_random_patent_complete() {
          setRandomButtonState(false);                                 // re-enable button when done mapping
        }
      }

      function setRandomButtonState(state) {
      // set appearance of the 'Random' button at the top of the force map.
          $("button.btn-random").prop('disabled', state);
      }

      function on_click_weird_btn(event) {
      }

      function on_click_undo_delete_btn(event) {
      // click event handler for the 'Undo' button on the Map page
        if (patentLists["clearFlag"]) {
          undoClear(on_undelete_complete);
        }
        else {
          var patent_no = patentLists["deleted"].slice(-1)[0];         // take last entry in the deleted list
          undeletePatent(patent_no, "single", "undo_delete", on_undelete_complete);
        }

        function on_undelete_complete() {
          setUndoButtonState();                            // set state based on whether deleted list contains any patents
          // last action is to enable the Clear button, but set the state based on whether patentsPlotted has any patents
          setClearButtonState();
        }
      }

      function undeletePatent(patent_no, deletionType, context, on_undelete_complete) {
      // undelete deleted patent patent_no; call the callback function on_undelete_complete when done; 'context' is the
      // context in which the function is called ('undo_delete' or 'undo_clear'); called from
      // on_click_undo_delete_btn, and restoreClearedPatents
        var patentNode = patentsHistory[patent_no];
        if (patentNode.source) {
          addSourcePatentToForceMap(patent_no, "map", context);   // also maintains deleted list
          addSourcePatentToMappedList(patent_no);                 // re-create entry in Mapped list on the Map page
          // undelete the reference patents associated with patent_no;
          mapExistingTargetPatents(patent_no, on_map_complete);   // on_map_complete is the callback
        }
        else {
          addTargetPatentToForceMap("", patent_no, "", context);    // recreate patent_no and all links to it on force map
          on_map_complete();
        }

        function on_map_complete() {
        // complete task of undeleting a patent called from undeletePatent when undeleting a target patent or
        // mapExistingTargetPatents after timeout when undeleting a source patent
          updateMapFavButtons(patent_no);
          remakeDeletedCitationListEntries(patent_no, patentNode);
          switch (deletionType) {
            case "single":
              updateForceMap();
              break;
            case "group":
              break;            // functions specifying 'group' undeletes are responsible for calling updateForceMap themselves
          }
          if (patent_no in patentLists["favorites"]) {     // show delete button in Favorites list entry
            var $patentContainer = $favoritesList
                                 .find("div.patent-list-entry[data-patent='" + patent_no + "'] div.patent-list-patent-container");
            setupDeleteButton($patentContainer, patent_no);
          }
          if (on_undelete_complete) {                      // call the callback if it was passed
            on_undelete_complete();
          }
        }

        function updateMapFavButtons(patent_no) {
        // need to set state of Map and Favorite buttons on patent, search, and related tabs; button state for biblios on the
        // force map are set when updateForceMap is called; button state in the Mapped and Favorites lists on the Map page are
        // set when patent_no is added to the list
          if (patentLists["map"].indexOf(patent_no) != -1) {
            toggleButton(patent_no, "btn-map-add", "add");
          }
          if (patentLists["favorites"].indexOf(patent_no) != -1) {
            toggleButton(patent_no, "btn-favorite-add", "add");
          }
        }
      }


      function mapExistingTargetPatents(source_patent, on_map_complete) {
      // plot reference patents for which epoBiblio data has already been queried and processed
        var sourceNode = patentsPlotted[source_patent];       // source_patent must already be plotted on the force map
        var $sourceContainer = $mappedList       // get appropriate jQuery element for source_patent in Mapped patent list
                       .find("div.patent-list-entry[data-patent='" + source_patent + "'] div.patent-list-patent-container");
        var linksList = sourceNode.targetPatentLinksList;
        var nL = 40;                                          // replot nL links and associated patents at a time
        var groupList = createGroupList(linksList, nL);       // break into list of subgroups of indices in linksList
        // plot target patents one group at a time, so map updates when undeleting a source patent with lots of references
        if (groupList.length > 0) {
          var iL = 0;
          taskTracker.initialize("Fetching", undefined);
          taskTracker.startTask(groupList.length);
          plotTargetGroup();
        }
        else {
          on_existing_map_complete();
        }

        function plotTargetGroup() {
        // plot the iL'th group of links and associated patents in linksList
          if (arguments.length > 0) {                         // was called recursively after timeout in this function
            taskTracker.finishTask(arguments[0]);
          }
          var targetPatentsList = [];
          var index = groupList[iL];
          // map in the same order that links were originally mapped
          for (var jL = index.start; jL < index.end; jL++) {
            var link = linksList[jL];                           // to help preserve legend colors
            var linkToTargetPatent = sourceNode.targetPatentLinks[link];
            var target_patent = linkToTargetPatent.target.patent_no;
            var type = linkToTargetPatent.type;
            addTargetPatentToForceMap(source_patent, target_patent, type, "new");
            addTargetPatentToMappedSublist($sourceContainer, source_patent, target_patent, type, false);
            targetPatentsList.push(target_patent);
          }
          updateForceMap();
          console.log("In mapExistingTargetPatents, for source patent " + source_patent + ", already have EPO data for "
                    + targetPatentsList.length + " reference patents: ", targetPatentsList);
          iL++;
          if (iL < groupList.length) {
            // call plotTargetGroup again after allowing 1 task to finish
            window.setTimeout(plotTargetGroup.bind(undefined, 1), 500);
          }
          else {
            window.setTimeout(afterFinalGroupPlotted, 500);    // after final group plotted
          }
        }

        function afterFinalGroupPlotted() {
          taskTracker.finishTask(1);
          on_existing_map_complete();
        }

        function on_existing_map_complete() {
          if (on_map_complete) {
            on_map_complete();                                 // call the callback function
          }
        }
      }

      function remakeDeletedCitationListEntries(patent_no, patentNode) {
      // create reference sublist entries in the Mapped patent list for patent_no under all source patents it is linked
      // to that are on the Mapped list; called from on_click_undo_delete and addFavorite patent
        for (link in patentNode.sourcePatentLinks) {
          var linkToSourcePatent = patentNode.sourcePatentLinks[link];
          var source_patent = linkToSourcePatent.source.patent_no;
          if (patentLists["map"].indexOf(source_patent) != -1) {         // if source_patent is currently mapped
            var type = linkToSourcePatent.type;
            var $sourceContainer = $mappedList     // get appropriate jQuery element for source_patent in Mapped patent list
                       .find("div.patent-list-entry[data-patent='" + source_patent + "'] div.patent-list-patent-container");
            addTargetPatentToMappedSublist($sourceContainer, source_patent, patent_no, type, true);
          }
        }
      }

      function addPatentToDeletedList(patent_no) {
      // add patent_no to deleted list and update CSS for the undo button
        patentLists["deleted"].push(patent_no);
      }

      function removePatentFromDeletedList(patent_no) {
      // test if patent_no is in the deleted list and if so remove it.
        var index = patentLists["deleted"].indexOf(patent_no);
        if (index != -1) {
          patentLists["deleted"].splice(index, 1);   // remove from the deleted list
        }
      }

      function setUndoButtonState(state) {
      // set appearance of the 'Undo' button at the top of the force map; if state is provided, set the button to
      // that state; if not, set the state based on whether deleted list contains any patents; called from
      // on_click_delete_btn$, on_click_delete_btn, on_click_clear_btn, and undoClear
        if (arguments.length > 0) {
          $("button.btn-undo").prop('disabled', state);
        }
        else {
          if (patentLists["deleted"].length == 0) {
            $("button.btn-undo").prop('disabled', true);
          }
          else {
            $("button.btn-undo").prop('disabled', false);
          }
        }
      }

      function setClearButtonState(state) {
      // set appearance of the 'Clear' button at the top of the force map; if state is provided, set the button to
      // that state; if not, set the state based on whether patentsPlotted contains any patentNodes; called from
      // mapNewTargetPatents, on_click_clear_btn, and undoClear.
        if (arguments.length > 0) {
          $("button.btn-clear").prop('disabled', state);
        }
        else {
          if (_.isEmpty(patentsPlotted)) {
            $("button.btn-clear").prop('disabled', true);
          }
          else {
            $("button.btn-clear").prop('disabled', false);
          }
        }
      }

      function initializeClearedLists() {
      // empty out the patent lists that support clear and undoing clear; called from on_click_map_buttons and
      // undoClear.
        var cleared = patentLists["cleared"];
        cleared["map"] = [];
        cleared["target"] = [];
        cleared["deleted"] = [];
        patentLists["clearFlag"] = false;
      }

      function initializeDeletedList() {
      // called from on_click_map_buttons and on_click_clear_btn.
        patentLists["deleted"] = [];                                    // remove 'Clear' from deleted list; it is now empty
      }

      function preserveClearedLists() {
      // preserve legend and deleted lists needed to undo a Clear command; called from on_click_clear_btn.
        var cleared = patentLists["cleared"];
        cleared["deleted"] = patentLists["deleted"].slice();            // save deleted list in case we need to Undo the Clear
        cleared["map"] = patentLists["map"].slice();                    // clone the mapped patent list
      }

      function on_click_clear_btn(event) {
      // event handler for the 'Click' button at the top of the force map
        setClearButtonState(true);                     // first action is to disable the Clear button, so user cannot click it twice
        preserveClearedLists();                        // preserve some history in case user undoes the Clear;
        var mapPatentList = patentLists["cleared"]["map"];
        // delete mapped patents one at a time in reverse order; the deletePatentFromMap function takes care of
        // calling updateForceMap when 'single' mapped patents and associated target patents are deleted
        var iP = mapPatentList.length;
        deleteMappedPatent();

        function deleteMappedPatent() {
          if (iP > 0) {
            iP--;
            var patent_no = mapPatentList[iP];
            deletePatentFromMap(patent_no, "single", deleteMappedPatent);    // deleteMappedPatent is the callback
          }
          else {
            deleteRemainingTargetPatents();
          }
        }

        function deleteRemainingTargetPatents() {
        // delete any remaining target patents whose source patent(s) were not plotted 
          for (patent_no in patentsPlotted) {
            deletePatentFromMap(patent_no, "group", undefined);
            patentLists["cleared"]["target"].unshift(patent_no);        // add to beginning of list to help preserve legend colors
          }
          // need to call updateForceMap since remaining target patents were deleted as a 'group'.
          updateForceMap();
          // the deleted list contains the patents that were just deleted; we need a new list now
          initializeDeletedList();
          patentLists["clearFlag"] = true;
          setUndoButtonState(false);                                     // set Undo button state enabled so can undo the Clear
        }
      }

      function undoClear(on_undo_clear_complete) {
      // undo a Clear command; called from on_click_undo_delete_btn; call on_undo_clear_complete when done.
        setUndoButtonState(true);                // immediately disable the Undo button (might be re-enabled later)
        // bring back the list of deleted patents when Clear was clicked so do not re-plot them
        restoreClearedLists();
        restoreClearedPatents(on_restore_complete);

        function on_restore_complete() {
          initializeClearedLists();
          on_undo_clear_complete();
        }
      }

      function restoreClearedLists() {
      // restore deleted lists to previous saved state; called from undoClear.
        patentLists["deleted"] = patentLists["cleared"]["deleted"];
      }

      function restoreClearedPatents(on_restore_complete) {
      // remap the patents that were deleted when the 'Clear' button was originally clicked; called from undoClear;
      // on_restore_complete is the callback called when function is finished
        var mapPatentList = patentLists["cleared"]["map"];
        var targetPatentList = patentLists["cleared"]["target"];
        // undelete formerly mapped patents and isolated target patents in reverse order that they were Cleared
        restoreTargetPatents();

        function restoreTargetPatents() {
        // undelete any isolated target patents in reverse order that they were Cleared
          var nP = targetPatentList.length;                           // as each patent was undeleted, it was removed from the list
          if (nP > 0) {
            var patent_no = targetPatentList[0];                        // always take the first entry
            undeletePatent(patent_no, "group", "undo_clear", restoreTargetPatents);      // restoreTargetPatents is the callback
          }
          else {
            // for 'group' undeletes, undeletePatent does not call updateForceMap; we need to call it here
            updateForceMap();
            restoreMappedPatents();
          }
        }

        function restoreMappedPatents() {
        // undelete mapped patents in the order they were originally plotted to try to preserve the original legend colors.
        // undelete the patent at index 0 in mapPatentList; waits for undeleting of each mapped patent and associated
        // target patents to be completed before recursively calling itself on the next mapped patent
          var nP = mapPatentList.length;                            // as each patent was undeleted, it was removed from the list
          if (nP > 0) {
            var patent_no = mapPatentList[0];                       // always take the first entry
            if (nP > 1) {
              // for 'single' undeletes, undeletePatent takes care of calling updateForceMap
              undeletePatent(patent_no, "single", "undo_clear", restoreMappedPatents);    // restoreMappedPatent is the callback
            }
            else {                                                          // last patent in the list
              undeletePatent(patent_no, "single", "undo_clear", on_restore_complete);     // on_restore_complete is the callback
            }
          }
          else {
            on_restore_complete();
          }
        }
      }

      function randomizeArray(array) {
      // randomize array using the javascript .sort with a random sort function; .sort sorts in place
        array.sort(function() {return (0.5 - Math.random());});
      }

      function divMouseDown(event) {
      // prevent the blue outline from appearing on a clicked div button; attached to div#right-toolbar-buttons on
      // Google Patent page and to bootstrap buttons at the top of the Map page
        event.preventDefault();
//          event.stopPropagation();
      }

    </script>
  </body>
</html>
