<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Patent visualization</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen">
    <script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/md5.js"></script>
    <script src="http://code.jquery.com/jquery.js"></script>
    <script src="/js/bootstrap.min.js"></script>
    <script src="/js/underscore.js"></script>
    <script src="/js/moment.min.js"></script>
    <script src="/js/d3.v3.min.js" charset="utf-8"></script>
<!--    <script src="/js/innersvg.js" charset="utf-8"></script>      <!-- to be able to set '.innerHTML' (or '.innerSVG') on SVG elements -->
    <link rel="stylesheet" href="/css/jdwmainpage.css">
  </head>

  <body>
    <ul class="nav nav-tabs" id="topTabs">
      <li class="active">
	<a id="patMap" href="#Map" data-toggle="tab">Map</a>
      </li>
      <li>
	<a id="gAdvSearchForm" href="#Search" data-toggle="tab">Search</a>
      </li>
    </ul>

    <div class="tab-content" id="topTabsContent">
      <div class="tab-pane active" id="Map">
        <div class="bib-container">
        </div>
        <svg class="main-svg">
          <defs>
            <!-- svg for the mapped patent cross graphic for a node on the force map -->
            <g id="force-mapped-cross-def" clip-path="url(#nodeClip)">
              <rect class="force-mapped-cross" width="20" height="5" transform="translate(-10,-2.5)"></rect>
              <rect class="force-mapped-cross" width="5" height="20" transform="translate(-2.5,-10)"></rect>
            </g>
    
            <!-- svg for the favorite patent symbol for a node on the force map -->
            <g id="force-favorite-heart-def" transform="translate(0,8)">
              <g class="force-favorite-heart" transform="rotate(-135)">
                <rect height="8" width="10" transform="translate(0,0)"></rect>
                <circle r="4" transform="translate(10,4)"></circle>
              </g>
              <g class="force-favorite-heart" transform="rotate(-45)">
                <rect height="8" width="10" transform="translate(0,-8)"></rect>
                <circle r="4" transform="translate(10,-4)"></circle>
              </g>
            </g>
          </defs
        </svg>
      </div>
      <div class="tab-pane" id="Search">
        <iframe id="gps" src="advanced_patent_search" width="1050" height="700" scrolling="no" allowfullscreen="true" sandbox="allow-same-origin allow-top-navigation allow-forms allow-scripts">
	</iframe>
      </div>
    </div>

    <script type="text/javascript">

      aaa = {};
      $(document).ready(setupInitialTabs);

      function setupInitialTabs() {
        $("head").append($("script#customize-bootstrap-styles").html());      // append customized bootstrap styles (for tabs and popover html content)
        var aTab = $("a[data-toggle='tab']");
        aTab.on('shown.bs.tab', function(event) {                          // setup eventListeners so popovers on other tabs are disabled/reenabled correctly
          if (event.relatedTarget) {
            var $previousTab = $(event.relatedTarget);
            if ($previousTab.popover) {
              $previousTab.popover('enable');
              var tab_id = $previousTab.attr("id");
              if (tab_id.slice(0,10) == 'relatedTab') {                    // update the popover content of a related tab
                updateRelatedTabPopover($previousTab);
              }  
            }
          }
        });
      }

      function updateRelatedTabPopover($aTab) {
        // $aTab is a jQuery object containing the <a> element that is used to activate a bootstrap tab
	var divID = $aTab.attr("href");               // need to get the document in the iframe of the div element associated with this tab
	var $context = $("div"+divID+" iframe").contents();
	var searchEntries = extractPriorArtSearchEntries($context);
	var popoverObject = $aTab.data('bs.popover');                     // get reference to popover instance; the .tip() method
	var popoverObjectContent = popoverObject.options.content;         // get popover html content
	var $popoverObjectContent = $(popoverObjectContent, popoverObjectContent);    // make into a jQuery object
	var $newTDsearch = $("td#jdw-pop-search-terms", popoverObjectContent).html(searchEntries.searchTerms);
	var $newTDstartDate = $("td#jdw-pop-start-date", popoverObjectContent).html(searchEntries.startDate);
	var $newTDendDate = $("td#jdw-pop-end-date", popoverObjectContent).html(searchEntries.endDate);
	$("td#jdw-pop-search-terms", $popoverObjectContent).replaceWith($newTDsearch);
	$("td#jdw-pop-start-date", $popoverObjectContent).replaceWith($newTDstartDate);
	$("td#jdw-pop-end-date", $popoverObjectContent).replaceWith($newTDendDate);
	popoverObject.options.content = $popoverObjectContent[0].outerHTML;
      }

      function extractPriorArtSearchEntries($context) {
	// extract patent number, title, search terms, and search dates for popover
	var searchTerms = '';
	$("div.search-term-wrapper span.jfk-checkbox-checked", $context).parent().parent()
	  .each( function(index) {
	    if (index == 0) {
	        searchTerms += $(this).text().trim();
	      }
	      else {
	        searchTerms += '<br>' + $(this).text().trim();
	    }
	  });
	var startDate = $("tr#start-date input", $context).val();
	if (startDate == '') startDate = 'Any';
	var endDate = $("tr#end-date input", $context).val();
	if (endDate == '') endDate = 'Any';
	return {searchTerms: searchTerms, startDate: startDate, endDate: endDate};
      }

      function deleteTab(event) {
        var clickedButton = $(event.target);
        var assocTab = clickedButton.closest("a");             // previous sibling element of the parent
        var activeTab = $("li.active > a");
        if (activeTab.get(0) == assocTab.get(0)) {             // are the HTML elements the same (the jQuery objects are not!)
            nextTab = assocTab.parent().prev().children("a");  // the previous tab
          }
          else {
            nextTab = activeTab
        }
        nextTab.tab("show");                                 // show nextTab before deleting the clicked tab and its content so popovers behave properly
        $("div"+assocTab.attr("href")).remove();             // remove the content of the tab; (the href of the anchor starts with '#' and references the div)
        clickedButton.closest("li").remove();                // remove the list element for the tab itself
      }

    </script>

    <script type="text/javascript">

      var startTime;                     // for debugging elapsed time
      var nSearchResultTabs = 0, nPatentTabs = 0, nRelatedTabs = 0;
      var patentBiblio = {};             // list of objects containing patent bibliographic, cited, citing, and related patent info; used for querying EPO for mapping
      var favoriteBiblio = {};           // list of objects containing patent bibliographic data, but no citation or related patent info; used for favorites list
      var epoBiblio = {};                // contains the bibliographic data fetched from EPO
      var patentNoEPOtoGoogle = {};      // a dictionary of epo patent document keys and Google patent document values
      var patentLists = {                // simple lists of patent numbers for each kind of list
         "map": [],
         "favorites": []
      };

      var external_URLs = ['worldwide.espacenet.com',
                           'register.epo.org',
                           'uspto.gov',
                           'wipo.int',
                           'scholar.google.com',
                           'docs.google.com',
                           'sipo',
                           '.bibtex',
                           '.enw',
                           '.ris'];

      var rExp_patno_from_url = /\/(?:patents|related)\/(\w+)(?:[\?#%&]|$)/;  // match /patent_num?,# or end of url string; (?:...) specifies non-capturing

      var formFields = {
        "as_q" : "All of: ",
        "as_epq" : "Exactly: ",
        "as_oq" : "At least one: ",
        "as_eq" : "None of: ",
        "as_pnum" : "Patent: ",
        "as_vt" : "Title: ",
        "as_pinvent" : "Inventor: ",
        "as_pasgnee" : "Assignee: ",
        "as_pusc" : "US class: ",
        "as_pintlc" : "Int'l class: ",
        "as_pcoopc" : "Coop class: ",
        "as_ptypeorstatus" : "Type: ",
        "as_drrb_is" : "ChkBoxPatDateOptions",    // value 'q' anytime; value 'b' between dates
        "as_minm_is" : "MinMonth",
        "as_miny_is" : "MinYear",
        "as_maxm_is" : "MaxMonth",
        "as_maxy_is" : "MaxYear",
        "as_pdatetype" : "Restrict by"          // value '1' application date; value '2' issue date
      };

      var typeValues = {
        "0" : "Any", "1" : "Application", "2" : "Issued", "3" : "Utility", "4" : "Design", "5" : "Plant",
        "6" : "Other", "7" : "Other", "8" : "Other"
      };

      var restrictByValues = {
        "1" : "Appl. date", "2" : "Issue date"
      };

      var monthValues = {
       "0" : "", "1" : "Jan ", "2" : "Feb ", "3" : "Mar ", "4" : "Apr ", "5" : "May ", "6" : "Jun ",
        "7" : "Jul ", "8" : "Aug ", "9" : "Sep ", "10" : "Oct ", "11" : "Nov ", "12" : "Dec "
      };

      function TableTemplateVars() {
        return {
          "t1" : "", "v1" : "",
          "t2" : "", "v2" : "",
          "t3" : "", "v3" : "",
          "t4" : "", "v4" : "",
          "t5" : "", "v5" : "",
          "t6" : "", "v6" : "",
          "t7" : "", "v7" : "",
          "t8" : "", "v8" : "",
          "t9" : "", "v9" : "",
          "t10" : "", "v10" : "",
          "t11" : "", "v11" : "",
          "t12" : "", "v12" : "",
          "t13" : "", "v13" : "",
          "t14" : "", "v14" : "",
          "t15" : "", "v15" : "",
          "t16" : "", "v16" : ""};
      }

      $("iframe#gps").load(function() {
        var $context = $(this).contents();
        $("a[href='http://www.google.com/'] > img", $context).unwrap();    // delete link associated with the Google logo
        $("a[href='/about.html']", $context).remove();                     // delete the 'About Google' link
        $("center:contains('\u00A9')", $context).remove();                 // delete the Google copyright notice
        $("form[action='/patents']", $context).on("submit", on_submit_form);  // intercept the form submit request...


        function on_submit_form(event) {
          event.preventDefault();
          var searchTerms = $(this).serializeArray();                           // an array of objects {name: input field name, value: input field value}
          var url = $(this).attr('action');
          var formData = $(this).serialize();                                   // get the form query data
//          $.get(url, formData, function(resp) {                               // do a GET request to do the search
          make_search_result_tab(url + '?' + formData, '', searchTerms);
        }

      });

      function make_related_tab(related_url) {
        nRelatedTabs += 1;
        var link_match = rExp_patno_from_url.exec(unescape(related_url));        // javascript unescape() function to remove %2F
        var patent_no = link_match ? link_match[1] : '';
        var tab_name = 'Re-' + patent_no;
        var tab_id = "relatedTab_" + nRelatedTabs;
        var tab_content_id = "related_" + nRelatedTabs;
        var iframe_id = "gps_related_" + nRelatedTabs;
        var navTabHTML = _.template( $("script#bs_nav-tab").html(), {tab_id: tab_id, tab_content_id: tab_content_id, tab_name: tab_name});
        var tabContentHTML = _.template( $("script#bs_tab-pane").html(),
          {tab_content_id: tab_content_id, iframe_id: iframe_id, iframe_width: 1220, iframe_height: 700});
        $("div.tab-pane.active").after(tabContentHTML);
        $("ul#topTabs li.active").after(navTabHTML);
        var htmlPriorArtHeader = _.template( $("script#prior-art-table").html(), {patent_no: patent_no});
        $("iframe#" + iframe_id).load(function() {on_related_load(this, tab_id, htmlPriorArtHeader);});
        $("iframe#" + iframe_id).attr("src", related_url);
//          $("a#" + tab_id).tab("show");
//          window.scrollTo(0,0);
      }

      function make_search_result_tab(search_url, tab_title, searchTerms) {
        nSearchResultTabs += 1;
        var tab_name = (tab_title == '') ? 'S-' + nSearchResultTabs.toString() : tab_title;
        var tab_id = "searchTab_" + nSearchResultTabs;
        var tab_content_id = "result_" + nSearchResultTabs;
        var iframe_id = "gps_result_" + nSearchResultTabs;
        var navTabHTML = _.template( $("script#bs_nav-tab").html(), {tab_id: tab_id, tab_content_id: tab_content_id, tab_name: tab_name});
        var tabContentHTML = _.template( $("script#bs_tab-pane").html(),
          {tab_content_id: tab_content_id, iframe_id: iframe_id, iframe_width: 1050, iframe_height: 700});
        $("div.tab-pane.active").after(tabContentHTML);
        $("ul#topTabs li.active").after(navTabHTML);
        var htmlSearchTermsTable = createHTMLSummaryTable("script#search-term-table", searchTerms);   // table at the top of the search result page
        var htmlPopoverTable = createHTMLSummaryTable("script#search-term-popover", searchTerms);     // table in the popover for the page
        $("iframe#" + iframe_id).load(function() {on_search_result_load(this, tab_id, htmlSearchTermsTable, htmlPopoverTable);});
        $("iframe#" + iframe_id).attr("src", search_url);
//          $("a#" + tab_id).tab("show");
//          window.scrollTo(0,0);
      }

      function make_more_result_tab($currentIFrame, more_result_url) {
      // load more search results into the current iframe ($currentIFrame is a jQuery object)
        htmlSearchTermsTable = $("div#jdw1", $currentIFrame.contents()).clone();
        $currentIFrame.off("load");                                                                   // remove original search result load event handler
        $currentIFrame.on("load", function() {on_more_result_load(this, htmlSearchTermsTable);});
        $currentIFrame.attr("src", more_result_url);
        window.scrollTo(0,0);
      }

      function setupSearchTab(tab_id, htmlPopoverTable) {
        var aTab = $("a#" + tab_id);
        aTab.popover( {placement: "bottom", trigger: "hover", html: true, title: "Search:", content: htmlPopoverTable} );   // use trigger: "click" for debugging
        aTab.popover('disable');                       // disable initially since we are already looking at this tab
        var popoverObject = aTab.data('bs.popover');                                              // get reference to popover instance; the .tip() method
        $(popoverObject.tip()).addClass('jdwsearch').children("div,h3").addClass('jdwsearch');    // returns the top div element of the popover so can add my own css
        aTab.on('shown.bs.tab', on_tab_shown);
      }

      function make_patent_tab(patent_url, patent_no) {
        nPatentTabs += 1;
        var tab_id = "patTab_" + nPatentTabs;
        var tab_content_id = "patent_" + nPatentTabs;
        var iframe_id = "gps_patent_" + nPatentTabs;
        var navTabHTML = _.template( $("script#bs_nav-tab").html(), {tab_id: tab_id, tab_content_id: tab_content_id, tab_name: patent_no});
        var tabContentHTML = _.template( $("script#bs_tab-pane").html(),
          {tab_content_id: tab_content_id, iframe_id: iframe_id, iframe_width: 1050, iframe_height: 700});
        var tabButtonHTML = $("script#tab-buttons").html();
        $("div.tab-pane.active").after(tabContentHTML);
        $("ul#topTabs li.active").after(navTabHTML);
        var aTab = $("a#" + tab_id);
        aTab.append(tabButtonHTML);                          // add the map and favorite buttons
        setupMapFavButtons(aTab, document, "main", patent_no);
        $("iframe#" + iframe_id).load( function() {on_patent_load(this, tab_id);});
        $("iframe#" + iframe_id).attr("src", patent_url);
      }

      function setupMapFavButtons($btnContext, $docContext, page_type, patent_no) {
        var btnMap = $("span.btn-map-add", $btnContext);
        var btnFav = $("span.btn-favorite-add", $btnContext);
        $("span.btn-map-add, span.btn-favorite-add", $btnContext)
                 .attr("data-patent", patent_no).on("click", {$context: $docContext, page: page_type}, on_click_map_buttons);
        if (patentLists["map"].indexOf(patent_no) != -1) btnMap.addClass("show-result-btn");
        if (patentLists["favorites"].indexOf(patent_no) != -1) btnFav.addClass("show-result-btn");
      }

      function on_patent_load(iframeElement, tab_id) {
        var $context = $(iframeElement).contents();
        $("head", $context).append($("script#search-term-table-style").html());    // append the style for the replacement page header
        $("div#pocs", $context).remove();
        process_links($context, "patent");
        process_patent_button_bar($context);
        var patent_no = $("ul#topTabs li.active", $context).text();
        $("a[href='/patents']", $context).remove();        // Link to basic patent search
        $("div#footer_table", $context).remove();          // Links at the bottom of the page
        $("div#gb", $context).replaceWith($("script#page-header").html()); 
        $("div.viewport-chrome-toolbar div:contains('Application')", $context)
          .each( function(index) {$(this).on("click", {index: index}, on_click_Application);} );  // Application button(s)
        $("div.viewport-chrome-toolbar div:contains('Grant')", $context)
          .each( function(index) {$(this).on("click", {index: index}, on_click_Grant);} );        // Grant button
        $("span.notice-section > a", $context)             // Override default event handler assigned in process_links
          .off("click", on_click_new_patent_url).on("click", on_click_AlsoPublishedAs);
        $("td.patent-bibdata-heading:contains('Also published as') ~ td span.patent-bibdata-value > a", $context)
          .off("click", on_click_new_patent_url).on("click", on_click_AlsoPublishedAs);
        setupPatentTab(tab_id, $context);
        $("a#" + tab_id).tab("show");
        window.scrollTo(0,0);
      }

      function on_related_load(iframeElement, tab_id, htmlPriorArtHeader) {
        var $context = $(iframeElement).contents();
        $("head", $context).append($("script#search-term-table-style").html());    // append the style for the replacement page header
        // the main prior art patent list and parent patent info is loaded via javascript after the rest of the page loads; we need to detect
        // when those parts are populated with content; a hack to do this is to attach an animation to the div.r elements via css
        // see http://stackoverflow.com/questions/6997826/alternative-to-domnodeinserted
        $("body", $context).addClass("make-invisible");          // so user does not see the web page manipulations
        $("td.content-td",$context)
          .on('webkitAnimationStart', "div.r", function() {on_divr_added(this, $context);}); // Chrome animation event
        $("td.content-td",$context)
          .on('animationstart', "div.r", function() {on_divr_added(this, $context);});       // Firefox animation event
        $("td.metadata-td",$context)
          .on('webkitAnimationStart', "div.metadata", function() {on_divmeta_added(this, tab_id, $context);}); // Chrome animation event
        $("td.metadata-td",$context)
          .on('animationstart', "div.metadata", function() {on_divmeta_added(this, tab_id, $context);});       // Firefox animation event
        process_links($context, "related");

        // generate click for prior art patents only
        // 11/25/2013: do not need to simulate click if append '#c=p' to the end of the related url; only the patents load now
//          var patentsOnlyOption = $("div#left-toolbar-buttons div:contains('Patents')", $context).get(0);   // get underlying Element of Patents nav option
//          simulateClick(patentsOnlyOption, 'mousedown', patentsOnlyOption.ownerDocument.defaultView);     // so can send mousedown, mouseup event
//          simulateClick(patentsOnlyOption, 'mouseup', patentsOnlyOption.ownerDocument.defaultView);
        $("div#pocs", $context).remove();
        $("div.kd-appbar", $context).remove();                   // Prior Art Finder options row
        $("div#footer", $context).remove();
        $("div#gb", $context).replaceWith($("script#page-header").html());       // replace the google content with a greatly simplified version
        $("div#jdwTop", $context).append(htmlPriorArtHeader);                    // append html for the prior art page header
        var aTab = $("a#" + tab_id);                                          // attach on_tab_shown hander here. Firefox does not start animations until the page is visible
        aTab.on('shown.bs.tab', on_tab_shown);                                // Chrome starts them when the HTML for the animated element is loaded
        aTab.tab("show")                                                     // note that the div.r's and divmeta have not finished loading yet
        window.scrollTo(0,0);
      }

      function on_divr_added(divr, $context) {
      // called for each div.r that is added
        var divrContext = $(divr, $context);
        process_links(divrContext, "related");
        var $span_t = $("span.t", divrContext)
        if ($("span", $span_t).length == 1) {                                  // if the 'map' and 'favorites' buttons have not been added
          $("span.hide-result-btn", $span_t).addClass("btn-original");
          $span_t.append($("script#related-art-page-button-content").html());  // add them
          var btnMap = $("span.btn-map-add", $span_t);
          var patent_no = getPatentURL_No(btnMap, $context, "related").patent_no;
          setupMapFavButtons($span_t, $context, "related", patent_no);
          $("span.btn-original", $span_t).attr("title", "Hide");
        }
      }

      function setupPatentTab(tab_id, $context) {
        var tia = getTIA($context);                                            // object containing title, inventors, assignees for the patent
        inventors = tia.inventors.replace(/, (?!Jr|JR|II|IV)/g,'<br/>');       // x(?!y) matches x only if not followed by y
        assignee = tia.assignee.replace(/, (?!Jr|JR|II|IV)/g,'<br/>');
        var htmlPopoverContent = _.template( $("script#patent-info-popover").html(), {inventors: inventors, assignee: assignee} );
        var aTab = $("a#" + tab_id);
        aTab.popover( {placement: "bottom", trigger: "hover", html: true, title: tia.title, content: htmlPopoverContent} );  // or "click" to debug
        aTab.popover('disable');                                                                  // disable initially since we are already looking at this tab
        var popoverObject = aTab.data('bs.popover');                                              // get reference to popover instance; the .tip() method
        $(popoverObject.tip()).addClass('jdwpatent').children("div,h3").addClass('jdwpatent');    // returns the top div element of the popover so can add my own css
        aTab.on('shown.bs.tab', on_tab_shown);
      }

      function setupPriorArtTab(tab_id, $context) {
        var patent_no = $("div#patent-metadata-box h2 a", $context).text();
        var patent_title = $("div#patent-metadata-box div#title", $context).text();
        var searchEntries = extractPriorArtSearchEntries($context);
        var htmlPopoverTitle = _.template( $("script#prior-art-popover-title").html(),
          {patent_no: patent_no, patent_title: patent_title});
        var htmlPopoverContent = _.template( $("script#prior-art-popover-content").html(),
          {searchTerms: searchEntries.searchTerms, startDate: searchEntries.startDate, endDate: searchEntries.endDate});
        var aTab = $("a#" + tab_id);
        aTab.popover( {placement: "bottom", trigger: "hover", html: true, title: htmlPopoverTitle, content: htmlPopoverContent} );  // or "click" and 'enable' to debug
        aTab.popover('disable');                       // disable initially since we are already looking at this tab
        var popoverObject = aTab.data('bs.popover');                                              // get reference to popover instance; the .tip() method
        $(popoverObject.tip()).addClass('jdwprior').children("div,h3").addClass('jdwprior');    // returns the top div element of the popover so can add my own css
      }

      function on_divmeta_added(divmeta, tab_id, $context) {
        // the divmeta div; the page_type is 'related-root' - the root patent of the prior art search
        var $divmetaContext = $(divmeta, $context);
        process_links($divmetaContext, "related-root");
        $("div#discuss-this-parent", $context).remove();    // the 'Discuss the patent' button ('patent' misspelled as 'parent' in the div id!)
        $("div.metadata h2", $context).append($("script#related-art-page-button-content").html());
        var btnMap = $("div.metadata span.btn-map-add", $context);
        patent_no = getPatentURL_No(btnMap, $context, "related-root").patent_no;
        setupMapFavButtons($divmetaContext, $context, "related-root", patent_no);
        setupPriorArtTab(tab_id, $context);                 // set up the popover for the tab for this page
        $("body", $context).removeClass("make-invisible");
        $("a#" + tab_id).click();
      }

/*
      function simulateClick(element, eventType, contextWindow) {
      // similate a mouse event 'type' on the 'element' in the 'contextWindow'
      // 11/25/2013: no longer need to use this function to load only patents in the related window; append "#c=p" to the end of the related url
        var event = new MouseEvent(eventType, {
          'view': contextWindow,
          'bubbles': true,
          'cancelable': true
        });
        var canceled = !element.dispatchEvent(event);
        if (canceled) {
        // A handler called preventDefault.
        }
        else {
        // None of the handlers called preventDefault.
        }
      }
*/

      function process_search_result_contents($context, htmlSearchTermsTable) {
      // process the content of a search page
        $("div#pocs", $context).remove();
        $("div#main div#top_nav", $context).remove();
        $("div#main div#topabar", $context).remove();
        $("p#bfl", $context).parent().remove();                      // Page bottom: advanced search and other links
        $("div#gfn", $context).remove();                             // Page bottom: empty div
        $("div#fll", $context).remove();                             // Page bottom: Google home and other links
        $("div#footcnt", $context).remove();                         // Page bottom: Help Feedback Privacy
        // contents() gets both text nodes and elements; remove the hyphen and the 'Discuss' link
        $("div.osl", $context).each ( function() { $(this).contents().slice(-2).remove();} );
        $("head", $context).append($("script#search-term-table-style").html());    // append the style for the replacement page header
        $("div#mngb", $context).replaceWith($("script#page-header").html()); 
        $("div#jdwTop", $context).append(htmlSearchTermsTable);  // append html for the search term table
        $("body", $context).append($("script#search-page-more-results-style").html());  // append the style for the Goooogle page links
        $("div#ires h3.r", $context).append($("script#search-page-button-content").html());  // buttons to map, add to favorites, or hide patent
        $("li.g span.btn-hide-add", $context).on("click", function(event) {on_click_hide_button(event, $context); });
        $("li.g span.btn-map-add", $context)
            .each(function() {
               var patent_no = getPatentURL_No(this, $context, "search").patent_no;
               $(this).attr("data-patent", patent_no).on("click", {$context: $context, page: "search"}, on_click_map_buttons);
               if (patentLists["map"].indexOf(patent_no) != -1) $(this).addClass("show-result-btn");
             });
        $("li.g span.btn-favorite-add", $context)
            .each(function() {
               var patent_no = getPatentURL_No(this, $context, "search").patent_no;
               $(this).attr("data-patent", patent_no).on("click", {$context: $context, page: "search"}, on_click_map_buttons);
               if (patentLists["favorites"].indexOf(patent_no) != -1) $(this).addClass("show-result-btn");
             });
        $("div#res", $context).before($("script#search-page-unhide-results").html()); // html to unhide hidden results
        $("span.hidden-results-message", $context).data("nHidden", 0);
        $("span.hidden-results-clear-btn", $context).on("click", function(event) {on_click_show_hidden(event, $context); });
      }

      function on_click_show_hidden(event, $context) {
      // click event handler for the 'Show all' button on the search results page that unhides hidden results
        $(event.target, $context).parent().addClass("hidden-show-all");        // the containing div element for the 'Show all' button
        $("li.hide-result", $context).removeClass("hide-result");
        $("span.hidden-results-message", $context).data('nHidden', 0);
      }

      function on_click_hide_button(event, $context) {
      // click event handler for the 'hide' button on the search results page
        var pressedButton = $(event.target, $context);
        var assocResult = pressedButton.closest("li.g", $context);
        assocResult.addClass("hide-result");
        var $hiddenMessage = $("span.hidden-results-message", $context);
        var curCount = $hiddenMessage.data("nHidden") + 1;
        $hiddenMessage.data("nHidden", curCount);                           // update the count of hidden patent results
        if (curCount == 1) {
          $hiddenMessage.text(curCount.toString() + ' result hidden below.');
        }
        else {
          $hiddenMessage.text(curCount.toString() + ' results hidden below.');
        }
        $("div.hidden-results-info", $context).removeClass("hidden-show-all")
      }

      function getPatentURL_No(element, $context, page_type) {
      // get the patent url and number associated with an HTML element or jQuery object for the element on a page of type
      // page_type ("map", "main" "search", "patent", or "related")
        var patent_no = '';
        var patent_url = '';
        switch (page_type) {
          case "map":
            var $aPatent = $(element, $context).closest("div.bib").find("a.pop1-patent-url");
            patent_no = $aPatent.text();
            patent_url = $aPatent.attr("href");
            break;
          case "main":
            patent_no = $(element, $context).closest("a").children("span").text(); // the text of the span element inside the anchor element for the tab
            patent_url = "/patents/" + patent_no;
            break;
          case "patent": case "map":
            patent_url = $(element, $context).attr("href");
            var link_match = rExp_patno_from_url.exec(patent_url);
            patent_no = link_match ? link_match[1] : '';
            break;
          case "search":
            var li_g = $(element, $context).closest("li.g", $context);
            patent_url = $(li_g, $context).find("cite.vurls", $context).text().replace(/www.google.com/,'');
            var link_match = rExp_patno_from_url.exec(patent_url);
            patent_no = link_match ? link_match[1] : '';
            break;
          case "related":
            var div_r = $(element, $context).closest("div.r", $context);
            patent_url = $(div_r, $context).find("cite", $context).text().replace(/www.google.com/,'');
            var link_match = rExp_patno_from_url.exec(patent_url);
            patent_no = link_match ? link_match[1] : '';
            break;
          case "related-root":
            var $div_metadata = $(element, $context).closest("div.metadata", $context);
            patent_url = $div_metadata.find("a", $context).attr("href").replace(/www.google.com/,'');
            var link_match = rExp_patno_from_url.exec(patent_url);
            patent_no = link_match ? link_match[1] : '';
          default:
        }
        return {"patent_url": patent_url, "patent_no": patent_no};
      }

      function toggleBtn(patent_no, btn, action) {
      // toggle the state of the map or favorite button for patent patent_no according to the action ("add" or "remove");
      // btn is the jQuery object for the map or add button that was clicked; called from on_click_map_buttons.
        var btn_type = btn.hasClass("btn-map-add") ? "btn-map-add": (btn.hasClass("btn-favorite-add") ? "btn-favorite-add": "");
        var $forceMapBtns = $("div#Map span."+btn_type+"[data-patent='"+patent_no+"']", document);     // get the map or favorite button on the force map
        if ($forceMapBtns.length > 0) changeClass($forceMapBtns, action);                              // update whether it displays as clicked or not
        var $patTabBtns = $("ul.nav-tabs span."+btn_type+"[data-patent='"+patent_no+"']", document);   // get the map or favorite button on the patent tab for patent_no
        if ($patTabBtns.length > 0) changeClass($patTabBtns, action);                                  // update whether it displays as clicked or not
        $("div.tab-pane[id^='result'] iframe, div.tab-pane[id^='related'] iframe")                     // get all the iframes for search and related tabs
          .each(function() {                                                                           // in each one, search for buttons associated with patent_no
            $context = $(this).contents();
            var $btn_family = $("span."+btn_type+"[data-patent='"+patent_no+"']", $context);
            if ($btn_family.length > 0) changeClass($btn_family, action);                              // update how the button for patent_no is displayed
          });
        function changeClass($btns, action) {
          switch (action) {
            case "remove":
              $btns.removeClass("show-result-btn");
              break;
            case "add":
              $btns.addClass("show-result-btn");
              break;
            default:
          }
        }          
      }

      function makeGoogleDate(dateStr) {
      // use moment.js to take a string like 20100416 and return a string Apr 16, 2010 (Google format).
        return moment.utc(dateStr, "YYYYMMDD").format("MMM D, YYYY");
      };

      function makeGoogleAppl(applStr) {
      // take an EPO biblio applStr (all caps MONSANTO LLC [US]) and return mixed upper/lower case (Google format);
      // in the regex, \b matches a word boundary; \w matches any alphanumeric character;
        var s = applStr.replace(/ \[\w*\]/g, "");
        return s.toLowerCase().replace(/\b\w/g, function(match) {return match.toUpperCase();});
      }

      function makeGoogleName(nameStr) {
      // take an EPO biblio nameStr (all caps SMITH PAUL L [US]) and return mixed upper/lower case (Google format);
      // in the regex, \b matches a word boundary; \w matches any alphanumeric character;
        if (!nameStr) return "";
        var returnStr = ""
        var s = nameStr.replace(/ \[\w*\]/g, "");
        s = s.toLowerCase().replace(/\b\w/g, function(match) {return match.toUpperCase();});
        var names = s.match(/(\S+)/g);
        names.forEach(function(val, i, array) {if (val.length == 1) array[i] += ".";});
        switch (names.length) {
          case 0:
            return "";
            break;
          case 1:
            return names[1];
            break;
          case 2:
            return names[1] + " " + names[0];
            break;
          default:
            switch (names[0]) {
              case "Von" : case "Van" :
                names[0] = names[0].toLowerCase();
                switch (names[1]) {
                  case "De": case "Der":
                    names[1] = names[1].toLowerCase();
                    names.push(names[0], names[1], names[2]);          // add the first three entries in names to the end of names
                    names = names.slice(3);
                    break;
                  default:
                    names.push(names[0], names[1]);          // add the first two entries in names to the end of names
                    names = names.slice(2);
                }
                break;
              case "De": case "Del":
                names[0] = names[0].toLowerCase();
                switch (names[1]) {
                  case "La":
                    names[1] = names[1].toLowerCase();
                    names.push(names[0], names[1], names[2]);
                    names = names.slice(3);
                    break;
                  default:
                    names.push(names[0], names[1]);
                    names = names.slice(2);
                }
                break;
              default:
                names.push(names[0]);
                names = names.slice(1);
            }
        }
        switch (names[0]) {
          case "Ii": case "Iii": case "Iv":
            names[0] = names[0].toUpperCase();              // no break!
          case "Jr": case "Sr":
            names.push(names[0]);
            names = names.slice(1);
            break;
          default:
        }
        return names.join(" ");
      }

      function makeGoogleTitle(titleStr) {
      // take an EPO biblio titleStr (all caps) and return mixed upper/lower case (Google format);
      // in the regex, ^ matches the beginning of the string.
        return titleStr.toLowerCase().replace(/^\b\w/g, function(match) {return match.toUpperCase();});
      }

      function checkInventorName(gooName, assigneeName) {
        var retName = gooName;
        if (assigneeName.search(/Inc|Co|Llc|Ltd|Int/) != -1) {        // sometimes an inventor name has the assignee mixed in!
          aList = assigneeName.match(/(\S+)/g);                       // so remove the words in the assignee if the assignee is a company
          if (aList) {
            aList.forEach( function(val, ind, arr) {retName = retName.replace(/\bval\b/g, " ");});    // \b is a word boundary
            retName = retName.replace(/\s+/g, " ");
          }
        }
        return retName;
      }

      function on_get_EPO_data(epoJSON, source_patent, epoQueryLists, iList, callback) {
      // parse the epoJSON containing the data returned by the EPO API;
      // callback (on_EPO_query_complete) will be called when data parsing is complete;
      // source_patent is the patent at the focus of the force diagram; it is passed along to the callback;
      // iList and epoQueryLists track multiple EPO queries made simultaneously; passed along to the callback;
        if (epoJSON["ops:world-patent-data"]) {                                   // got EPO data
          var epoPatents = epoJSON["ops:world-patent-data"]["exchange-documents"]["exchange-document"];
          epoPatents = (epoPatents instanceof Array) ? epoPatents : [epoPatents];   // a single patent is not returned as a list,
          console.log("Got " + epoPatents.length + " documents back from EPO");            // so make one
          var processedList = [], unprocessedList = []; dupList = []; notFoundList = []; USApplicationCount = 0;
          epoPatents.sort(function(a, b) {                                        // process all status = 'not found' patents last
                            if (!a["@status"] && b["status"]) {                   // so can eliminate the ones that were not found
                              return -1;                                          // due to ambiguity in Google for US utility vs
                            }                                                     // plant applications. Must query EPO for both
                            if (a["@status"] && !b["status"]) {                   // but one will always be 'not found'.
                              return 1;
                            }
                            return 0;
                          });
          for (var iPat = 0; iPat < epoPatents.length; iPat++) {
            try {
              var epoPatent = epoPatents[iPat];
              var country = epoPatent["@country"];
              var doc_number = epoPatent["@doc-number"];
              var kind =  (epoPatent["@kind"]) ? epoPatent["@kind"] : "";         // kind will not be present if a patent is not found in EPO database
              var epo_patent_no = country + doc_number + ((country == "US") ? "" : kind);  // my queries to EPO for US patent docs never have a kind code
              // the "@doc-number" is the true EPO docdb number; the epodoc number is different for US reissue, plant, and design patents,
              // in which case we need to append the first letter of the kind code...
              epo_patent_no = epo_patent_no + ((country == "US" && (kind.slice(0,1) == "E" || kind.slice(0,1) == "P" || kind.slice(0,1) == "S")) ? kind.slice(0,1) : "");
              var patent_no = patentNoEPOtoGoogle[epo_patent_no];                 // convert from EPO patent doc number to Google patent doc number
              if (!(patent_no in epoBiblio) && epoPatent["@status"] != "not found") {
                // get pubDate first so can screen some patents out, like US B1 patents prior to 1/2/2001

                var pubDate = "";                                                 // get the publication date
                var pub_reference = epoPatent["bibliographic-data"]["publication-reference"];
                if (pub_reference) {
                  var document_id = pub_reference["document-id"];
                  pubDate = (document_id instanceof Array) ? makeGoogleDate(document_id[1]["date"]["$"]) : "";
                }

                var is_USB_123 = (country == "US" && kind[0] == "B");             // if patent is US kind B1,B2,B3 before 2001
                var is_pre_2001 = (moment.utc(pubDate).valueOf() < moment.utc("Jan 2, 2001"));
                if (is_USB_123 && is_pre_2001) {                                  // skip it
                  console.log("In on_get_EPO_data: patent " + patent_no + kind + " is US_B pre-2001");
                  dupList.push(patent_no + kind);
                  continue;
                }

                var abstractText = "";                                            // get the abstract
                var abstract = epoPatent["abstract"]
                if (abstract) {
                  abstractP = (abstract instanceof Array) ? abstract[0]["p"] : abstract["p"];  // if more than one abstract, [0] is in English
                  if (abstractP) {
                    if (abstractP instanceof Array) {                             // if more than one "p", concatenate them
                      var absList = [];
                      for (var iP = 0; iP < abstractP.length; iP++) {
                        absList.push(abstractP[iP]["$"]);
                      }
                      abstractText = absList.join(", ");
                    }
                    else {
                      abstractText = abstractP["$"];
                    }
                  }
                }

                var inventionTitle = "";                                          // get the invention title
                var invention_title = epoPatent["bibliographic-data"]["invention-title"];
                if (invention_title) {
                  inventionTitle = (invention_title instanceof Array) ? makeGoogleTitle(invention_title[0]["$"]) : makeGoogleTitle(invention_title["$"]);
                }
                var assigneeName = "";                                            // get the assignee
                var inventorList = [];                                            // and the inventors
                var parties = epoPatent["bibliographic-data"]["parties"];
                if (parties) {
                  var applicants = parties["applicants"];
                  if (applicants) {                                               // take the assignee as the first applicatn
                     assigneeName = (applicants["applicant"] instanceof Array) ?  // often inventors are also listed as applicants
                        makeGoogleAppl(applicants["applicant"][0]["applicant-name"]["name"]["$"]) : makeGoogleAppl(applicants["applicant"]["applicant-name"]["name"]["$"]);
                  }
                  var inventors = parties["inventors"];
                  if (inventors) {
                    var inventor = inventors["inventor"];
                    if (inventor instanceof Array) {
                      for (var iInv = 0; iInv < inventor.length; iInv++) {
                        if (inventor[iInv]["@data-format"] == "epodoc") {         // the 'epodoc' format has no commas or periods in the names
                          var epoName = inventor[iInv]["inventor-name"]["name"]["$"];
                          var gooName = makeGoogleName(epoName);
                          gooName = checkInventorName(gooName, assigneeName);     // sometimes an inventor name has the assignee mixed in!
                          inventorList.push(gooName);
                        }
                      }
                    }
                    else {
                      var epoName = inventor["inventor-name"]["name"]["$"];
                      var gooName = makeGoogleName(epoName);
                      gooName = checkInventorName(gooName, assigneeName);         // sometimes an inventor name has the assignee mixed in!
                      inventorList.push(gooName);
                    }
                  }
                }
                var fileDate = "";                                                // get the filing date
                var app_reference = epoPatent["bibliographic-data"]["application-reference"];
                if (app_reference) {
                  var document_id = app_reference["document-id"];
                  if (document_id instanceof Array) {
                    if (document_id[1]["date"]) {
                      fileDate = makeGoogleDate(document_id[1]["date"]["$"]);
                    }
                  }
                }
                fileDate = (fileDate == "") ? pubDate: fileDate;                   // very old patents only have a publication date; still want to be able to plot them
              }
              else {
                if (epoBiblio[patent_no]) {
                  if (!(country == "US" && patent_no.length == 13)) {      // if duplicate because we query US patent applications twice (as utility and as plant)
                    dupList.push(patent_no);                                       // then do not count as duplicate
                    console.log("In on_get_EPO_date: patent " + ((country == "US") ? patent_no + kind : patent_no) + " is duplicate");
                  }
                  else {
                    USApplicationCount += 1;
                  }
                }
                else {
                  notFoundList.push(patent_no);
                  console.log("In on_get_EPO_date: patent " + patent_no + " not found");
                 }
                continue;
              }
            }
            catch(error) {
              unprocessedList.push(patent_no);
              console.log("In on_get_EPO_data, error thrown: " + error.name + ": " + error.message);
              console.log("      Error parsing patent " + patent_no);
              console.log(epoPatent);
              continue;
            }
            epoBiblio[patent_no] = {};                                          // add the patent to the epoBiblio list
            epoBiblio[patent_no]["title"] = inventionTitle;
            epoBiblio[patent_no]["abstract"] = abstractText;
            epoBiblio[patent_no]["pub_date"] = pubDate;
            epoBiblio[patent_no]["assignee"] = assigneeName;
            epoBiblio[patent_no]["inventors"] = inventorList.join(", ");
            epoBiblio[patent_no]["file_date"] = fileDate;
            processedList.push(patent_no);                                      // add to list of patents successfully processed
            console.log("In on_get_EPO_data: parsed patent " + patent_no);
            console.log(epoPatent);
          }
          console.log("In on_get_EPO_data, " + processedList.length + " successfully parsed patents:");
          console.log(processedList);
          console.log("                    " + unprocessedList.length + " patents not parsed:");
          console.log(unprocessedList);
          console.log("                    " + dupList.length + " patents were duplicates (between cited/citing and related lists?) or US_B pre-2001:");
          console.log(dupList);
          console.log("US applications not found due to querying as both utility and plant applications: " + USApplicationCount);
          console.log("                    " + notFoundList.length + " patents not found:");
          console.log(notFoundList);
          callback(source_patent, processedList, epoQueryLists, iList);
        }
        else {                                              // got error message
          console.log("In on_get_EPO_data, error getting EPO patent data:");
          console.log(epoJSON);
        }
      }

      function getEPOPatentData(patent_no, epoQueryLists, iList, callback) {
      // get and process patent bibliographic data from the EPO API; epoQueryLists is a list of objects produced by makeQueryLists, containing
      // keys "list" which is a string (,patent1,patent2,...), "type" which is the type of patents (cited, citing, or related), and
      // "done", which tracks whether the EPO query has completed.
      // callback (on_EPO_query_complete) is passed along to on_get_EPO_data; it is the function finally called when
      // the query completes and the data has been parsed; iList is passed along to callback.
        var epoPatList = epoQueryLists[iList]["list"];
        if (epoPatList != "") {
          console.log(epoPatList);
          $.ajax({ type: "POST",
                   url: "/epoapi/biblio/",
                   contentType: "application/x-www-form-urlencoded; charset=UTF-8",    // this is default
                   // Request Body is ,patent1,patent2,...; CacheKey is refs_patent+epoPatList to ask server to pull data from cache if it exists
                   data: {"Request Body": epoPatList, "CacheKey": "refs_" + CryptoJS.MD5(patent_no + epoPatList)},
                   dataType: "json",
                   success: function(data) {on_get_EPO_data(data, patent_no, epoQueryLists, iList, callback);},
                   error: function(req, status, error) {console.log("In getEPOPatentData, error returned from POST request"); console.log(status); console.log(error);}
                 });
        }
      }

      function on_EPO_query_complete(source_patent, processedList, epoQueryLists, iList) {
        // epoQueryLists is a list of objects containing keys "list" (the query list), "type" (cited, citing, related)
        // and "done" (track when the query completes); one object for each query POSTed;
        // iList is the process number that just finished; processList is a list of patents in EPO format
        // that were successfully parsed and for which biblio data exists in epoBiblio; source_patent is the
        // patent at the focus of the force diagram.
        epoQueryLists[iList]["done"] = "true";                               // the iList list has been queried and processed
        console.log("In on_EPO_query_complete, retrieved biblio data for the following patents");
        console.log(processedList);
        var type = epoQueryLists[iList]["type"];
        for (var i = 0; i < processedList.length; i++) {                      // add to the force diagram
          addTargetPatentToForceMap(source_patent, processedList[i], type);
        }
        console.log("Adding queried EPO data for " + processedList.length + " " + type + " patents to the force map"); 
        updateForceMap();
      }

      function addTargetPatentToForceMap(source_patent, patent_no, type) {
      // add patent patent_no and associated link to the force diagram; link type is "cited", "citing", "related", or "";
      // source_patent is the focus of the force diagram; biblio data for patent_no must exist in epoBiblio.
        if (!patentIndex[patent_no]) {                                                   // if not already in the force diagram
          var targetNode = new PatentNode(patent_no, false, epoBiblio[patent_no]);       // create a new patentNode
          patentNodes.push(targetNode);                                                  // add to node list
          patentIndex[patent_no] = targetNode;
        }
        else {                                                                           // get existing node on force diagram
          var targetNode = patentIndex[patent_no];
        }
        var link_key = (source_patent < patent_no) ? source_patent + patent_no + type : patent_no + source_patent + type; 
        if (!linkIndex[link_key]) {                                                      // if link does not already exist in the force diagram
          var targetLink = new PatentLink(patentIndex[source_patent], targetNode, type, link_key);  // create new patentLink between the patents
          patentLinks.push(targetLink);
          linkIndex[link_key] = targetLink;
        }
      }

        function createHTMLSummaryTable(scriptName, searchTerms) {
        // populates the html template defined in scriptName with a table of searchTerms
          var tableTemplateVars = TableTemplateVars();
          var dateInfo = {};
          var inputName = '', entryName = '', entryValue = '';
          var maxChar = 25;
          var tableEntry = 0;
          searchTerms.forEach( function(inputField) {
            inputName = inputField["name"];
            if (formFields[inputName]) {                                        // there are some input fields we have not defined in formFields
              entryName = formFields[inputName];
              entryValue = inputField["value"];
              switch (entryName) {
                case "All of: ": case "Exactly: ": case "At least one: ": case "None of: ": case "Patent: ": case "Title: ": case "Inventor: ": case "Assignee: ":
                case "US class: ": case "Intl class: ": case "Coop class: ":
                  if (entryValue != "") {
                    tableEntry += 1;
                    tableTemplateVars["t"+tableEntry] = entryName;
                    tableTemplateVars["v"+tableEntry] = entryValue;           // no need to truncate long strings; CSS of the class .vcell takes care of it!
                  }
                  break;
                case "Type: ": case "ChkBoxPatDateOptions": case "MinMonth": case "MinYear": case "MaxMonth": case "MaxYear": case "Restrict by":
                  dateInfo[entryName] = entryValue;                             // need to store these values and process them separately
                  break;
              }
            };
          });

          tableEntry = 4*Math.ceil(tableEntry/4);                            // round to nearest multiple of 4
          tableEntry += 1;
          tableTemplateVars["t"+tableEntry] = "Type: ";                      // put in the last column in the table
          tableTemplateVars["v"+tableEntry] = typeValues[dateInfo["Type: "]];
          if (dateInfo["ChkBoxPatDateOptions"] == 'q') {                      // no restriction on date
            tableEntry += 1;
            tableTemplateVars["t"+tableEntry] = "Date: ";
            tableTemplateVars["v"+tableEntry] = "Any";
          }
          else {                                                                // process the date restrictions
            tableEntry += 1;
            tableTemplateVars["t"+tableEntry] = "Start date: ";
            if (dateInfo["MinYear"] == "") {
              tableTemplateVars["v"+tableEntry] = "Any";
            }
            else {
              tableTemplateVars["v"+tableEntry] = monthValues[dateInfo["MinMonth"]] + dateInfo["MinYear"];
            }
            tableEntry += 1;
            tableTemplateVars["t"+tableEntry] = "End date: ";
            if (dateInfo["MaxYear"] == "") {
              tableTemplateVars["v"+tableEntry] = "Any";
            }
            else {
              tableTemplateVars["v"+tableEntry] = monthValues[dateInfo["MaxMonth"]] + dateInfo["MaxYear"];
            }
            tableEntry += 1;
            tableTemplateVars["t"+tableEntry] = "Restrict by: ";
            tableTemplateVars["v"+tableEntry] = restrictByValues[dateInfo["Restrict by"]];
          };

          return _.template( $(scriptName).html(), tableTemplateVars);
        }

        function on_tab_shown(event) {
          var $clickedTab = $(event.target);
          if ($clickedTab.data('bs.popover')) {
            $clickedTab.popover('hide');              // was already hovering before the click; make it disappear
            $clickedTab.popover('disable');           // prevent it from popping up again
          }
          if (event.relatedTarget) {
            var $previousTab = $(event.relatedTarget);
            if ($previousTab.data('bs.popover')) {
              $previousTab.popover('enable');
              var tab_id = $previousTab.attr("id");
              if (tab_id.slice(0,10) == 'relatedTab') {         // update the popover content of a related tab
                updateRelatedTabPopover($previousTab);
              }  
            }
          }
        }

      function on_click_map_buttons(event) {
      // click event handler for the 'map' and 'favorite' buttons
      // event.data stores the jQuery context of the element that generated the event in .$context, and the type of page the button in .page
      // on a patent page, $context is the main html document
      // on the search results and related patents pages, $context is the document in the iframe
        event.preventDefault();
        event.stopPropagation();
        var $context = event.data.$context;
        var pressedButton = $(event.target, $context);
        var patent_info = getPatentURL_No(event.currentTarget, event.data.$context, event.data.page);
        var patent_no = patent_info.patent_no;
        var patList = pressedButton.hasClass("btn-map-add") ? "map": (pressedButton.hasClass("btn-favorite-add") ? "favorites": "");
        if (pressedButton.hasClass("show-result-btn")) {    // remove patent
          switch (patList) {
            case "favorites":
              removePatentFromFavorites(patent_no, pressedButton);
              break;
            case "map":
              removePatentFromMap(patent_no);
              break;
          }
console.log("Remove");
console.log(patentLists);
console.log(patentBiblio);
        }
        else {                                              // add patent
          toggleBtn(patent_no, pressedButton, "add");       // toggle appearance of button
          patentLists[patList].push(patent_no);             // add to the patList list
console.log("patentLists");
console.log(patentLists);
          switch (patList) {
            case "favorites":
              addFavoriteMarkerToForceMap(patent_no);
              if (!(patent_no in favoriteBiblio)) {
console.log("Do not have " + patent_no + " in favoriteBiblio");
                favoriteBiblio[patent_no] = {}              // favoriteBiblio does not have citation or related patent lists
                getQuickBiblioData(patent_no, on_favorite_data_complete);      // on_favorite_data_complete is the callback
              }
              else {
console.log("Have " + patent_no + " in favoriteBiblio");
                on_favorite_data_complete();
              }
              break;
            case "map":
              $("a[href='#Map']").click();                      // switch to the Map tab
startTime = new Date();
console.log("Started mapping process");
              if (!(patent_no in patentBiblio)) {               // if no bibliographic info
console.log("Do not have " + patent_no + " in patentBiblio");
                patentBiblio[patent_no] = {};                                  // create empty entry in patList for patent_no
                var status = {bibDone: false, relDone: false, expired: false}; // to track status of the queries for patent data; used by callback on_patent_data_complete
                getPatentBiblioData(patent_info, event, $context, on_patent_data_complete, status);  // get bibliographic info for the patent from the google patent page
                getRelatedPatentList(patent_no, on_patent_data_complete, status); // get the patents related to this one from a customized google related patents search
                var patentDataTimeout = setTimeout(function() {status["expired"] = true;
                                                               on_patent_data_complete(status);}, 20000);    // 20 seconds
              }
              else {
console.log("Have " + patent_no + " in patentBiblio");
                var status = {bibDone: true, relDone: true, expired: false};  // query status for on_patent_data_complete; queries were previously run
                on_patent_data_complete(status);                              // and there is already an entry for patent_no in patentBiblio
              }
              break;
          }
 
          function on_favorite_data_complete() {
          // update the favorites list on the Map tab
            console.log("For " + patent_no + ", got favorite biblio data: ", favoriteBiblio[patent_no]);
          }

          function on_patent_data_complete(status) {
          // callback for getPatentBiblioData and getRelatedPatentList; patentBiblio now has a complete entry for patent_no
          // (unless queries took too much time); status is an object containing the status of each callback.
console.log("In on_patent_data_complete: getting data for patent " + patent_no);
console.log("Status: ", status);
            if (status["bibDone"] && status["relDone"] && !status["expired"]) {
              clearTimeout(patentDataTimeout);
              console.log("In on_patent_data_complete, added entry for " + patent_no + " to patentBibio");
              console.log(patentLists);
              console.log(patentBiblio);
console.log("Starting to assemble data for mapping at " + (new Date() - startTime)/1000);
              addSourcePatentToForceMap(patent_no);
console.log("Adding the source node to the force map");
              updateForceMap();                        // add the source patent to the force map
              // checkDataForPatents checks if we already have biblio data for each patent in the list; if so, it adds the patent
              // to the force map; returns a list of patents we need to query  
              var citedListToQuery = checkDataForPatents(patent_no, patentBiblio[patent_no]["cited_patents"], "cited");
              var citingListToQuery = checkDataForPatents(patent_no, patentBiblio[patent_no]["citing_patents"], "citing");
              var relatedListToQuery = checkDataForPatents(patent_no, patentBiblio[patent_no]["related_patents"], "related");
              var epoQueryLists = makeAllQueryLists(patent_no, citedListToQuery, citingListToQuery, relatedListToQuery);
console.log(epoQueryLists);
              for (var iList = 0; iList < epoQueryLists.length; iList++) {
                getEPOPatentData(patent_no, epoQueryLists, iList, on_EPO_query_complete); // on_EPO_query_complete is the callback
              }
            }
            else {
              if (status["expired"]) {
                console.log("Too much time waiting for data in on_patent_data_complete. Bib info: ", status);
              }
            }
          }

          function addFavoriteMarkerToForceMap(patent_no) {
            var patentNode = d3.select("g.node[data-patent=" + patent_no + "]");
            var markerColor = patentNode.select("circle.force-patent-circle").style("fill");
            var marker = patentNode.insert("svg:g", "circle+*").classed("force-favorite-marker", true);
            marker.append("svg:circle").classed({"force-favorite-circle": true})
                  .attr({"r": "10", "data-patent": patent_no}).style({"fill": markerColor}); // event handler attached to parent g.node
            marker.append("svg:use").attr({"xlink:href": "#force-favorite-heart-def"});
          }

          function addSourcePatentToForceMap(patent_no) {
          // create a source node for patent_no on the force map.
            if (!patentIndex[patent_no]) {           // if the source patent is not already in the force diagram
              var sourceNode = new PatentNode(patent_no, true, patentBiblio[patent_no]);    // create a PatentNode object for the patent at the
              patentNodes.push(sourceNode);                                             // center of the map, and add it to the list of patentNodes
              patentIndex[patent_no] = sourceNode;                                      // keep a record of patents in the force diagram
            }
            else {
              var sourceNode = patentIndex[patent_no];
              sourceNode["source"] = true;
              var marker = d3.select("g.node[data-patent=" + patent_no + "]").insert("svg:g", "text").classed({"force-mapped-marker": true});
              marker.append("svg:circle").classed({"force-mapped-circle": true})
                    .attr({"r": "10", "data-patent": patent_no});                       // event handler attached to parent g.node
              marker.append("svg:use").attr({"xlink:href": "#force-mapped-cross-def"});
            }
          }

          function getPatentBiblioData(patent_info, event, $context, on_patent_data_complete, status) {
            // get the biblio data for patent patent_no (central patent on the force map) and make a new entry
            // for it in patList; update bibDone in status and callback on_patent_data_complete when done.
            var patent_url = patent_info.patent_url;
            var patent_no = patent_info.patent_no;
            switch (event.data.page) {
              case "main":                                                           // the map button on a patent tab is on the main page
                var div_id = $(event.currentTarget, $context).closest("a").attr("href");   // the href of the anchor element for the tab
                var patent_contents = $("div" + div_id + " > iframe", $context).contents();
                processPatentPage(patent_contents, patent_no, on_patent_data_complete, status);  // parse the patent page if button clicked on patent page
                break;
              case "search": case "related": case "related-root": case "map":        // if button clicked on search or related page
                var $aTab = $("a[data-tabname='" + patent_info.patent_no + "']");    // check if the patent tab for this patent already exists
                if ($aTab.length == 0) {                                             // if not get and parse the patent page
console.log("In getPatentBiblioData, tab for this patent is not open; request data from Google " + (new Date() - startTime)/1000);
                 $.get(patent_url, function(doc) {processPatentPage(doc, patent_no, on_patent_data_complete, status);});
                }
                else {                                                               // if so, parse the patent document that was already loaded
                  var div_id = $aTab.attr("href");
console.log("In getPatentBiblioData, tab for this patent is already open");
                  var patent_contents = $("div" + div_id + " > iframe", $context).contents();
                  processPatentPage(patent_contents, patent_no, on_patent_data_complete, status);
                }
                break;
              default:
                console.log("Unhandled case in getPatentBiblioData");
            }
          }
/*
$.ajax({ type: "POST",
         url: "ops.epo.org/3.1/auth/accesstoken",
         headers: {"Authorization": "Basic xxxxxxx"},
         contentType: "application/x-www-form-urlencoded; charset=UTF-8",    // this is default
         data: {"grant_type": "client_credentials"},
         dataType: "json"
      });

$.ajax({ type: "GET",              // works with epodoc or docdb
         url: "https://ops.epo.org/3.1/rest-services/published-data/publication/epodoc/EP2337452.A2",
         headers: {"Authorization": "Bearer access_token",
                   "Accept": "application/json"},
         contentType: "application/x-www-form-urlencoded; charset=UTF-8",    // this is default
         dataType: "json"
      });

$.ajax({ type: "POST",             // bulk request only seems to work with epodoc
         url: "https://ops.epo.org/3.1/rest-services/published-data/publication/epodoc/biblio",
         headers: {"Authorization": "Bearer access_token",
                   "Accept": "application/json"},
         contentType: "application/x-www-form-urlencoded; charset=UTF-8",    // this is default
         data: {"Request Body" : ,doc1,doc2,doc3 comma or newline separated list of patent documents, must begin with a comma (max 100/request)},
         dataType: "json"
      });
*/

          function getQuickBiblioData(patent_no, on_favorite_data_complete) {
          // get bibliographic data for patent_no for use in the favorites list using the Google related art service
          // goal is to get the data quickly, so do not get citing patent list, which requires loading and parsing the full patent
          // POST requests to /patents/related/rpc; a very convenient way to get the bibliographic info!!
          // Use chrome extension 'Postman' to debug the POST query
          // Get the metadata (info in the panel on the right side of a related patents page.
            $.ajax({ type: "POST",
                     url: "/patents/related/rpc",
                     headers: {"XmlHttpRequest": "2"},
                     contentType: "application/x-www-form-urlencoded; charset=UTF-8",    // this is default
                     data: {"m": "metadata",
                            "id": patent_no},
                     success: on_complete_quick_metadata_post,
                     dataType: "json"
                   });

            function on_complete_quick_metadata_post(data) {
           // extract the biblio information from the data returned by the metadata query;
              favoriteBiblio[patent_no]["title"] = data[1];
              // dates come back as a list of integers [year, month, day]; need to convert to "YYYYMMDD" format for makeGoogleDate
              favoriteBiblio[patent_no]["file_date"] = makeGoogleDate(data[6][0] + ("0" + data[6][1]).slice(-2) + ("0" + data[6][2]).slice(-2));
              favoriteBiblio[patent_no]["pub_date"] = makeGoogleDate(data[7][0] + ("0" + data[7][1]).slice(-2) + ("0" + data[7][2]).slice(-2));
              favoriteBiblio[patent_no]["inventors"] = data[11].join(", ");
              favoriteBiblio[patent_no]["assignee"] = data[12][0];               // take just the first one
              on_favorite_data_complete();
            }
          }

          function getRelatedPatentList(patent_no, on_patent_data_complete, status) {
          // Get a list of patents related to patent_no using the Google related art service;
          // update relDone in status and callback on_patent_data_complete when done. 
          // Looked at Network requests in chrome developer tools and noticed that related patent data is fetched using
          // POST requests to /patents/related/rpc; a very convenient way to get the related patent numbers!!
          // Use chrome extension 'Postman' to debug the POST query
          // Get the metadata (info in the panel on the right side of a related patents page.
            $.ajax({ type: "POST",
                     url: "/patents/related/rpc",
                     headers: {"XmlHttpRequest": "2"},
                     contentType: "application/x-www-form-urlencoded; charset=UTF-8",    // this is default
                     data: {"m": "metadata",
                            "id": patent_no},
                     success: on_complete_related_metadata_post,
                     dataType: "json"
                   });

            function on_complete_related_metadata_post(data) {
              // extract top three search terms from the data returned by the metadata query;
              // get the patents related to patent_no, and using the search terms.
              var searchTermsList = data[10][1];                   // the list of search terms that appears on the left side
              searchTerms = searchTermsList.slice(0,3).join(" ");  // of a related art page; concatenate the first 3 (like Google does)
              $.ajax({ type: "POST",
                       url: "/patents/related/rpc",
                       headers: {"XmlHttpRequest": "2"},
                       contentType: "application/x-www-form-urlencoded; charset=UTF-8",  // this is default
                       data: {"m": "search",
                             "q": searchTerms,
                             "c": "p",
                             "start": "",
                             "end": encodeURIComponent(dateString(new Date())),
                             "page": "0",
                             "pid": patent_no},
                      success: on_complete_related_patents_post,
                      dataType: "json"
                     });
            }

            function on_complete_related_patents_post(data) {
              // extract the list of the related patents from the JSON
              patentBiblio[patent_no]["related_patents"] = [];
              var relatedList = data[5];
              for (var i = 0; i < relatedList.length; i++) {
                related_patent_no = relatedList[i][7][0][0];
                patentBiblio[patent_no]["related_patents"].push(related_patent_no);
              }
              status["relDone"] = true;
              on_patent_data_complete(status);
            }
          }

          function dateString(newDate) {
            // return a date string 'mm/dd/yyyy' from Date object newDate
            var dayNow = newDate.getDate().toString();
            dayNow = dayNow.length < 2 ? "0" + dayNow : dayNow;
            var monthNow = (newDate.getMonth() + 1).toString();
            monthNow = monthNow.length < 2 ? "0" + monthNow : monthNow;
            var yearNow = newDate.getFullYear().toString();
            return monthNow + "/" + dayNow + "/" + yearNow
          }

          function processPatentPage(doc, patent_no, on_patent_data_complete, status) {
            // doc is the document for a Google patent page; parse it for title, inventors, assignee, cited patents, and citing patents;
            // add the data to the patentObj object for the patent; update bibDone in status and callback on_patent_data_complete when done.
            var $docBody = $(doc).select("body");
            $docBody.remove("div.patent-description-section");
            var patentObj = patentBiblio[patent_no];
            var tia = getTIA($docBody);                         // title, inventors, assignee in separate function, also used in setting up a patent tab
            var file_date = $("table.patent-bibdata td.patent-bibdata-heading:contains('Filing date') + td.single-patent-bibdata", $docBody).text();
            var pub_date = $("table.patent-bibdata td.patent-bibdata-heading:contains('Publication date') + td.single-patent-bibdata", $docBody).text();
            var abstract = $("div.abstract", $docBody).text();
            patentObj["title"] = tia.title;
            patentObj["inventors"] = tia.inventors;
            patentObj["assignee"] = tia.assignee;
            patentObj["abstract"] = abstract;
            patentObj["file_date"] = file_date;
            patentObj["pub_date"] = pub_date;
            var $cited = $("a#backward-citations ~ table.patent-data-table td.citation-patent a", $docBody);
            var cited_patents = new Array($cited.length);
            $cited.each(function(index) {cited_patents[index] = this.textContent;}); // $(this).text());});
            var $citing = $("a#forward-citations ~ table.patent-data-table td.citation-patent a", $docBody)
            var citing_patents = new Array($citing.length);
            $citing.each(function(index) {citing_patents[index] = this.textContent;}); // $(this).text());});
            patentObj["cited_patents"] = cited_patents;
            patentObj["citing_patents"] = citing_patents;
            status["bibDone"] = true;
            on_patent_data_complete(status);
          }

          function checkDataForPatents(source_patent, inList, type) {
          // check epoBiblio to see which patents in inList we have already queried EPO for biblio data;
          // add patents with data to the lists of nodes and links for the force diagram with source_patent as its focus;
          // add patents without data to the outList for querying EPO; return a list outList of the patents for which
          // there is no biblio data.
            var outList = [];
            for (var i = 0; i < inList.length; i++) {
              var patent_no = inList[i];
              if (epoBiblio[patent_no]) {                       // if we already have EPO data for this patent
                addTargetPatentToForceMap(source_patent, patent_no, type);
              }
              else {
                outList.push(patent_no);
              }
            }
            console.log("Adding " + (inList.length-outList.length) + " out of " + inList.length + " " + type + " patents to the force map that we already have data for");
            if (outList.length < inList.length) {
              updateForceMap();                                   // map the patents for which we already have data from EPO
            }
            return outList;
          }

          function makeQueryLists(inList, type) {
          // inList is a list of cited, citing, or related patents; split each into groups of 15 and return a list of objects
          // containing keys "list": subList of patents to query, "type" of the subList (cited, citing, or related), and
          // "done", which tracks whether the query has completed.

            var sizeList = 15;                                          // split patents in inList into subLists of 15
            var nList = Math.floor(inList.length/sizeList);
            var queryLists = [];
            for (var iList = 0; iList < nList; iList++) {
              var subList = inList.slice(iList*sizeList, (iList+1)*sizeList);
              queryLists.push({"list": makeEPOQueryList(subList), "type": type, "done": false});
            }
            if (nList*sizeList < inList.length) {                      // the elements at the end of inList
              var subList = inList.slice(nList*sizeList);
              queryLists.push({"list": makeEPOQueryList(subList), "type": type, "done": false});
            }
            return queryLists;
          }

          function makeAllQueryLists(source_patent, q_citedList, q_citingList, q_relatedList) {
          // source_patent is the central patent of the force map;
          // given arrays citedList, citingList, and relatedList, split each into arrays of length 15 for querying EPO in small groups;
          // send to makeEPOQueryList to make comma-separated strings; process each list separately since we want to display the links
          // differently in d3js; return a list of EPO query lists and associated type of list (cited, citing, etc).
            return [].concat(makeQueryLists(q_citedList, "cited"), makeQueryLists(q_citingList, "citing"), makeQueryLists(q_relatedList, "related")); 
          }

          function makeEPOQueryList(patentList) {
            // given patentList list of patent publications as obtained from Google, return a string suitable for a bulk POST query to the 
            // EPO API; the string is a list of comma-separated patent publication numbers that also starts with a comma; publication numbers
            // are formatted using formatPatentNumber(patent_no) so EPO can understand the request.
            var queryList = "";
            for (var i = 0; i < patentList.length; i++) {
              var patent_no = patentList[i];                           // Google format
              var formattedPN = formatPatentNumber(patent_no);         // EPO query format
              if (formattedPN != "") {
                for (var iForm = 0; iForm < formattedPN.length; iForm++) {
                  queryList = queryList + "," + formattedPN[iForm];
                  var epo_patent_no = formattedPN[iForm].replace(/\./g, "");
                  patentNoEPOtoGoogle[epo_patent_no] = patent_no;        // add to EPO to Google patent doc number dictionary
                }
              }
            }
            return queryList;
          }

          function formatPatentNumber(patent_no) {
          // patent_no is a patent number as it appears in the cited patents sections on the Google patent page.
          // It is a string with the country code, publication number, and kind and no spaces in between.
          // Returns a document ID string suitable for the EPO API.
          // US patent numbers start with various letters if they are not utility patents; older JP patent numbers can start with a letter like H or S.
            rExp_EPO_docid_from_Google_patent_no = /([A-Z]{2})([A-Z]*)(\d+)([A-Z]*\d*)/;
            var match = rExp_EPO_docid_from_Google_patent_no.exec(patent_no);
            // Google does not distinguish between US utility applications and plant applications, but EPO does! So need to query EPO with the
            // application number (utility patent) and the application number with 'P' appended (plant patent);
            if (match) {
              var cc = match[1]; var pub_type = match[2]; var pub_no = match[3]; var kind = match[4];
              var us_application_flag = false;
              var formattedList = [];
              switch (cc) {
                case "US":
                  if (pub_no.length == 11 && pub_no[4] == "0") { // EPO API removes the leading zero of a US application publication
                    pub_no = pub_no.slice(0,4) + pub_no.slice(5);
                    us_application_flag = true;
                  }
                  switch (pub_type) {
                    case "D":
                      pub_no = pub_no + "S";
                      break;
                    case "PP":
                      pub_no = pub_no + "P";
                      pub_type = ""
                      break;
                    case "RE":
                      pub_no = pub_no + "E";
                      break;
                    default:
                  }
                  break;
                case "WO":
                  intDoc = parseInt(pub_no.slice(4,10));               // get document number (six digits in Google format)
                  intYear = parseInt(pub_no.slice(0,4));
                  switch (true) {                                     // fix the document number
                    case intYear <= 2002:
                      if (intDoc < 100000) {
                        pub_no = pub_no.slice(0,4) + pub_no.slice(5); // five-digit document number if <10000;
                      }
                      break;
                  }
                  switch (true) {                                     // fix the year
                    case intYear <= 2003:                             // use two-digit year for years 2003 and previous
                      pub_no = pub_no.slice(2);
                      break;
                  }
                  break;
              }
              formattedList.push(cc + pub_type + pub_no + (kind ? "." + kind : ""));
              if (us_application_flag) {
                formattedList.push(cc + pub_type + pub_no + "P" + (kind ? "." + kind : ""));
              }
              return formattedList;
            }
            else {
              console.log("In formatPatentNumber, could not match '" + patent_no + "'. Skipping...");
              return '';
            }
          }
        }
      }

      function on_search_result_load(iframeElement, tab_id, htmlSearchTermsTable, htmlPopoverTable) {
        var $context = $(iframeElement).contents();
        process_links($context, "search");       // make google links point to my server
        process_search_result_contents($context, htmlSearchTermsTable);  // set up the search terms summary at the top of the page
        setupSearchTab(tab_id, htmlPopoverTable);            // set up the popover for the tab for this page
        $("a#" + tab_id).tab("show");
        window.scrollTo(0,0);
      }

      function on_more_result_load(iframeElement, htmlSearchTermsTable) {
        var $context = $(iframeElement).contents();
        process_links($context, "search");
        process_search_result_contents($context, htmlSearchTermsTable);
        // htmlSearchTermsTable has been cloned from the original search page; popover has already been attached to the tab
      }

      function process_links($context, page_type) {
        $("a", $context).each(function() {                   // for each link on the page
          var orig_url = $(this).attr("href");
          if (orig_url) {
            if (external_URLs.some( function(external_URL) {return orig_url.search(external_URL) >= 0 ? true : false;})) {
              $(this).on("click", on_click_external);                // open these links in a new browser tab
            }
            else {
              var strip_url = orig_url.replace('https', 'http');
              strip_url = strip_url.replace('http://www.google.com', '');  // open these links as relative to my site
              $(this).attr("href", strip_url);
              var rExp = /\/[^\?/]*[\?/]/;
              var link_match = rExp.exec(strip_url);
              var link_type = (link_match) ? link_match[0] : '';
              switch (link_type) {
                case "/patents/":
                  $(this).removeAttr("onmousedown");
                  if (strip_url.search('/patents/related') >= 0) {
                    // when search page loads, 'related' url starts with /patents/related
                    $(this).on("click", {$context: $context, page: page_type}, on_click_new_related_url);
                  }
                  else {
                    // patent link on search or patent page, except for Grant, Application, and Also Published As which have their own
                    // click handlers because we want to display them in the same tab as the original patent
                    $(this).on("click", {$context: $context, page: page_type}, on_click_new_patent_url);
                  }
                  break;
                case "/search?":
                  if (strip_url.search('&start=') >= 0) {
                    $(this).on("click", on_click_more_search_result);   // more search results from the same page; do not open a new tab
                  }
                  else {
                    $(this).on("click", on_click_new_search_url);       // search link on a search page or a patent page; open a new tab
                  }
                  break;
                case "/url?":
                  if (strip_url.search('/www.google.com/patents/') >= 0) {
                    $(this).on("click", {$context: $context, page: page_type}, on_click_new_patent_url); // patent link on prior art page;
                  }                                                                                                       // fetches patent as query after /url?
                  else {                                                    // this branch should never be called since the 'related' link on a search page
                    // is processed when the page loads; after mousedown, url changes, starts with /url?
                    $(this).on("click", {$context: $context, page: page_type}, on_click_new_related_url);
                  }
                  break;
                default:
                // there are other types of links as well which are not visible on the page
              }
            }
          };
        });
      }

      function on_click_new_related_url(event) {
        event.preventDefault();
        event.stopPropagation();
        var related_url = $(this).attr("href");
        var patent_info = getPatentURL_No(event.currentTarget, event.data.$context, event.data.page);
        var $aTab = $("a[data-tabname='Re-" + patent_info.patent_no + "']");    // check if the related tab for this patent already exists
        if ($aTab.length == 0) {
          // add '#c=p' suffix to load patents only; otherwise need to simulate a click on the Patents option at the top of the page.
          make_related_tab(related_url + "#c=p");
        }
        else {
          $aTab.click();
        }
      }

      function on_click_new_patent_url(event) {
        // patent url's can be clicked on map, search, related (as a related patent or as the root patent), or patent pages
        // event.data.$context stores the jQuery context of the element that triggered the event
        // event.data.page stores the type of page the link was clicked on
        event.preventDefault();
        event.stopPropagation();
console.log("Here new patent");
        var patent_info = getPatentURL_No(event.currentTarget, event.data.$context, event.data.page);
        var $aTab = $("a[data-tabname='" + patent_info.patent_no + "']");    // check if the patent tab for this patent already exists
        if ($aTab.length == 0) {
          make_patent_tab(patent_info.patent_url, patent_info.patent_no);
        }
        else {
          $aTab.click();
        }
      }

      function on_click_AlsoPublishedAs(event) {
        var $context = $(this.ownerDocument.body);
        var grant_url = $(this).attr("href");
        var link_match = rExp_patno_from_url.exec(grant_url);
        var grant_no = link_match ? link_match[1] : '';
        // if patent will not open in separate browser tab, change the caption of the current application tab
        if (!external_URLs.some( function(external_URL) {return grant_url.search(external_URL) >= 0 ? true : false;})) {  
          $("ul#topTabs li.active > a > span").text(grant_no);
        }
        window.scrollTo(0,0);
      }

      function on_click_more_search_result(event) {
        event.preventDefault();
        event.stopPropagation();
        var $currentIFrame = $("div.tab-pane.active iframe");                 // jQuery object - the containing iframe
        var more_results_url = $(this).attr("href");
        make_more_result_tab($currentIFrame, more_results_url);
      }

      function on_click_new_search_url(event) {
        event.preventDefault();
        event.stopPropagation();
        var search_url = $(this).attr("href");
        var link_text = $(this).text();
        var link_words = link_text.split(/[,\s]+/);                           // split on one or more ,whitespace
        var tab_title = 'Result';
        var searchTerms = [{}, {"name" : "as_drrb_is", "value": "q"}, {"name": "as_ptypeorstatus", "value": "0"}]; // mimic google patent search form input fields
        if (search_url.search('ininventor') >= 0) {
          if (link_words.length > 0) {
            var last_word = link_words[link_words.length-1];
            switch (last_word.toUpperCase()) {
              case "JR": case "JR.": case "II": case "III": case "IV":
                tab_title = link_words[link_words.length-2];
                break;
              default:
                tab_title = last_word;
            }
          }
          searchTerms[0] = {"name": "as_pinvent", "value": link_text};
        }
        else if (search_url.search('inassignee') >=0) {
          if (link_words.length > 0) {
            tab_title = link_words.length > 1 ? link_words[0] + '...' : link_words[0];
            searchTerms[0] = {"name": "as_pasgnee", "value": link_text};
          }
        }
        else {
          console.log('Did not match search url in on_click_new_search_url');
        }
        make_search_result_tab(search_url, tab_title, searchTerms);
      }

      function process_patent_button_bar($context) {
        $("div.goog-inline-block.jfk-button", $context).each(function() {
          var button_text = $(this).text();
          // Remove any language translation buttons, 'Discuss this patent'
          if (button_text != 'Application' && button_text != 'Grant' && button_text != 'Find prior art'
            && button_text != 'View PDF' && button_text != 'Download PDF') $(this).remove();
        });
        $("div[role='button'] img[src*='settings.png']", $context).parent().parent().remove();  // gearbox settings button
        var origLeftToolbarButtons = $("div#left-toolbar-buttons", $context);
        var origRightToolbar = $("div#right-toolbar-buttons div.viewport-chrome-toolbar", $context);
        // replace divs with themselves as the only way to remove anonymous mousedown and mouseup event listeners;
        // clone('false') = do not clone event listeners;
        origRightToolbar.replaceWith(origRightToolbar.clone('false'));
        var newRightToolbar = $("div#right-toolbar-buttons div.viewport-chrome-toolbar", $context);
        newRightToolbar.on('mousedown', divMouseDown);
        newRightToolbar.on('click', on_click_patent_div_button);
      }

      function getTIA($context) {
        // get title, inventor(s), and assignee(s) in a patent document $context; used when setting up a patent tab and in the
        // a patent entry in the patentBiblio object list
        var title = $("invention-title", $context).text();
console.log("Got title " + (new Date() - startTime)/1000);
        var inventors = "";
        var assignee = "";
        $("table.patent-bibdata td.patent-bibdata-heading:contains('Inventors') + td span.patent-bibdata-value", $context)
            .each(function() {inventors += $(this).text();});
console.log("Got inventors " + (new Date() - startTime)/1000);
        $("table.patent-bibdata td.patent-bibdata-heading:contains('Assignee') + td span.patent-bibdata-value", $context)
            .each(function() {assignee += $(this).text();});
        if (assignee == "") {                                      // Assignee or Applicant, depending on which country
          $("table.patent-bibdata td.patent-bibdata-heading:contains('Applicant') + td span.patent-bibdata-value", $context)
            .each(function() {assignee += $(this).text();});
        }
console.log("Got assignee " + (new Date() - startTime)/1000);
        return {title: title, inventors: inventors, assignee: assignee};
      }

      function on_click_patent_div_button(event) {
        switch ($(event.target).text()) {
          case "Find prior art":
            var related_url = $("a#appbar-patents-prior-art-finder-link", $(event.target.ownerDocument)).attr("href");
            make_related_tab(related_url);
            break;
          case "View PDF":
            var external_url = $("a#appbar-read-patent-link", $(event.target.ownerDocument)).attr("href");
            window.open(external_url);
            break;
          case "Download PDF":
            var external_url = $("a#appbar-download-pdf-link", $(event.target.ownerDocument)).attr("href");
            window.open(external_url);
            break;
          default:
        }
      }

      function divMouseDown(event) {
        event.preventDefault();
//          event.stopPropagation();
      }

      function on_click_Application(event) {
        var $context = $(this.ownerDocument);
        var thisIndex = event.data.index;                       // index of element the triggered the event
        var application_url = $("a[data-label='Application']", $context).eq(thisIndex).attr("href");
        var link_match = rExp_patno_from_url.exec(application_url);
        var application_no = link_match ? link_match[1] : '';
        $("ul#topTabs li.active > a > span").text(application_no);     // note we are not changing the id of the tab
        window.scrollTo(0,0);
      }

      function on_click_Grant(event) {
        var $context = $(this.ownerDocument);
        var thisIndex = event.data.index;
        var grant_url = $("a[data-label='Grant']", $context).eq(thisIndex).attr("href");
        var link_match = rExp_patno_from_url.exec(grant_url);
        var grant_no = link_match ? link_match[1] : '';
        $("ul#topTabs li.active > a > span").text(grant_no);     // note we are not changing the id of the tab
        window.scrollTo(0,0);
      }

      function on_click_external(event) {
        event.preventDefault();
        event.stopPropagation();
        var external_url = $(this).attr("href");
        window.open(external_url);
      }

    </script>

    <script id="customize-bootstrap-styles" type="text/template">    <!-- will load in main window -->
      <!-- import style for popovers on search, patent, and prior art pages -->
      <style type="text/css">
        @import url("/css/jdwpopovers.css");
        @import url("/css/jdwbuttons.css");
      </style>
    </script>

    <!-- html for adding the '+' and 'heart' (add and favorite) buttons to the Google related art page
         piggy back off of the Google css class 'hide-result-btn' for the 'x' that hides a patent;
         edit the /patents/related/static/icons.png file and add +' and 'heart' icons; (this file has many icons);
         save as iconsJDW and serve from the /css directory on my server; we select which icon to use by setting
         the position, height, and width of the background css parameter. -->
    <script id="related-art-page-button-content" type="text/template">
      <span class="hide-result-btn btn-favorite-add" title="Add to favorites"></span>
      <span class="hide-result-btn btn-map-add" title="Add to patent map"></span>
    </script>

    <script id="search-page-button-content" type="text/template">
      <span class="hide-result-btn btn-hide-add" title="Hide"></span>
      <span class="hide-result-btn btn-favorite-add" title="Add to favorites"></span>
      <span class="hide-result-btn btn-map-add" title="Add to patent map"></span>
    </script>

    <script id="search-page-unhide-results" type="text/template">
      <div class="hidden-results-info hidden-show-all">
        <span class="hidden-results-message">0 result hidden below.</span>
        <span class="hidden-results-clear-btn">Show all</span>
      </div>
    </script>

    <script id="prior-art-popover-title" type="text/template">
      Prior art for <%= patent_no %>:<br><span class="popover-subtitle jdwprior"><%- patent_title %></span>
    </script>

    <script id="prior-art-popover-content" type="text/template">
      <table id="jdw20">
        <tbody id="jdw21">
          <tr>
            <td class="jdw22">Search terms:</td>
            <td class="jdw23" id="jdw-pop-search-terms"><%- searchTerms %></td>
          </tr>
          <tr>
            <td class="jdw22">Start date:</td>
            <td class="jdw23" id="jdw-pop-start-date"><%= startDate %></td>
          </tr>
          <tr>
            <td class="jdw22">End date:</td>
            <td class="jdw23" id="jdw-pop-end-date"><%= endDate %></td>
          </tr>
        </tbody>
      </table>
    </script>

    <script id="patent-info-popover" type="text/template">
      <table id="jdw20">
        <tbody id="jdw21">
          <tr>
            <td class="jdw22">Inventors:</td>
            <td class="jdw23"><%= inventors %></td>
          </tr>
          <tr>
            <td class="jdw22">Assignee:</td>
            <td class="jdw23"><%= assignee %></td>
          </tr>
        </tbody>
      </table>
    </script>
    
    <script id="search-term-popover" type="text/template">            <!-- will load in main window -->
      <table id="jdw14">
        <tbody>
          <tr>
            <td class="tcell"><%- t1 %></td>
            <td class="vcell"><%- v1 %></td>
            <td class="tcell"><%- t5 %></td>
            <td class="vcell"><%- v5 %></td>
            <td class="tcell"><%- t9 %></td>
            <td class="vcell"><%- v9 %></td>
            <td class="tcell"><%- t13 %></td>
            <td class="vcell"><%- v13 %></td>
          </tr>
          <tr>
            <td class="tcell"><%- t2 %></td>
            <td class="vcell"><%- v2 %></td>
            <td class="tcell"><%- t6 %></td>
            <td class="vcell"><%- v6 %></td>
            <td class="tcell"><%- t10 %></td>
            <td class="vcell"><%- v10 %></td>
            <td class="tcell"><%- t14 %></td>
            <td class="vcell"><%- v14 %></td>
          </tr>
          <tr>
            <td class="tcell"><%- t3 %></td>
            <td class="vcell"><%- v3 %></td>
            <td class="tcell"><%- t7 %></td>
            <td class="vcell"><%- v7 %></td>
            <td class="tcell"><%- t11 %></td>
            <td class="vcell"><%- v11 %></td>
            <td class="tcell"><%- t15 %></td>
            <td class="vcell"><%- v15 %></td>
          </tr>
          <tr>
            <td class="tcell"><%- t4 %></td>
            <td class="vcell"><%- v4 %></td>
            <td class="tcell"><%- t8 %></td>
            <td class="vcell"><%- v8 %></td>
            <td class="tcell"><%- t12 %></td>
            <td class="vcell"><%- v12 %></td>
            <td class="tcell"><%- t16 %></td>
            <td class="vcell"><%- v16 %></td>
          </tr>
        </tbody>
      </table>
    </script>

    <!-- tweek formating of Gooooogle span so it disappears.  Will load in iframe of search pages -->
    <script id="search-page-more-results-style" type="text/template">
      <style type="text/css">
        @import url("/css/jdwsearchresultpage.css");
      </style>
    </script>

    <script id="search-term-table-style" type="text/template">    <!-- loads in iframe of search, patent, related, and hidden related pages -->

      <!-- import styles for:
             inserted Map and Favorites buttons
             customized page header
             animation trick to get the prior art div.r's to load properly -->
      <style type="text/css">
        @import url("/css/jdwbuttons.css");
        @import url("/css/jdwpageheader.css");
        @import url("/css/jdwpriorartpage.css");
      </style>
    </script>

    <!-- replacement header for google search and patent pages -->
    <script id="page-header" type="text/template">
      <div id="jdwTop">
        <div class="gb_ba gb_f jdwGoog" id="gbq1" style="max-width:127px;min-width:127px">
          <div class="gb_ca">
            <!-- replace the <a> tag in the Google page with a span having the same classes -->
            <!-- get google logo with this span -->
            <span class="gb_fb gb_ea">
              <span class="gb_c"></span>
            </span>
          </div>
        </div>
      </div>
    </script>

    <!-- header for prior art page -->
    <script id="prior-art-table" type="text/template">                  <!-- will load in prior art iframe -->
      <div id="jdw30" class="gbt">
        <h2 id="jdw31">Prior art for <%= patent_no %></h2>
      </div>
    </script>

    <!-- search term table -->
    <script id="search-term-table" type="text/template">                <!-- will load in iframe -->
      <div id="jdw1" class="gbt">
        <div id="jdw2" class="gbt">
          <table>
            <tbody>
              <tr>
                <td><b>Search terms:</b></td>
              </tr>
            </tbody>
          </table>
        </div>
        <div id="jdw3" class="gbt">
          <table id="jdw4">
            <tbody>
              <tr>
                <td class="tcell"><%- t1 %></td>
                <td class="vcell"><%- v1 %></td>
                <td class="tcell"><%- t5 %></td>
                <td class="vcell"><%- v5 %></td>
                <td class="tcell"><%- t9 %></td>
                <td class="vcell"><%- v9 %></td>
                <td class="tcell"><%- t13 %></td>
                <td class="vcell"><%- v13 %></td>
              </tr>
              <tr>
                <td class="tcell"><%- t2 %></td>
                <td class="vcell"><%- v2 %></td>
                <td class="tcell"><%- t6 %></td>
                <td class="vcell"><%- v6 %></td>
                <td class="tcell"><%- t10 %></td>
                <td class="vcell"><%- v10 %></td>
                <td class="tcell"><%- t14 %></td>
                <td class="vcell"><%- v14 %></td>
              </tr>
              <tr>
                <td class="tcell"><%- t3 %></td>
                <td class="vcell"><%- v3 %></td>
                <td class="tcell"><%- t7 %></td>
                <td class="vcell"><%- v7 %></td>
                <td class="tcell"><%- t11 %></td>
                <td class="vcell"><%- v11 %></td>
                <td class="tcell"><%- t15 %></td>
                <td class="vcell"><%- v15 %></td>
              </tr>
              <tr>
                <td class="tcell"><%- t4 %></td>
                <td class="vcell"><%- v4 %></td>
                <td class="tcell"><%- t8 %></td>
                <td class="vcell"><%- v8 %></td>
                <td class="tcell"><%- t12 %></td>
                <td class="vcell"><%- v12 %></td>
                <td class="tcell"><%- t16 %></td>
                <td class="vcell"><%- v16 %></td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </script>

    <!-- scripts for inserting a Bootstrap tab and tab content-->
    <script id="bs_tab-pane" type="text/template">
      <div class="tab-pane" id="<%= tab_content_id %>">
        <iframe class="gps_result" id="<%= iframe_id %>" width="<%= iframe_width %>" height="<%= iframe_height %>" allowfullscreen="true" sandbox="allow-same-origin allow-top-navigation allow-forms allow-scripts">
        </iframe>
      </div>
    </script>

    <script id="bs_nav-tab" type="text/template">
      <li>
        <a id="<%= tab_id %>" href="#<%= tab_content_id %>" data-toggle="tab" data-tabname="<%= tab_name %>">
          <span><%= tab_name %></span>
          <div class="tb">
            <button class="close close-tab" type="button" onclick="deleteTab(event)">&times;</button>
          </div>
        </a>
      </li>
    </script>

    <!-- script for adding the Map and Favorites buttons to patent tabs -->
    <script id="tab-buttons" type="text/template">
       <div class="tb tb-left">
          <span class="hide-result-btn btn-map-add" title="Add to patent map"></span>
          <span class="hide-result-btn btn-favorite-add" title="Add to favorites"></span>
       </div>
    </script>

    <!-- script for templating the biblio popup on the force map -->
    <script id="force-pop1" type="text/template">
      <div class="pop1-container" data-patent="<%= patent_no %>">
        <div class="pop1-top-capture"></div>
        <div class="pop1-arrow"></div>
        <div class="pop1-patent-row">
          <div class="pop1-patent"><a class="pop1-patent-url" href="/patents/<%= patent_no %>"><%= patent_no %></a></div>
          <div class="pop1-buttons">
            <span class="hide-result-btn btn-map-add" title="Add to patent map"></span>
            <span class="hide-result-btn btn-favorite-add" title="Add to favorites"></span>
            <span class="hide-result-btn btn-pin-add" title="Pin to map"></span>
            <span class="hide-result-btn btn-hide-add" title="Delete from map"></span>
          </div>
          <div class="pop1-dates">
            <div>Appl: <%= file_date %></div>
            <div>Pub: <%= (pub_date != "") ? pub_date : "N/A" %></div>
          </div>
        </div>
        <div class="pop1-title"><%- (title != "") ? title : "Title not available" %></div>
        <div class="pop1-inventors"><%= (inventors !="") ? makeLinksHTML(inventors, "ininventor") : "Inventors not available" %></div>
        <div class="pop1-assignee"><%= (assignee != "") ? makeLinksHTML(assignee, "inassignee") : "Assignee not available" %></div>
        <div class="pop1-abstract"><strong>Abstract</strong><br><%- (abstract != "") ? abstract : "Not available" %></div>
        <div class="pop1-top-btns" data-patent="<%= patent_no %>">
          <svg class="pop1-top-btns-svg">
            <clipPath id="leftBtn">
              <rect x="-11px" y="-11px" width="21px" height="22px"></rect>
            </clipPath>
            <clipPath id="midBtn">
              <rect x="-10px" y="-11px" width="20px" height="22px"></rect>
            </clipPath>
            <clipPath id="rightBtn">
              <rect x="-10px" y="-11px" width="21px" height="22px"></rect>
            </clipPath>
            <g class="pop1-front" clip-path=url(#leftBtn)>                                         
              <title>Bring to front</title>        
              <rect class="pop1-front-btn" x="-10px" y="-10px" rx="7px" ry="7px" width="20px" height="20px"></rect>
              <rect class="pop1-front-back-unfilled" x="-5px" y="-5px" width="7px" height="7px"></rect>
              <rect class="pop1-front-back-filled" x="-2px" y="-2px" width="7px" height="7px"></rect>
            </g>
            <g class="pop1-back" clip-path=url(#midBtn)>
              <title>Send to back</title>
              <rect class="pop1-back-btn" x="-10px" y="-10px" rx="7px" ry="7px" width="20px" height="20px"></rect>
              <rect class="pop1-front-back-filled" x="-5px" y="-5px" width="7px" height="7px"></rect>
              <rect class="pop1-front-back-unfilled" x="-3px" y="-3px" width="8px" height="8px"></rect>
            </g>
            <g class="pop1-full" clip-path=url(#rightBtn)>
              <title>Full view</title>
              <rect class="pop1-full-btn" x="-10px" y="-10px" rx="7px" ry="7px" width="20px" height="20px"></rect>
              <rect class="pop1-full-rect" x="-5px" y="-4px" width="10px" height="8px"></rect>
            </g>
            <g class="pop1-close make-not-displayed" clip-path=url(#rightBtn)>
              <title>Popup view</title>
              <rect class="pop1-close-btn" x="-10px" y="-10px" width="20px" height="20px"></rect>
              <line class="pop1-close-x1" x1="-10px" y1="0px" x2="10px" y2="0px"></line>
              <line class="pop1-close-x2" x1="-10px" y1="0px" x2="10px" y2="0px"></line>
            </g>
          </svg>
        </div>
      </div>
      <% function makeLinksHTML(parseStr, queryTerm) {
        // parseStr is a comma separated string of names; from each name construct an <a> tag whose href is a google patent
        // search URL containing the query term queryTerm.
        var aPre = '<a class="pop1-search-url" href="/search?tbo=p&amp;tbm=pts&amp;hl=en&amp;q=' + queryTerm + ':%22';
        var aPost = '%22">';
        var aClose = '</a>';
        var itemArray = parseStr.split(/\s*,\s*/);
        itemArray = itemArray.map( function(name) {return aPre + name.replace(/\s+/g, "+") + aPost + name;});
        return itemArray.join(aClose + ", ") + aClose;
      } %>
    </script>

    <script type="text/javascript" charset="utf-8">

      // force map calculation space (somewhat arbitrary)
      var fMap = {
        "w": 1000,
        "h": 550,
        "minDate": new Date("01-01-1976"),
        "maxDate": new Date("01-01-2014"),
        "alpha": 0.1
      }

      // svg parameters
      var svgP = {
        "w" : 1160,     // was 960
        "h" : 600,     // was 500
        // need large margins to accomodate mouse dragging of nodes behind biblio divs
        "margin" : {"top": 10, "bottom" : 130, "left": 18, "right": 218}
      }

      // plotting and map display parameters
      var pParam = {
        "minDate": undefined,                              // min, max based on patent data
        "maxDate": undefined,
        "minX": undefined,                                 // min, max of the x (filing date) axis
        "maxX": undefined,
        "minY": 0,
        "maxY": fMap.h,
        "scale": 1,
        "panTransY": 0,                                    // need to track the panning and zooming contributions to the y translation reported
        "zoomTransY": 0,                                   // by d3 zoom.translation()
        "zMin": 0,                                         // for tracking the css z-index of biblios
        "zMax": 0
      };

      // legend parameters
      nLegendEntry = 8;                                    // maximum number of legend entries

      var d3_format_EPO_date = d3.time.format("%b %e, %Y");     // e.g., Nov 1, 1978

      function PatentNode(patent_no, source, biblio) {     // the data object that is bound as the force map node
        this.patent_no = patent_no;
        this.source = source;                              // true if the patent is the focus of the map
        this.biblio = biblio;                              // an object containing all the bibliographic data
        this.label = patent_no;
        this.key = patent_no;                              // data key for d3
        this.date = d3_format_EPO_date.parse(this.biblio.file_date);   // a javascript date
        this.x_fix = xForceScale(this.date);                // x_fix initialized according to the initial x-axis; x_fix never changes even if x-axis is changed
        this.plotX = 0;
        this.plotY = 0;
        // note the x_fix, x,y values used in the force map are never affected by zooming; plotX,plotY is the data that is actually used
        // in the transform operations on the actual SVG elements; this.x,.y will be created and defined when force map is created
        this.updatePlotCoord = function() {                 // need to call when the force map is zoomed
          this.plotX = xForceToPlotScale(this.x);
          this.plotY = yForceToPlotScale(this.y);           // translate in the y direction but do not zoom
        }
        this.drag = false;                                  // mark a node when it is being dragged 
        this.z_index = 0;                                   // css z-index
      }

      function PatentLink(source, target, type, key) {     // the data object that is bound as the force map link
        this.source = source;
        this.target = target;
        this.type = type;                                  // a string "cited", "citing", "related"
        this.key = key;                                    // data key for d3
      }

      function LegendEntry(assignee, legendColor, patentCount) {  // constructor for a LegendEntry instance
        this.assignee = assignee;
        this.legendColor = legendColor;
        this.patentCount = patentCount;
      }

      LegendEntry.makeShort = function(assignee) {          // static method for LegendEntry
        switch (assignee.slice(0,4).toUpperCase()) {
          case "":                                          // some patents have no assignee
            return "No assignee";
          case "UNIV":
            switch (assignee.slice(0,10).toUpperCase()) {
              case "UNIVERSITY":
                return assignee.slice(0,20);
              default:
                return assignee.slice(0,12);
            }
          default:
            return assignee.split(/[,\s]+/)[0].slice(0,6);  // use first six letters of first word as basis of matching an assignee name
        }
      }

      var patent
      var patentNodes = [];                                // force diagram nodes
      var patentLinks = [];                                // force diagram links
      var patentIndex = {};                                // dictionary of patents in the force diagram
      var linkIndex = {};                                  // dictionary of links in the force diagram
      var legendEntries = [];                              // array of LegendEntry legend entry objects that can be sorted by patentCount
      var legendObjects = {};                              // need a key-value collection of LegendEntry objects
      var legendColors = ['rgb(141,211,199)','rgb(255,255,179)','rgb(190,186,218)','rgb(251,128,114)','rgb(128,177,211)','rgb(253,180,98)',
                          'rgb(179,222,105)','rgb(252,205,229)','rgb(217,217,217)','rgb(188,128,189)','rgb(204,235,197)','rgb(255,237,111)']
      var visBiblio = [];                                  // list of short biblios that are visible and unpinned
      var visFullBiblio = [];                              // list of full biblios that are visible and unpinned

      var labelDistance = 0;
      var plotWidth = svgP.w - svgP.margin.left - svgP.margin.right;
      var plotHeight = svgP.h - svgP.margin.top - svgP.margin.bottom;

      // create div container element for the short biblio popovers; overlays the force map; need to add 1px to plotWidth and
      // plotHeight so the bib-container completely masks mouse events at the right and bottom edges of the force plot when
      // the full biblio is being shown.
      var bib = d3.select("#Map").select("div.bib-container")
                  .style({"position": "absolute", "width": (plotWidth+1) + "px", "height": (plotHeight+1) + "px",
                          "margin-top": svgP.margin.top + "px", "margin-bottom": svgP.margin.bottom + "px",
                          "margin-left": svgP.margin.left + "px", "margin-right": svgP.margin.right + "px"});

      // create the main svg element and attach mouse event handlers that will control when biblio pop-ups disappear
      // and allow mouse events to go through biblio pop-ups
      var svg_main = d3.select("#Map").select("svg.main-svg").attr({"width": svgP.w, "height": svgP.h})
                       .on("mousemove.biblio", on_mouse_main_svg)
                       .on("mouseover.biblio", on_mouse_main_svg)
                       .on("mouseoout.biblio", on_mouse_main_svg);

      // create g container element to contain the graphics; note var svg is actually the g element child of the
      // svg document element; appends to svg will be children of the g element
      var svg = svg_main.append("svg:g").attr("transform", "translate(" + svgP.margin.left + "," + svgP.margin.top + ")")

      // create a clipping region for the force map; does not actually clip anything until it is applied to a particular
      // graphics element via the clip-path attribute; apply to plot data, but not to axes
      svg.append("svg:clipPath").attr({"id": "clip"})
                                .append("svg:rect").attr({"width": plotWidth, "height": plotHeight});

      // create a clipping region for the mapped patent markers. (Append it here to avoid multiple copies for each marker)
      svg.append("svg:clipPath").attr({"id": "nodeClip"})
                                .append("svg:circle").attr({"id": "nodeMarker", "r": 7.5});

      // define the x-axis scale for the force map: domain is patent filing date; range is force map coordinates
      var xForceScale = d3.time.scale().domain([fMap.minDate, fMap.maxDate]).range([0, fMap.w]);
      // define the x- and y-axis scales for plotting: domain is patent filing date; range is pixel coordinates for plotting
      var xPlotScale = d3.time.scale().domain([pParam.minDate, pParam.maxDate]).range([0, plotWidth]);
      var yPlotScale = d3.scale.linear().domain([pParam.minY, pParam.maxY]).range([0, plotHeight]);

      // define the x- and y-axis scales for transforming force map coordinates to plotting coordinates
      var xForceToPlotScale = d3.scale.linear().domain([xForceScale(fMap.minDate), xForceScale(fMap.maxDate)])
                                               .range([xPlotScale(fMap.minDate), xPlotScale(fMap.maxDate)]);
      var yForceToPlotScale = d3.scale.linear().domain([0, fMap.h])
                                               .range([yPlotScale(0), yPlotScale(fMap.h)]);

      var xAxisLabel = d3.svg.axis().orient("bottom").tickPadding(4).tickSize(2).scale(xPlotScale);  // create the x-axis with labels only
      var xAxisLabelSVG = svg.append("g").classed({"x-axis-label": true})
                             .attr({"transform": "translate(0," + plotHeight +")"}); // create x axis label SVG elements
      var xAxisGrid = d3.svg.axis().orient("top").tickPadding(0).innerTickSize(plotHeight).outerTickSize(0).scale(xPlotScale); // create the x-axis gridlines
      var xAxisGridSVG = svg.append("g").classed({"x-axis-grid": true})
                             .attr({"transform": "translate(0," + plotHeight +")"})
                             .style({"stroke": "lightgray", "fill": "transparent"});     // x axis gridline SVG; override default stroke:white, fill:black

      // create the legend container
      var legend = svg.append("svg:g").classed({"legend": true}).attr({"transform": "translate(10, 10)"});

      // create a zoom function implementing zooming and panning; will zoom the x-axis
      var zoom = d3.behavior.zoom().on("zoom", on_zoom).x(xPlotScale);                     // zoom and translate the x axis; just translate the y axis
      var zoom_rect = svg.append("svg:rect").attr({"class": "zoom-pane", "width": plotWidth, "height": plotHeight}).call(zoom)  // container to process zoom events

      // create g container for the plot elements that will be clipped; plot elements will be drawn last so they are the first to receive events
      var plot = svg.append("svg:g").attr({"clip-path": "url(#clip)"});

      var allNodes = [];                                               // global variables for the force tick event handler
      var allLinks = [];                                               // and the zoom event handler
      var allBibs = [];
      var compiledPop1Template = _.template( $("script#force-pop1").html());

      // define the force map for the nodes, specifying the nodes, links, and linkStrengths
      var force = d3.layout.force().size([fMap.w, fMap.h]).nodes(patentNodes).links(patentLinks)
                    .gravity(0.05).linkDistance(function(link, i) {return Math.abs(link.source.x_fix - link.target.x_fix);})
                    .charge(-100).linkStrength(0.1);    // gravity 0.05; linkDistance = 50; linkStrength = 1; charge -10000

//      var force_drag = function() {}
      var force_drag = force.drag()
                       .on("dragstart.biblio", on_dragstart_force_patent)
                       .on("drag.biblio", on_drag_force_patent)
                       .on("dragend.biblio", on_dragend_force_patent);


      updateForceMap();

      force.on("tick", on_force_tick);

      var updateLink = function() {                                    // move a link to its new position
            this.attr("x1", function(d) {return d.source.plotX;})
                .attr("y1", function(d) {return d.source.plotY;})
                .attr("x2", function(d) {return d.target.plotX;})
                .attr("y2", function(d) {return d.target.plotY;});
      }

      var updateNode = function() {                                    // move a node to its new position
            this.attr("transform", function(d) {return "translate(" + d.plotX + "," + d.plotY + ")";});
      }

      var updateBib = function() {                                    // move a bib div to its new position
            this.style({"-webkit-transform": function(d) {return "translate(" + d.plotX + "px," + d.plotY + "px)"}})     // Chrome
                .style({"transform": function(d) {return "translate(" + d.plotX + "px," + d.plotY + "px)"}});            // Firefox
      }

      function on_force_tick(e) {
        allNodes.each(function(d, i) {                                 // update the force map coordinates .x and .y
//            d.x = d.px + 0.1*(d.x - d.px);
//            d.y = d.py + 0.1*(d.y - d.py);
            d.x = d.x + ((Math.log(10*0.099) - Math.log(10*e.alpha))/(Math.log(10*0.099) - Math.log(10*0.005)))*(d.x_fix - d.x);
                                                      // default value of alpha starts at 0.1 and decays exponentially to 0.005
            d.updatePlotCoord();                                       // update the SVG plotting coordinates .plotX and .plotY
          });
        allNodes.call(updateNode);
        allBibs.call(updateBib);
        allLinks.call(updateLink);
      }

      function on_drag_force_tick(e) {
        allNodes.each(function(d, i) {                         // update the force map coordinates .x and .y
            if (d.drag) {                                      // this node is being dragged
console.log("Hello from on_drag_force_tick");
console.log("cur tick d: ", d.x, d.y);
//                d.plotX = d.orig_plotX + (d.x - d.orig_x);   // use this and next line if want to follow drag in x direction
//                d.x = xForceToPlotScale.invert(d.plotX);
              d.x = d.orig_x;                                  // do not drag in x direction; do not change d.plotX
              d.plotY = d.orig_plotY + (d.y - d.orig_y);       // drag in y direction
              d.y = yForceToPlotScale.invert(d.plotY);
console.log("new tick d: ", d.x, d.y);
            }
            else {
              d.x = d.x + 0.2*(d.x_fix - d.x);
              d.updatePlotCoord();                             // update the SVG plotting coordinates .plotX and .plotY
            }
          });
        allNodes.call(updateNode);
        allBibs.call(updateBib);
        allLinks.call(updateLink);
      }

      function on_dragstart_force_patent(d, i) {
console.log("Hello from on_dragstart_force_patent");
console.log(d3.event);
        d.drag = true;                          // save the current x position so can restrict the drag to the y direction
        d.orig_x = d.x;
        d.orig_y = d.y;
        d.orig_plotX = d.plotX;
        d.orig_plotY = d.plotY;
        force.on("tick", on_drag_force_tick);
        d.fixed = true;                         // so node does not move after dragging
      }

      function on_drag_force_patent(d, i) {
      // When the drag handler is called, event.x, event.y is the position computed as the d.x, d.y when the drag was started
      // + pixels traveled by dragging; thus the starting point is in force map coordinates, but the distance traveled is
      // in pixels (i.e., plotting coordinates).
      // event.dx, event.dy are the changes in pixels from the previous mouse position;
      // d.x, d.y are the old force coordinates; they have not yet been updated with the current mouse event coordinates
      // by the time the tick handler is called, d.x, d.y values are the same as the drag event.x, event.y;
      // changing: event.x, event.y; event.dx, event.dy; or d.x., d.y in the drag handler has no effect on d in tick event handler
      // if d.x, d.y are changed in the tick handler, those values are still present when the drag handler is called.
      }

      function on_dragend_force_patent(d, i) {
console.log("Hello from on_dragend_force_patent");
        d.drag = false;
          // need to change d.px, d.py because at end of drag they are set to coordinates based on the current mouse position,
          // not the current node position, causing nodes to bounce back into position in weird ways
        d.px = xForceToPlotScale.invert(d.plotX);
        d.py = yForceToPlotScale.invert(d.plotY);
        force.on("tick", on_force_tick);
      }

      function updateForceMap() {
      // add new nodes to the force map as the patent data is received from EPO
console.log("updateForceMap");
console.log(patentNodes);
console.log(patentLinks);

        var link = plot.selectAll("line.link").data(force.links(), function(d) {return d.key;}).enter().append("svg:line")
                      .classed({"link": true})
                      .attr({"data-link-key": function(d, i) {return d.key;}})
                      .style({"stroke": function(d, i) {
                                          switch(d.type) {
                                            case "cited":
                                              return "tomato";
                                            case "citing":
                                              return "darkgreen";
                                            case "related":
                                              return "darkblue";
                                          }
                                        },
                             "stroke-width": "1px"});                 // add the new links to the SVG (just new links using .enter.append)

        // add the new nodes to the SVG (just new nodes using .enter.append); attach event handler to g.node, but enable
        // pointer events only on the node circles.
        var node = plot.selectAll("g.node").data(force.nodes(), function(d) {return d.key;}).enter().append("svg:g")
                      .classed({"node": true})
                      .attr({"data-patent": function(d, i) {return d.patent_no;}})
                      .on("mouseover.biblio", on_mouseover_force_patent);

        var bibDiv = bib.selectAll("div.bib").data(force.nodes(), function(d) {return d.key;}).enter().append("div")  // add new divs to the main bib div
                      .classed({"bib": true})
                      .attr({"data-patent": function(d, i) {return d.patent_no;}})     // bibDiv is just the new divs (.enter.append)

        plot.selectAll("g.node, line.link").sort(function(a, b) {         // put all node elements after all line elements so nodes on drawn on top of lines
                                                  var aInst = a instanceof PatentNode;     // true or false
                                                  var bInst = b instanceof PatentNode;
                                                  return (aInst == bInst) ? 0 : ((aInst) ? 1 : -1);
                                                }).order();
        allNodes = svg.selectAll("g.node").sort(function(a, b) {         // sort so the source nodes are drawn last so can see labels
                                                  return (a.source < b.source) ? -1 : ((a.source > b.source) ? 1 : 0);
                                                }).order();              // need to be sure to select all nodes currently on the map before re-starting
        allBibs = bib.selectAll("div.bib");
        allLinks = svg.selectAll("line.link");                           // the force map so the tick event handler deals with all the nodes on the map!

        updateXAxisLimits();                                             // update the x-axis plot limits in pParam
        updateXAxisContent();                                            // update the tick locations and labels for xAxisLabel and xAxisGrid
        updatePlotScaling();                                             // update the xPlotAxis according to the new plot limits

        // insert the html for the biblio popup that appears when the mouse is over a patent node, and then attach event handlers
        bibDiv.html(function(d, i) {return compiledPop1Template(
                                        {patent_no: d.patent_no, file_date: d.biblio.file_date, pub_date: d.biblio.pub_date,
                                         title: d.biblio.title, inventors: d.biblio.inventors, assignee: d.biblio.assignee,
                                         abstract: d.biblio.abstract});});
        bibDiv.select("div.pop1-container")
              .style({"z-index": function(d, i) {return d.z_index;}});  // top-level div in the html added under the div.bib

        bibDiv.select("a.pop1-patent-url")
                       .on("click.biblio", on_click_new_patent_url_map);
        bibDiv.select("a.pop1-search-url")
                       .on("click.biblio", on_click_new_search_url_map);
        bibDiv.select("div.pop1-top-btns")
                       .on("click.biblio", on_click_top_buttons_biblio);
        bibDiv.each(function(d,i) {setupMapFavButtons(this, document, "map", d.patent_no);});  // set up map and favorite buttons
        bibDiv.each(function(d,i) {d3.select(this).select("span.btn-hide-add")                 // set up the delete button
                                       .attr({"data-patent": function(ds, is) {return d.patent_no;}})
                                       .on("click.biblio", on_click_delete_btn);});
        bibDiv.each(function(d,i) {d3.select(this).select("span.btn-pin-add")                 // set up the delete button
                                       .attr({"data-patent": function(ds, is) {return d.patent_no;}})
                                       .on("click.biblio", on_click_pin_btn);});

        force.start();
        // finish appending svg elements 
        node.append("svg:circle").classed("force-patent-circle", true)   // make each node a circle
                                 .attr({"r": 7, "data-patent": function(d, i) {return d.patent_no;}});

        node.append("svg:text").text(function(d, i) {return d.label})    // add the node labels to the SVG
              .classed("node-label", true)
              .attr({"text-anchor": "middle", "dominant-baseline": "middle", "data-patent": function(d, i) {return d.patent_no;}});

        node.each(function(d,i) {setupMapFavMarkers(this, document, d.patent_no);}).each(function(d, i) {addToLegend(d, i);});

        updateLegend();

        // update the node colors
        allNodes.each(updateForceMapSymbolColor);

        node.call(force_drag);                                           // allows nodes to be dragged with the mouse
//        bibDiv.call(force_drag);
      }

      function updateForceMapSymbolColor(d, i) {
        var legendKey = LegendEntry.makeShort(d.biblio.assignee);
        var legendColor = (legendObjects[legendKey].legendColor != "") ? legendObjects[legendKey].legendColor : legendObjects["AllOthers"].legendColor;
        d3.select(this).selectAll("circle.force-patent-circle, circle.force-mapped-circle, circle.force-favorite-circle")
              .style({"fill": legendColor});        
      }

      function updateLegend() {
        // determine if we need to have an 'AllOthers' entry in the legend; add a LegendEntry object if needed
        if ("AllOthers" in legendObjects) {
          if (legendEntries.length <= nLegendEntry + 1) {       // need to delete the 'AllOthers' entry, leaving nLegendEntry entries
            var ao_Index = legendEntries.indexOf(legendObjects["AllOthers"]);
            legendEntries.splice(ao_Index, 1);
            delete legendObjects["AllOthers"];
          }
          else {                                                // need the existing 'AllOthers' entry
            legendObjects["AllOthers"].patentCount = 0;
          }
        }
        else {                                                  // 'AllOthers' entry does not exist
          if (legendEntries.length > nLegendEntry) {            // need to create one
            legendObjects["AllOthers"] = new LegendEntry("Others", "", 0)
            legendEntries.push(legendObjects["AllOthers"]);
          }
        }

        legendEntries.sort(function(a, b) {if (a.patentCount < b.patentCount) return 1;                // sort in descending order
                                           if (a.patentCount > b.patentCount) return -1;
                                           return 0;
                                          });
        if ("AllOthers" in legendObjects) {                              // calculate the number of 'Others' patents and insert as the last entry
          for (var iL = nLegendEntry - 1; iL < legendEntries.length - 1; iL++) {   // the last entry is 'Others' at this point
            var notShownEntry = legendEntries[iL]
            legendObjects["AllOthers"].patentCount += notShownEntry.patentCount;
            if (notShownEntry.legendColor != "") {
              recycleLegendColor(notShownEntry);
            }
          }
          var ao_Index = legendEntries.indexOf(legendObjects["AllOthers"]);
          legendEntries[ao_Index] = legendEntries[nLegendEntry - 1];     // swap the last legend entry at nLegendEntry-1 for the 'Others' entry
          legendEntries[nLegendEntry - 1] = legendObjects["AllOthers"];
        }

        // now update the SVG for the legend
        var curLegendItem = legend.selectAll("g.legend-entry").data(legendEntries.slice(0,nLegendEntry));  // show only the first nLegendEntries entries
        curLegendItem.select("circle.legend-symbol");                                                      // propagate the new data to the child elements!
        curLegendItem.select("text.legend-text");
        var newLegendItem = curLegendItem.enter().append("svg:g").classed({"legend-entry": true});         // add new legend entries
        newLegendItem.append("svg:circle").classed({"legend-symbol": true}).attr({"r": 5});
        newLegendItem.append("svg:text").classed({"legend-text": true});
        curLegendItem.exit().remove();
        curLegendItem = legend.selectAll("g.legend-entry");                                            // refresh the data for the legend SVG
        curLegendItem.attr({"transform": function(d, i) {return "translate(0," + i*14 + ")";}});       // list the entries
        curLegendItem.selectAll("circle.legend-symbol")
                            .style({"fill": function(d, i) {return (d.legendColor != "") ? d.legendColor : getNewLegendColor(d);}});
        curLegendItem.selectAll("text.legend-text").attr({"transform": "translate(15,0)", "dominant-baseline": "middle"})
                            .text(function(d, i) {return d.assignee + " (" + d.patentCount + ")";});
      }

      function recycleLegendColor(legendEntry) {
      // puts legendEntry.legendColor back in the list of available colors
        legendColors.push(legendEntry.legendColor);                  // add to end of color list
        legendEntry.legendColor = "";
      }

      function getNewLegendColor(d) {
      // assigns an unused legend color to d.legendColor
        d.legendColor = legendColors.shift();                        // pop from beginning of color list
        return d.legendColor;
      }

      function addToLegend(d, i) {
      // d is a PatentNode, i is its index in patentNodes
        var assignee = d.biblio.assignee
        var shortAssignee = LegendEntry.makeShort(assignee);         // use first six letters of first word as basis of matching an assignee name
        if (shortAssignee in legendObjects) {
          legendObjects[shortAssignee].patentCount +=1;
        }
        else {                                                        // add object for this assignee to legendObjects and add to the legend entry array
          assignee = (assignee != "") ? assignee : shortAssignee;
          legendObjects[shortAssignee] = new LegendEntry(assignee, "", 1);
          legendEntries.push(legendObjects[shortAssignee]);
        }
      }

      function setupMapFavMarkers(nodeElem, $context, patent_no) {
      // SVG elements do not have innerHTML properies that allows us to add SVG on the fly using d3 .html() or jQuery .after();
      // one way to get around this is to follow suggestion in d3 documentation, and add innersvg.js polyfill at
      // https://code.google.com/p/innersvg via a script tag in the document header; (need to apply patch to use the <use> tag;
      // the alternative, which I ended up going with is to add all the svg using d3 
        var patentNode = d3.select(nodeElem);
        if (patentLists["favorites"].indexOf(patent_no) != -1) {
          var marker = patentNode.insert("svg:g", "text").classed("force-favorite-marker", true);
          marker.append("svg:circle").classed({"force-favorite-circle": true})  // event handler is attached to the parent g.node
                .attr({"r": "10", "data-patent": patent_no});
          marker.append("svg:use").attr({"xlink:href": "#force-favorite-heart-def"});
        }
        if (patentLists["map"].indexOf(patent_no) != -1) {               // will show the mapped marker on top of the favorite marker if patent is in both lists
          var marker = patentNode.insert("svg:g", "text").classed("force-mapped-marker", true);
          marker.append("svg:circle").classed({"force-mapped-circle": true})
                .attr({"r": "10", "data-patent": patent_no});
          marker.append("svg:use").attr({"xlink:href": "#force-mapped-cross-def"});
        }
      }

      function updatePlotScaling() {
      // update the scales to transform force map coordinates to plotting coordinates.
        xForceToPlotScale.range([xPlotScale(fMap.minDate), xPlotScale(fMap.maxDate)]);
        yForceToPlotScale.range([yPlotScale(0), yPlotScale(fMap.h)]);
      }

      function replotForceMap() {
        allNodes.each(function(d, i) {
                        d.updatePlotCoord();});             // update the SVG plotting coordinates .plotX and .plotY
                        
        allNodes.call(updateNode);                          // move force map nodes to their new positions
        allBibs.call(updateBib);                            // move force map biblio popups
        allLinks.call(updateLink);                          // move force map links
      }

      function on_zoom() {
        console.log(d3.event);
        pParam.minX = xPlotScale.invert(0);
        pParam.maxX = xPlotScale.invert(plotWidth);
        var totalTransY = zoom.translate()[1];
        if (zoom.scale() == pParam.scale) {                 // pan: only apply the y translation if the zoom event was panning
          pParam.panTransY = totalTransY - pParam.zoomTransY
          yPlotScale.domain([pParam.minY - pParam.panTransY, pParam.maxY - pParam.panTransY]);  // apply pan portion of translation to the y axis
        }
        else {                                              // zoom: update the zoom-induced component of the translation
          pParam.scale = zoom.scale();
          pParam.zoomTransY = totalTransY - pParam.panTransY;   // zooming to a new scale induces a translation which we need to remove
        }
        updateXAxisContent();        
        updatePlotScaling();
        replotForceMap();
      }

      function on_zoomY() {
      }

      function updateXAxisLimits() {
      // calculate the new x-axis plot limits and store in pParam; update the xPlotScale
        if (allNodes[0].length > 0) {
          var d3_format = d3.time.format("%Y");
          var dateNow = new Date();
          var maxDate = d3.max(allNodes.data(), function(d) {return d.date;});
          var minDate = d3.min(allNodes.data(), function(d) {return d.date;});
          var padDate = 0.125*(maxDate.getTime() - minDate.getTime());
          pParam.minDate = d3.time.year.floor(new Date(minDate.getTime() - padDate));
          pParam.maxDate = d3.time.year.ceil(new Date(Math.min(maxDate.getTime() + padDate, dateNow.getTime())));
          var minYear = pParam.minDate.getFullYear();
          var maxYear = pParam.maxDate.getFullYear();
          var nYears = maxYear - minYear;
          if (isNaN(nYears) || nYears < 5) {
            var addYears = 5 - nYears;                                     // minimum interval for x axis is 5 years
            var padHigh = Math.floor(addYears/2);
            maxYear = Math.min(maxYear + padHigh, d3.time.year.ceil(dateNow).getFullYear());
            pParam.maxDate = d3_format.parse((maxYear).toString());
            pParam.minDate = d3_format.parse((maxYear - 5).toString());
          }
console.log("minDate: ", pParam.minDate, "maxDate: ", pParam.maxDate);
          // update the domain of xPlotScale based on filing date of patents on the force map;
          pParam.minX = (pParam.minX < pParam.minDate) ? pParam.minX : pParam.minDate;
          pParam.maxX = (pParam.maxX > pParam.maxDate) ? pParam.maxX : pParam.maxDate;
          xPlotScale.domain([pParam.minX, pParam.maxX]);
          zoom.x(xPlotScale);                                              // need to call zoom.x when xPlotScale is updated
          var xRange = (pParam.maxX.getTime() - pParam.minX.getTime())/(365.25*24*60*60*1000)  // x-axis range in years
          zoom.scaleExtent([xRange/300, xRange/1.2]);
        }
      }

      function updateXAxisContent() {
      // calculate new x-axis labels and gridlines; update the xAxisLabel and xAxisGrid axes

        if (allNodes[0].length > 0) {
          var nYears = pParam.maxX.getFullYear() - pParam.minX.getFullYear();
          var tickInt = d3.time.year;                         // default tick interval unit
          var gridInt = d3.time.year;                         // default grid interval unit
          if (nYears < 1) {
            var tickNo = 1;
            var gridInt = d3.time.month;                      // override default grid interval
            var gridNo = 1;
          }
          else if (1 <= nYears && nYears <= 2) {
            var tickNo = 1;
            var gridInt = d3.time.month;                      // override default grid interval
            var gridNo = 1;
          }
          else if (3 <= nYears && nYears <= 4) {
            var tickNo = 1;
            var gridInt = d3.time.month;                      // override default grid interval
            var gridNo = 3;
          }
          else if (5 <= nYears && nYears <= 12) {
            var tickNo = 1;
            var gridInt = d3.time.month;                      // override default grid interval
            var gridNo = 6;
          }
          else if (13 <= nYears && nYears <= 24) {
            var tickNo = 2;
            var gridNo = 1;
          }
          else if (25 <= nYears && nYears <= 36) {
            var tickNo = 4;
            var gridNo = 1;
          }
          else if (37 <= nYears && nYears <= 60) {
            var tickNo = 5;
            var gridNo = 1;
          }
          else if (61 <= nYears && nYears <= 120) {
            var tickNo = 10;
            var gridNo = 2;
          }
          else if (121 <= nYears && nYears <= 240) {
            var tickNo = 20;
            var gridNo = 4;
          }
          else if (241 <= nYears && nYears <= 360) {
            var tickNo = 40;
            var gridNo = 10;
          }
          else if (361 <= nYears && nYears <= 500) {
            var tickNo = 50;
            var gridNo = 10;
          }
          else {
            console.log("Unexpected xAxis range in updateXAxisContent")
          }
          xAxisLabel.ticks(tickInt, tickNo).scale(xPlotScale);              // create the tick label HTML generating function
          xAxisGrid.ticks(gridInt, gridNo).scale(xPlotScale);               // create the gridline HTML generating function
          xAxisLabelSVG.call(xAxisLabel);                                   // add tick labels to the plot
          xAxisGridSVG.call(xAxisGrid);                                     // add gridlines to the plot
          d3.selectAll("g.x-axis-label > g.tick > line").remove();          // remove tick mark from label
          d3.selectAll("g.x-axis-grid > g.tick > text").remove();           // remove text from gridlines
        }
      }

      function deleteLink(patentLink) {
      // delete patentLink (of type PatentLink) from the force map; but do not delete the patentLink itself;
        var linkKey = patentLink.key;
console.log(linkKey);
        patentLinks.splice(patentLinks.indexOf(patentLink), 1);           // remove 1 patentLink from patentLinks at the index
        delete linkIndex[linkKey];                                        // remove the entry for the link in linkIndex
        patentLink.source.weight -= 1;                                    // update weights of the sourceNode and targetNode
        patentLink.target.weight -= 1;
console.log(        d3.select("line.link[data-link-key=" + linkKey + "]"));   // remove the line.link SVG element
        d3.select("line.link[data-link-key=" + linkKey + "]").remove();   // remove the line.link SVG element
      }

      function deleteNode(patentNode) {
      // delete patentNode (of type PatentNode) from the force map; but do not delete patentNode itself;
      // $bibDiv is the jQuery object for the div.bib associated with patentNode;
      // if deleted patent is a source patent, delete it from the patentLists["map"] list and unclick all the associated map buttons;
	var patent_no = patentNode.patent_no;
        var $bibDiv = $("div.bib[data-patent='" + patent_no + "']");      // the div.bib associated with this patent
        patentNodes.splice(patentNodes.indexOf(patentNode), 1);           // remove 1 patentNode from patentNodes at the index
        delete patentIndex[patent_no];                                    // remove the entry for the patent from patentIndex
        if (patentNode.source) {                                          // if a sourceNode
          var $mapBtn = $bibDiv.find("span.btn-map-add");                 // get the map button element associated with this patent on the force map
          toggleBtn(patent_no, $mapBtn, "remove");
          patentLists["map"].splice(patentLists["map"].indexOf(patent_no), 1);
        }
        var shortAssignee = LegendEntry.makeShort(patentNode.biblio.assignee);
        var legendEntry = legendObjects[shortAssignee];
        legendEntry.patentCount -= 1;
        if (legendEntry.patentCount == 0) {                               // if no other patents from this company
          var leIndex = legendEntries.indexOf(legendEntry);               // delete patent from the legendEntries
          legendEntries.splice(leIndex, 1);
          if (legendEntry.legendColor != "") {
            recycleLegendColor(legendEntry);          
          }
          delete legendObjects[shortAssignee];                            // and from the legendObjects collection
        }
        $bibDiv.remove();                                                 // remove the div.bib HTML
        d3.select("g.node[data-patent=" + patent_no + "]").remove();      // remove the g.node SVG
      }

      function on_click_pin_btn(d, i) {
//        d3.event.preventDefault();
//        d3.event.stopPropagation();
        var pinBtn = d3.select(this);
        var patent_no = pinBtn.attr("data-patent");
        var divPop = d3.select("div.pop1-container[data-patent=" + patent_no + "]");
console.log("Begin on_click_pin_btn");
        if (pinBtn.classed("show-result-btn")) {                          // unpin the biblio
console.log("In on_click_pin_btn, start unpin");
          pinBtn.classed({"show-result-btn": false});                     // give button the unpressed look
console.log("In on_click_pin_btn, start pop1-pinned");
          divPop.classed({"pop1-pinned": false});                         // class indicates that biblio is not pinned
          visBiblio.push(divPop);
        }
        else {
console.log("In on_click_pin_btn, start pin");
          pinBtn.classed({"show-result-btn": true});                      // pin the biblio
console.log("In on_click_pin_btn, start pop1-pinned");
          divPop.classed({"pop1-pinned": true});
          visBiblio.pop();
        }
      }

      function on_click_delete_btn(d, i) {
      // delete the patent and associated links from the force map; keep the biblio data available in case the node is replotted;
      // delete from patentNodes and patentLinks arrays which provide data for d3;
      // delete from patentIndex and linkIndex objects which track which patents and links are plotted;
      // delete nodes whose only link is to the node being deleted;
      // if deleted patent is a source patent, delete it from the patentLists["map"] list and unclick all the associated map buttons;
        d3.event.preventDefault();
        d3.event.stopPropagation();
        d3.select("div.bib-container").classed({"bib-container-front": false});   // if delete was clicked in full biblio view
        var patent_no = d3.select(this).attr("data-patent");
        removePatentFromMap(patent_no);
      }

      function removePatentFromMap(patent_no) {
      // remove patent patent_no from the force map.
        fMap.alpha = force.alpha();
        var patentNode = d3.select("div.bib[data-patent=" + patent_no + "]").datum();
        var isSource = patentNode.source;
        deleteNode(patentNode);                                           // delete patentNode from the force map

        for (var i=patentLinks.length; i > 0; i--) {                      // now delete the links associated with patentNode
          var patentLink = patentLinks[i-1];                              // take links in reverse order, so deleting some does not mess up for loop;
          if (patentLink) {                                               // using delete on an array leaves the element in place with
            if (patentLink.source == patentNode) {                        // an undefined value
              var targetNode = patentLink.target;
              deleteLink(patentLink);
              if (targetNode.weight == 0) {                               // if the targetNode is now disconnected, delete the targetNode also
                deleteNode(targetNode);
              }
            }
            if (patentLink.target == patentNode) {
              var sourceNode = patentLink.source;
              deleteLink(patentLink);
              if (sourceNode.weight == 0) {                               // if the sourceNode is now disconnected, let the source node stay on the map
//                deleteNode(sourceNode);
              }
            }
          }        
        }
        updateLegend();
        allNodes = svg.selectAll("g.node");
        allNodes.each(updateForceMapSymbolColor);
        if (isSource) {
          force.start();                                                  // let map rearrange itself significantly
        }
        else {
          force.start();
          force.alpha(Math.max(fMap.alpha, 0.06));                        // let map relax somewhat
        }
      }

      function removePatentFromFavorites(patent_no, $favBtn) {
        d3.select("g.node[data-patent=" + patent_no + "] g.force-favorite-marker").remove();
        toggleBtn(patent_no, $favBtn, "remove");
        patentLists["favorites"].splice(patentLists["favorites"].indexOf(patent_no), 1);
      }

      function on_click_new_patent_url_map(d, i) {
      // need to call the on_click_new_patent_url event handler set up by jQuery, which is expecting the event object
      // as the only argument and event data in event.data
        d3.event.data = {$context: document, page: "map"};
        on_click_new_patent_url.call(this, d3.event);
      }

      function on_click_new_search_url_map(d, i) {
      // need to call the on_click_new_search_url event handler set up by jQuery, which is expecting the event object
      // as the only argument
        on_click_new_search_url.call(this, d3.event);
      }

      function on_mouse_main_svg() {
      // the .elementFromPoint method only returns an element if pointer events are enabled on it
      // <a> elements do not pass mousemove events through them
        // there must never be more than one entry in the visBiblio list of unpinned div.pop1-containers
        if (visBiblio.length > 0) {
          var divPop = visBiblio[0].classed({"pointer-events-auto": true});        // activate mouse events
          var topElement = document.elementFromPoint(d3.event.x, d3.event.y);      // see if the biblio is the topmost element
console.log("topElement", topElement);
          divPop.classed({"pointer-events-auto": false});
          if (topElement == zoom_rect.node() || topElement == svg_main.node()) {
            if (!divPop.classed("pop1-pinned")) {            // if the biblio is not pinned make it disappear
              on_mouseout_force_biblio(divPop);
              visBiblio.pop();
            }
            force.alpha(Math.max(fMap.alpha, 0.06));
          }
        }
      }

      function on_mouseover_force_patent(d, i) {
console.log("Hello from mouseover_force_patent");
        fMap.alpha = force.alpha();
        force.stop();
        // there must never be more than one entry in the visBiblio list of unpinned div.pop1-containers
        if (visBiblio.length > 0) {                      // make any visible, unpinned biblios disappear
          var vis_divPop = visBiblio.pop();
          on_mouseout_force_biblio(vis_divPop);
        }
        var patent_no = d3.select(this).attr("data-patent");
        d3.select("text.node-label[data-patent=" + patent_no + "]").classed({"visited-label": true});
        var divPop = d3.select("div.pop1-container[data-patent=" + patent_no + "]")
        if (!divPop.classed("pop1-pinned")) {            // if the biblio is not pinned (i.e., already visible)
          divPop.classed({"make-displayed": true});
          divPop.selectAll("span.hide-result-btn").classed({"make-visible": true});
          visBiblio.push(divPop);
        }
        allLinks.filter(function(d, i) {return (d.source.patent_no == patent_no || d.target.patent_no == patent_no);})
                .style({"stroke-width": function(d, i) {return (d.source.patent_no == patent_no) ? "3px" : "4px";}});  // highlight links to the node
      }

      function on_mouseover_force_biblio(d, i) {
      // event handler is attached to the pop1-container, whose parent is the div.bib
console.log("Hello from mouseover_force_biblio");
        var patent_no = d3.select(this).attr("data-patent");
//        d3.select("text.node-label[data-patent=" + patent_no + "]").classed({"make-hidden": true});
        d3.select("div.pop1-container[data-patent=" + patent_no + "]").classed({"make-displayed": true});    // .on("mousedown.drag", null);   // disable biblio dragging in case the user clicks next
//        var viewFull = d3.select("div.bib-container").classed("bib-container-front");       // keep label in view if viewing full biblio
//        var text_element = g_element.select("text").classed({"make-hidden": !viewFull});
        allLinks.filter(function(d, i) {return (d.source.patent_no == patent_no || d.target.patent_no == patent_no);})
                .style({"stroke-width": function(d, i) {return (d.source.patent_no == patent_no) ? "3px" : "4px";}});  // highlight links to the node
      }

      function on_mouseout_force_biblio(divPop) {
      // not an event handler, but part of simulating a mouseout event on a div.pop1-container whose parent is the div.bib
      // called from on_mouseover_force_patent and on_mouse_main_svg
console.log("Hello from mouseout_force_biblio");
//        force.alpha(Math.max(fMap.alpha, 0.06));
        var patent_no = divPop.attr("data-patent");     // d3.select(this).attr("data-patent");
//        d3.select("text.node-label[data-patent=" + patent_no + "]").classed({"make-hidden": false});
        if (!divPop.classed("pop1-pinned")) {            // if the biblio is not pinned (i.e., already visible)
          divPop.classed({"make-displayed": false});
          divPop.selectAll("span.hide-result-btn").classed({"make-visible": false});
        }
        allLinks.filter(function(d, i) {return (d.source.patent_no == patent_no || d.target.patent_no == patent_no);})
                .style({"stroke-width": "1px"});                                    // normal width links to the node
      }

      function on_click_top_buttons_biblio(d, i) {
      // event handler is attached to the div.pop1-top-btns element; event target elements are
      // rect.pop1-full-btn, rect.pop1-close-btn, rect.pop1-front-btn, and rect.pop1-back-btn.
        d3.event.stopPropagation();
        d3.event.preventDefault();
        var patent_no = d3.select(this).attr("data-patent");
        var clickedClass = d3.select(d3.event.target).attr("class");
        switch (clickedClass) {
          case "pop1-full-btn":                        // go to the full biblio
            visFullBiblio.push(visBiblio.pop());       // so full biblio does not disappear when mouse moves into main svg element
            d3.select("div.bib-container").classed({"bib-container-front": true}); // block mouse events from reaching the force map
            var divPop = d3.select("div.pop1-container[data-patent=" + patent_no+"]").classed({"pointer-events-auto": true});
//            divPop.select("div.pop1-arrow").classed({"make-hidden": true});                          // hide the little arrow
            divPop.selectAll("div.pop1-inventors, div.pop1-abstract").classed({"make-displayed": true});
//            d3.select("text.node-label[data-patent=" + patent_no + "]").classed({"make-hidden": false});  // keep label in view if viewing full biblio
//            d3.select("div.bib[data-patent=" + patent_no + "]")
//              .style({"-webkit-transform": "translate(" + plotWidth/2 + "px," + Math.max((plotHeight - $(divPop.node()).outerHeight())/2, 20) + "px)",      // Chrome; use jQuery outerHeight() method to get dimensions of the div.pop1-container
//                      "transform": "translate(" + plotWidth/2 + "px," + Math.max((plotHeight - $(divPop.node()).outerHeight())/2, 20) + "px)"});            // FireFox
            d3.select(this).select("g.pop1-close").classed({"make-not-displayed": false});
            d3.select(this).select("g.pop1-full").classed({"make-not-displayed": true});
            break;
          case "pop1-close-btn":                       // go to the short biblio - undo changes above
            d3.select(this).select("g.pop1-full").classed({"make-not-displayed": false});
            d3.select(this).select("g.pop1-close").classed({"make-not-displayed": true});
//            d3.select("div.bib[data-patent=" + patent_no+"]")
//              .style({"-webkit-transform": function(d, i) {return "translate(" + d.plotX + "px," + d.plotY + "px)";},            // Chrome
//                      "transform": function(d, i) {return "translate(" + d.plotX + "px," + d.plotY + "px)";}});                  // FireFox
            var divPop = d3.select("div.pop1-container[data-patent=" + patent_no+"]").classed({"pointer-events-auto": false});
//            divPop.select("div.pop1-arrow").classed({"make-hidden": false});                          // show the little arrow
            divPop.selectAll("div.pop1-inventors, div.pop1-abstract").classed({"make-displayed": false});
//            d3.select("text.node-label[data-patent=" + patent_no + "]").classed({"make-hidden": true});       // hide label
            d3.select("div.bib-container").classed({"bib-container-front": false});
            visBiblio.push(visFullBiblio.pop());
            break;
          case "pop1-front-btn":
            pParam.zMax += 1;
            d3.select(this).datum().z_index = pParam.zMax;
            d3.select("div.bib[data-patent=" + patent_no+"]").style({"z-index": pParam.zMax});  // must set z-index on siblings
            break;
          case "pop1-back-btn":
            pParam.zMin -= 1;
            d3.select(this).datum().z_index = pParam.zMin;
            d3.select("div.bib[data-patent=" + patent_no+"]").style({"z-index": pParam.zMin});
            break;
        }
      }
    </script>
  </body>
</html>
